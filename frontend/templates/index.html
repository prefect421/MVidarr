{% extends "base.html" %}

{% block title %}Dashboard - MVidarr{% endblock %}

{% block content %}
<div class="dashboard-container">
    
    <div class="dashboard-stats">
        <div class="stat-card">
            <h3>Tracked Artists</h3>
            <p class="stat-number" id="artists-count">0</p>
        </div>
        <div class="stat-card">
            <h3>Total Videos</h3>
            <p class="stat-number" id="videos-count">0</p>
        </div>
        <div class="stat-card">
            <h3>System Status</h3>
            <p class="stat-status" id="system-status">Checking...</p>
        </div>
    </div>

    <div class="dashboard-actions">
        <button onclick="window.location.href='{{ url_for('frontend.artists') }}'" class="btn btn-primary">
            Add Artist
        </button>
        <button onclick="showAddVideoModal()" class="btn btn-primary">
            Add Video
        </button>
        <button onclick="window.location.href='{{ url_for('frontend.videos') }}'" class="btn btn-secondary">
            Browse Videos
        </button>
        <button onclick="downloadAllWantedVideos()" class="btn btn-success" id="download-wanted-btn">
            Download All Wanted
        </button>
    </div>


    <div class="downloads-section">
        <div class="downloads-header">
            <h2>Download Queue</h2>
            <div class="queue-actions">
                <button onclick="clearStuckDownloads()" class="btn btn-warning btn-sm">Clear Stuck Downloads</button>
            </div>
        </div>
        <div id="download-queue-list">
            <p>Loading download queue...</p>
        </div>
    </div>

    <div class="recent-activity">
        <div class="history-header">
            <h2>Download History</h2>
            <div class="history-actions">
                <button onclick="clearDownloadHistory()" class="btn btn-danger btn-sm">Clear History</button>
                <button onclick="loadDownloadHistory()" class="btn btn-secondary btn-sm">Refresh</button>
            </div>
        </div>
        <div id="download-history-list">
            <p>Loading download history...</p>
        </div>
    </div>
</div>

<script>
// Auto-refresh interval for download queue
let queueRefreshInterval;
let previousQueueLength = 0;

// Load dashboard data
document.addEventListener('DOMContentLoaded', function() {
    loadDashboardStats();
    loadSystemStatus();
    loadDownloadQueue();
    loadDownloadHistory();
    
    // Start auto-refresh for download queue every 2 seconds
    startQueueAutoRefresh();
});

function startQueueAutoRefresh() {
    // Clear any existing interval
    if (queueRefreshInterval) {
        clearInterval(queueRefreshInterval);
    }
    
    // Set up new interval
    queueRefreshInterval = setInterval(() => {
        loadDownloadQueue();
        loadDownloadHistory(); // Also refresh history during active downloads
    }, 2000); // Refresh every 2 seconds
}

function stopQueueAutoRefresh() {
    if (queueRefreshInterval) {
        clearInterval(queueRefreshInterval);
        queueRefreshInterval = null;
    }
}

function getStatusDisplay(status, progress) {
    switch(status) {
        case 'pending':
            return 'Pending';
        case 'downloading':
            return `Downloading (${progress || 0}%)`;
        case 'completed':
            return 'Completed';
        case 'failed':
            return 'Failed';
        default:
            return status;
    }
}

function loadDashboardStats() {
    // Load artists count
    fetch('/api/artists/')
        .then(response => response.json())
        .then(data => {
            document.getElementById('artists-count').textContent = data.total || 0;
        });

    // Load videos count
    fetch('/api/videos/')
        .then(response => response.json())
        .then(data => {
            document.getElementById('videos-count').textContent = data.count || 0;
        });
}

function loadSystemStatus() {
    fetch('/api/health/status')
        .then(response => response.json())
        .then(data => {
            const statusElement = document.getElementById('system-status');
            statusElement.textContent = data.status === 'healthy' ? 'Healthy' : 'Issues Detected';
            statusElement.className = 'stat-status ' + (data.status === 'healthy' ? 'healthy' : 'unhealthy');
        })
        .catch(error => {
            document.getElementById('system-status').textContent = 'Error';
            document.getElementById('system-status').className = 'stat-status unhealthy';
        });
}

function loadDownloadQueue() {
    fetch('/api/metube/queue')
        .then(response => response.json())
        .then(data => {
            const queueDiv = document.getElementById('download-queue-list');
            
            // Check if queue size changed (downloads completed/added)
            const currentQueueLength = data.queue ? data.queue.length : 0;
            if (previousQueueLength !== currentQueueLength && previousQueueLength !== 0) {
                // Queue changed - refresh history to show completed downloads
                console.log(`Queue size changed from ${previousQueueLength} to ${currentQueueLength}, refreshing history`);
                loadDownloadHistory();
            }
            previousQueueLength = currentQueueLength;
            
            // Check if there are active downloads
            const hasActiveDownloads = data.queue && data.queue.some(d => 
                d.status === 'downloading' || d.status === 'pending'
            );
            
            // Auto-manage refresh based on active downloads
            if (hasActiveDownloads && !queueRefreshInterval) {
                startQueueAutoRefresh();
            } else if (!hasActiveDownloads && queueRefreshInterval) {
                // Slow down refresh when no active downloads
                clearInterval(queueRefreshInterval);
                queueRefreshInterval = setInterval(() => {
                    loadDownloadQueue();
                    loadDownloadHistory(); // Also refresh history when checking queue
                }, 10000); // Check every 10 seconds instead of 2
            }
            
            if (data.queue && data.queue.length > 0) {
                queueDiv.innerHTML = data.queue.map(download => `
                    <div class="download-item ${download.status}">
                        <div class="download-info">
                            <div class="download-header">
                                <div class="download-title">
                                    <strong>${download.title}</strong><br>
                                    <small>by ${download.artist} ‚Ä¢ ${getStatusDisplay(download.status, download.progress)}</small>
                                </div>
                                <div class="download-actions">
                                    ${download.status === 'downloading' || download.status === 'pending' ? 
                                        `<button onclick="stopDownload(${download.id})" class="btn-icon btn-stop" title="Stop Download">
                                            <span>‚èπ</span>
                                        </button>
                                        <button onclick="retryDownload(${download.id})" class="btn-icon btn-retry" title="Retry Download">
                                            <span>üîÑ</span>
                                        </button>` : ''
                                    }
                                </div>
                            </div>
                            <div class="download-progress">
                                <div class="progress-bar">
                                    <div class="progress" style="width: ${download.progress || 0}%"></div>
                                </div>
                                <div class="progress-text">${download.progress || 0}%</div>
                            </div>
                            ${download.error_message ? `<div class="error-msg">${download.error_message}</div>` : ''}
                        </div>
                    </div>
                `).join('');
            } else {
                queueDiv.innerHTML = '<p>No downloads in queue</p>';
            }
        })
        .catch(error => {
            document.getElementById('download-queue-list').innerHTML = '<p>Error loading download queue</p>';
        });
}

function loadDownloadHistory() {
    fetch('/api/metube/history?limit=10')
        .then(response => response.json())
        .then(data => {
            const historyDiv = document.getElementById('download-history-list');
            
            if (data.history && data.history.length > 0) {
                historyDiv.innerHTML = data.history.map(download => `
                    <div class="download-item ${download.status}">
                        <div class="download-info">
                            <div class="download-header">
                                <div class="download-title">
                                    <strong>${download.title}</strong><br>
                                    <small>by ${download.artist} ‚Ä¢ ${download.status} ‚Ä¢ ${new Date(download.updated_at).toLocaleString()}</small>
                                    ${download.file_size ? `<div class="file-info">File size: ${formatFileSize(download.file_size)}</div>` : ''}
                                </div>
                                <div class="download-actions">
                                    ${download.status === 'failed' ? 
                                        `<button onclick="retryDownload(${download.id})" class="btn-icon btn-retry" title="Retry Failed Download">
                                            <span>üîÑ</span>
                                        </button>` : ''
                                    }
                                </div>
                            </div>
                            ${download.error_message ? `<div class="error-msg">${download.error_message}</div>` : ''}
                        </div>
                    </div>
                `).join('');
            } else {
                historyDiv.innerHTML = '<p>No download history</p>';
            }
        })
        .catch(error => {
            document.getElementById('download-history-list').innerHTML = '<p>Error loading download history</p>';
        });
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function clearDownloadHistory() {
    toastConfirm('Are you sure you want to clear all download history? This action cannot be undone.', () => {
        proceedClearDownloadHistory();
    });
}

function proceedClearDownloadHistory() {
    
    fetch('/api/metube/history/clear', {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(`Successfully cleared ${data.deleted_count} download history records`);
            loadDownloadHistory(); // Refresh the history display
        } else {
            showError('Error clearing download history: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error clearing download history:', error);
        showError('Error clearing download history: ' + error.message);
    });
}

function stopDownload(downloadId) {
    toastConfirm('Are you sure you want to stop this download?', () => {
        proceedStopDownload(downloadId);
    });
}

function proceedStopDownload(downloadId) {
    
    fetch(`/api/metube/download/${downloadId}/stop`, {
        method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(`Download stopped: ${data.message}`);
            loadDownloadQueue(); // Refresh the queue display
            loadDownloadHistory(); // Refresh history to show stopped download
        } else {
            showError('Error stopping download: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error stopping download:', error);
        showError('Error stopping download: ' + error.message);
    });
}

function retryDownload(downloadId) {
    toastConfirm('Are you sure you want to retry this download?', () => {
        proceedRetryDownload(downloadId);
    });
}

function proceedRetryDownload(downloadId) {
    
    fetch(`/api/metube/download/${downloadId}/retry`, {
        method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(`Download restarted: ${data.message}`);
            loadDownloadQueue(); // Refresh the queue display
            loadDownloadHistory(); // Refresh history
        } else {
            showError('Error retrying download: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error retrying download:', error);
        showError('Error retrying download: ' + error.message);
    });
}

function downloadAllWantedVideos() {
    proceedDownloadWantedVideos();
}

function clearStuckDownloads() {
    toastConfirm('Clear downloads stuck at 0% progress for more than 10 minutes?', () => {
        proceedClearStuckDownloads();
    });
}

function proceedClearStuckDownloads() {
    const button = event.target;
    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = 'Clearing...';
    
    fetch('/api/metube/clear-stuck', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            minutes: 10 // Clear downloads stuck for more than 10 minutes
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            if (data.cleared_count > 0) {
                showSuccess(`Cleared ${data.cleared_count} stuck downloads`);
                // Refresh queues to show updated status
                loadDownloadQueue();
                loadDownloadHistory();
            } else {
                showSuccess('No stuck downloads found to clear');
            }
        } else {
            showError('Error clearing stuck downloads: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        console.error('Error clearing stuck downloads:', error);
        showError('Error clearing stuck downloads: ' + error.message);
    })
    .finally(() => {
        button.disabled = false;
        button.textContent = originalText;
    });
}

function proceedDownloadWantedVideos() {
    // Disable the button to prevent multiple clicks
    const button = document.getElementById('download-wanted-btn');
    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = 'Starting Downloads...';
    
    fetch('/api/videos/bulk/download-wanted', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            limit: 100 // Adjust limit as needed
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            if (data.success_count > 0) {
                showSuccess(`Successfully queued ${data.success_count} wanted videos for download!`);
                
                // Show detailed results if there were failures
                if (data.failed_count > 0) {
                    // Categorize failures for better user feedback
                    const failures = data.results.filter(r => !r.success);
                    const failureTypes = {};
                    
                    failures.forEach(failure => {
                        const error = failure.error || 'Unknown error';
                        if (error.includes('malformed')) {
                            failureTypes['Malformed titles'] = (failureTypes['Malformed titles'] || 0) + 1;
                        } else if (error.includes('age-restricted')) {
                            failureTypes['Age-restricted content'] = (failureTypes['Age-restricted content'] || 0) + 1;
                        } else if (error.includes('No URL available')) {
                            failureTypes['No URLs found'] = (failureTypes['No URLs found'] || 0) + 1;
                        } else {
                            failureTypes['Other errors'] = (failureTypes['Other errors'] || 0) + 1;
                        }
                    });
                    
                    // Build detailed error message
                    let errorDetails = `${data.failed_count} videos could not be downloaded:\n`;
                    for (const [type, count] of Object.entries(failureTypes)) {
                        errorDetails += `‚Ä¢ ${type}: ${count}\n`;
                    }
                    errorDetails += '\nTip: Check video titles for cleanup, or manually search for age-restricted content.';
                    
                    setTimeout(() => {
                        showError(errorDetails);
                        console.log('Failed downloads details:', failures);
                    }, 2000);
                }
            } else {
                showSuccess(data.message || 'No wanted videos found to download');
            }
            
            // Refresh dashboard data
            loadDownloadQueue();
            loadDownloadHistory();
            loadDashboardStats();
        } else {
            showError('Error downloading wanted videos: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        console.error('Error downloading wanted videos:', error);
        showError('Error downloading wanted videos: ' + error.message);
    })
    .finally(() => {
        // Re-enable the button
        button.disabled = false;
        button.textContent = originalText;
    });
}

// Add Video Modal Functions
function showAddVideoModal() {
    document.getElementById('addVideoModal').style.display = 'block';
    // Clear previous search results
    document.getElementById('videoSearchResults').style.display = 'none';
    document.getElementById('songTitleInput').value = '';
    document.getElementById('artistNameInput').value = '';
    document.getElementById('songTitleInput').focus();
}

function closeAddVideoModal() {
    document.getElementById('addVideoModal').style.display = 'none';
    document.getElementById('videoSearchResults').style.display = 'none';
    document.getElementById('videoSearchResultsList').innerHTML = '';
}

function searchForVideos() {
    const songTitle = document.getElementById('songTitleInput').value.trim();
    const artistName = document.getElementById('artistNameInput').value.trim();
    
    if (!songTitle) {
        alert('Please enter a song title to search for videos.');
        return;
    }
    
    const searchQuery = artistName ? `${artistName} ${songTitle}` : songTitle;
    
    // Show loading state
    const resultsDiv = document.getElementById('videoSearchResults');
    const resultsList = document.getElementById('videoSearchResultsList');
    
    resultsDiv.style.display = 'block';
    resultsList.innerHTML = '<div class="loading">üîç Searching for videos...</div>';
    
    // Search both IMVDb and YouTube
    Promise.all([
        searchIMVDb(searchQuery, artistName, songTitle),
        searchYouTube(searchQuery, artistName, songTitle)
    ]).then(([imvdbResults, youtubeResults]) => {
        displaySearchResults([...imvdbResults, ...youtubeResults]);
    }).catch(error => {
        console.error('Error searching for videos:', error);
        resultsList.innerHTML = '<div class="error">‚ùå Error searching for videos. Please try again.</div>';
    });
}

async function searchIMVDb(searchQuery, artistName, songTitle) {
    try {
        let imvdbArtistId = null;
        if (artistName) {
            const artistUrl = `/api/imvdb/search-artist?q=${encodeURIComponent(artistName)}`;
            const artistResponse = await fetch(artistUrl);
            
            if (artistResponse.ok) {
                const artistData = await artistResponse.json();
                if (artistData.results && artistData.results.length > 0) {
                    imvdbArtistId = artistData.results[0].id;
                }
            }
        }
        
        // Search for videos
        let videoUrl;
        if (imvdbArtistId) {
            videoUrl = `/api/imvdb/search-videos?artist_id=${imvdbArtistId}&q=${encodeURIComponent(songTitle)}`;
        } else {
            videoUrl = `/api/imvdb/search-videos?q=${encodeURIComponent(searchQuery)}`;
        }
        
        const videoResponse = await fetch(videoUrl);
        if (!videoResponse.ok) {
            return [];
        }
        
        const videoData = await videoResponse.json();
        const videos = videoData.results || [];
        
        return videos.map(video => ({
            source: 'IMVDb',
            id: video.id,
            title: video.song_title || video.title,
            artist: video.artist_name || video.artist,
            thumbnail: video.image?.thumbnail || video.thumbnail,
            year: video.year,
            url: video.permalink || video.url
        }));
    } catch (error) {
        console.error('IMVDb search error:', error);
        return [];
    }
}

async function searchYouTube(searchQuery, artistName, songTitle) {
    try {
        const url = `/api/youtube/search?q=${encodeURIComponent(searchQuery)}&max_results=10`;
        const response = await fetch(url);
        
        if (!response.ok) {
            return [];
        }
        
        const data = await response.json();
        const videos = data.items || [];
        
        return videos.map(video => ({
            source: 'YouTube',
            id: video.id?.videoId || video.id,
            title: video.snippet?.title || video.title,
            artist: artistName || 'Unknown Artist',
            thumbnail: video.snippet?.thumbnails?.medium?.url || video.thumbnail,
            url: `https://youtube.com/watch?v=${video.id?.videoId || video.id}`,
            description: video.snippet?.description || ''
        }));
    } catch (error) {
        console.error('YouTube search error:', error);
        return [];
    }
}

function displaySearchResults(results) {
    const resultsList = document.getElementById('videoSearchResultsList');
    
    if (results.length === 0) {
        resultsList.innerHTML = '<div class="no-results">No videos found for your search.</div>';
        return;
    }
    
    resultsList.innerHTML = results.map(video => `
        <div class="search-result-item">
            <div class="result-thumbnail">
                <img src="${video.thumbnail || '/static/placeholder-video.png'}" alt="${video.title}" onerror="this.src='/static/placeholder-video.png'">
            </div>
            <div class="result-info">
                <div class="result-title">${video.title}</div>
                <div class="result-artist">${video.artist}</div>
                <div class="result-source">${video.source}${video.year ? ` ‚Ä¢ ${video.year}` : ''}</div>
            </div>
            <div class="result-actions">
                <button class="btn btn-primary btn-add-video" 
                        data-source="${video.source}" 
                        data-video-id="${video.id}" 
                        data-title="${video.title}" 
                        data-artist="${video.artist}" 
                        data-url="${video.url || ''}">
                    Add to Library
                </button>
            </div>
        </div>
    `).join('');
    
    // Add event listeners to add buttons
    document.querySelectorAll('.btn-add-video').forEach(button => {
        button.addEventListener('click', function() {
            const source = this.dataset.source;
            const videoId = this.dataset.videoId;
            const title = this.dataset.title;
            const artist = this.dataset.artist;
            const url = this.dataset.url;
            
            addVideoToLibrary(source, videoId, title, artist, url);
        });
    });
}

async function addVideoToLibrary(source, videoId, title, artist, url) {
    try {
        let endpoint, payload;
        
        if (source === 'YouTube') {
            endpoint = '/api/videos/import-from-youtube';
            payload = {
                youtube_id: videoId,
                url: url,
                title: title,
                artist: artist,
                auto_download: true
            };
        } else if (source === 'IMVDb') {
            endpoint = '/api/videos/import-from-imvdb';
            payload = {
                imvdb_id: videoId,
                auto_download: true
            };
        } else {
            throw new Error(`Unsupported source: ${source}`);
        }
        
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
            const responseText = await response.text();
            throw new Error(`HTTP ${response.status}: ${responseText}`);
        }
        
        const result = await response.json();
        
        if (result.success || result.video_id) {
            showSuccess(`‚úÖ Video "${title}" by ${artist} added to library successfully!`);
            closeAddVideoModal();
            // Refresh dashboard stats
            loadDashboardStats();
        } else {
            throw new Error(result.error || result.message || 'Unknown error occurred');
        }
        
    } catch (error) {
        console.error('Error adding video to library:', error);
        showError(`‚ùå Error adding video: ${error.message}`);
    }
}

// Close modal when clicking outside
window.onclick = function(event) {
    const addVideoModal = document.getElementById('addVideoModal');
    if (event.target === addVideoModal) {
        closeAddVideoModal();
    }
}
</script>

<style>
.dashboard-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
	
}

.dashboard-container h1 {
    color: #00d4ff;
    margin-bottom: 10px;
    font-size: 2.5rem;
    text-align: center;
}

.page-description {
    text-align: center;
    color: #ccc;
    margin-bottom: 30px;
    font-size: 1.1rem;
}

.dashboard-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}

.stat-card {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    border: 1px solid #444;
    border-radius: 12px;
    padding: 25px;
    text-align: center;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.stat-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 212, 255, 0.15);
}

.stat-card h3 {
    color: #00d4ff;
    margin-bottom: 15px;
    font-size: 1.2rem;
    border-bottom: 2px solid #00d4ff;
    padding-bottom: 8px;
}

.stat-number {
    font-size: 2.5rem;
    font-weight: bold;
    color: #00d4ff;
    margin: 0;
}

.stat-status {
    font-size: 1.2rem;
    font-weight: 500;
    margin: 0;
    color: #28a745;
}

.dashboard-actions {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-bottom: 30px;
    flex-wrap: wrap;
}

.downloads-section, .recent-activity {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    border: 1px solid #444;
    border-radius: 12px;
    padding: 25px;
    margin-bottom: 20px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.downloads-section:hover, .recent-activity:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 212, 255, 0.15);
}

.downloads-header, .history-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    border-bottom: 2px solid #00d4ff;
    padding-bottom: 10px;
}

.downloads-header h2, .history-header h2 {
    color: #00d4ff;
    margin: 0;
    font-size: 1.4rem;
}

.queue-actions, .history-actions {
    display: flex;
    gap: 10px;
}

.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.btn-primary {
    background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
    color: #fff;
}

.btn-primary:hover {
    background: linear-gradient(135deg, #0099cc 0%, #007799 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
}

.btn-secondary {
    background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
    color: #fff;
}

.btn-secondary:hover {
    background: linear-gradient(135deg, #5a6268 0%, #484e53 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
}

.btn-success {
    background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
    color: #fff;
}

.btn-success:hover {
    background: linear-gradient(135deg, #1e7e34 0%, #155724 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
}

.btn-warning {
    background: linear-gradient(135deg, #ffc107 0%, #d39e00 100%);
    color: #000;
}

.btn-warning:hover {
    background: linear-gradient(135deg, #d39e00 0%, #b08800 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
}

.btn-danger {
    background: linear-gradient(135deg, #dc3545 0%, #bd2130 100%);
    color: #fff;
}

.btn-danger:hover {
    background: linear-gradient(135deg, #bd2130 0%, #a01e2a 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
}

.btn-sm {
    padding: 6px 12px;
    font-size: 12px;
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none !important;
    box-shadow: none !important;
}

#download-queue-list, #download-history-list {
    color: #ccc;
    line-height: 1.6;
}

@media (max-width: 768px) {
    .dashboard-container {
        padding: 15px;
    }
    
    .dashboard-container h1 {
        font-size: 2rem;
    }
    
    .dashboard-stats {
        grid-template-columns: 1fr;
        gap: 15px;
    }
    
    .dashboard-actions {
        flex-direction: column;
        align-items: stretch;
    }
    
    .btn {
        justify-content: center;
    }
    
    .downloads-header, .history-header {
        flex-direction: column;
        align-items: stretch;
        gap: 15px;
    }
    
    .queue-actions, .history-actions {
        justify-content: center;
    }
    
    .downloads-section, .recent-activity {
        padding: 20px;
    }
}
</style>

<!-- Add Video Modal -->
<div id="addVideoModal" class="modal">
    <div class="modal-content" style="width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
            <h3>üéµ Add Video</h3>
            <span class="modal-close" onclick="closeAddVideoModal()">&times;</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="songTitleInput">Song Title:</label>
                <input type="text" id="songTitleInput" class="form-control" placeholder="Enter song title...">
            </div>
            <div class="form-group">
                <label for="artistNameInput">Artist Name (optional):</label>
                <input type="text" id="artistNameInput" class="form-control" placeholder="Enter artist name...">
            </div>
            <div class="modal-actions">
                <button onclick="searchForVideos()" class="btn btn-primary">üîç Search Videos</button>
                <button onclick="closeAddVideoModal()" class="btn btn-secondary">Cancel</button>
            </div>
            
            <div id="videoSearchResults" class="search-results" style="display: none;">
                <h4>Search Results:</h4>
                <div id="videoSearchResultsList" class="search-results-list">
                    <!-- Search results will be populated here -->
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 2000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(5px);
}

.modal-content {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    margin: 3% auto;
    padding: 0;
    border: 1px solid #444;
    border-radius: 12px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    color: #fff;
    animation: modalSlideIn 0.3s ease-out;
}

@keyframes modalSlideIn {
    from {
        opacity: 0;
        transform: translateY(-50px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 25px;
    border-bottom: 2px solid #00d4ff;
    background: linear-gradient(135deg, #2d2d2d 0%, #3a3a3a 100%);
    border-radius: 12px 12px 0 0;
}

.modal-header h3 {
    margin: 0;
    color: #00d4ff;
    font-size: 1.4rem;
}

.modal-close {
    font-size: 2rem;
    font-weight: bold;
    color: #aaa;
    cursor: pointer;
    padding: 0 10px;
    transition: color 0.3s ease;
}

.modal-close:hover {
    color: #00d4ff;
}

.modal-body {
    padding: 25px;
    max-height: 70vh;
    overflow-y: auto;
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    margin-bottom: 8px;
    color: #00d4ff;
    font-weight: 500;
    font-size: 1rem;
}

.form-control {
    width: 100%;
    padding: 12px 15px;
    font-size: 16px;
    border: 2px solid #444;
    border-radius: 8px;
    background: #1a1a1a;
    color: #fff;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.form-control:focus {
    outline: none;
    border-color: #00d4ff;
    box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
}

.form-control::placeholder {
    color: #666;
}

.modal-actions {
    display: flex;
    gap: 15px;
    justify-content: flex-end;
    margin-top: 25px;
    padding-top: 20px;
    border-top: 1px solid #444;
}

.search-results {
    margin-top: 25px;
    padding-top: 20px;
    border-top: 1px solid #444;
}

.search-results h4 {
    color: #00d4ff;
    margin-bottom: 15px;
    font-size: 1.2rem;
}

.search-results-list {
    max-height: 400px;
    overflow-y: auto;
}

.search-result-item {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 15px;
    margin-bottom: 10px;
    background: linear-gradient(135deg, #2a2a2a 0%, #333 100%);
    border: 1px solid #444;
    border-radius: 8px;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.search-result-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
    border-color: #00d4ff;
}

.result-thumbnail {
    flex-shrink: 0;
    width: 80px;
    height: 60px;
    border-radius: 6px;
    overflow: hidden;
}

.result-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.result-info {
    flex-grow: 1;
    min-width: 0;
}

.result-title {
    font-weight: bold;
    color: #fff;
    font-size: 1rem;
    margin-bottom: 4px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.result-artist {
    color: #00d4ff;
    font-size: 0.9rem;
    margin-bottom: 2px;
}

.result-source {
    color: #aaa;
    font-size: 0.8rem;
}

.result-actions {
    flex-shrink: 0;
}

.btn-add-video {
    padding: 8px 16px;
    font-size: 0.9rem;
    white-space: nowrap;
}

.loading, .error, .no-results {
    text-align: center;
    padding: 30px;
    color: #aaa;
    font-style: italic;
}

.error {
    color: #ff6b6b;
}

/* Mobile responsiveness */
@media (max-width: 768px) {
    .modal-content {
        width: 95%;
        margin: 5% auto;
        max-height: 90vh;
    }
    
    .modal-header {
        padding: 15px 20px;
    }
    
    .modal-body {
        padding: 20px;
    }
    
    .search-result-item {
        flex-direction: column;
        text-align: center;
        gap: 10px;
    }
    
    .result-thumbnail {
        width: 120px;
        height: 90px;
        align-self: center;
    }
    
    .result-info {
        text-align: center;
    }
    
    .result-title {
        white-space: normal;
    }
    
    .modal-actions {
        flex-direction: column;
        gap: 10px;
    }
}
</style>

{% endblock %}