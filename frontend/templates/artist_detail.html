{% extends "base.html" %}

{% block title %}Artist Details - MVidarr{% endblock %}

{% block head %}
<style>
/* CACHE BUST: 2025-08-29-16-30 - Force browser to reload compact button styles */

/* Library Statistics card specific styling - match artist navigation */
.library-stats-card {
    padding: 20px !important;
    border-radius: 12px !important;
    border: 2px solid var(--accent-primary, #00bcd4) !important;
    margin-bottom: 1.5rem !important;
}

.library-stats-card .stats-grid {
    padding: 0 5px 5px 5px !important;
}

/* IMVDb ID management styles */
.input-group {
    display: flex;
    align-items: center;
    gap: 5px;
}

/* External Services Grid - Overview Page */
.services-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.2rem;
    margin-top: 1rem;
}

.services-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    padding: 1rem 0;
}

.service-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem 1rem;
    background: var(--bg-tertiary, #333);
    border-radius: 6px;
    border-left: 3px solid var(--border-primary, #444);
    transition: all 0.2s ease;
}

.service-item:hover {
    background: var(--bg-quaternary, #3a3a3a);
    border-left-color: var(--accent-primary, #00d4ff);
}

.service-main {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex: 1;
}

.service-name-link {
    color: var(--text-accent, #00d4ff);
    text-decoration: none;
    font-weight: 500;
    cursor: pointer;
    transition: color 0.2s ease;
}

.service-name-link:hover {
    color: var(--accent-secondary, #00b8e6);
    text-decoration: underline;
}

.service-status {
    color: var(--text-secondary, #ccc);
    font-size: 0.9rem;
}

.service-status.linked {
    color: var(--success-color, #4CAF50);
}

.service-actions {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.service-sync-btn {
    background: none;
    border: none;
    color: var(--text-secondary, #ccc);
    cursor: pointer;
    padding: 0.25rem;
    border-radius: 3px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
}

.service-sync-btn:hover {
    background: var(--bg-secondary, #2a2a2a);
    color: var(--accent-primary, #00d4ff);
}

.service-sync-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.service-card {
    background: var(--bg-secondary, #2a2a2a);
    border: 1px solid var(--border-primary, #444);
    border-radius: 8px;
    overflow: hidden;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.service-card:hover {
    border-color: var(--text-accent, #00d4ff);
    box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
    transform: translateY(-2px);
}

.service-card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem;
    background: var(--bg-tertiary, #333);
    border-bottom: 1px solid var(--border-primary, #444);
}

.service-info {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.service-icon {
    font-size: 1.5rem;
    color: var(--text-accent, #00d4ff);
}

.service-name {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary, #fff);
    margin: 0;
}

.service-description {
    font-size: 0.85rem;
    color: var(--text-secondary, #ccc);
    margin: 0.25rem 0 0 0;
}

.service-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.connection-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--bg-muted, #666);
}

.connection-indicator.connected {
    background: var(--success-color, #4CAF50);
    box-shadow: 0 0 4px rgba(76, 175, 80, 0.4);
}

.connection-indicator.disconnected {
    background: var(--danger-color, #f44336);
}

.status-text {
    font-size: 0.85rem;
    font-weight: 500;
    color: var(--text-secondary, #ccc);
}

.service-card-header .service-status .status-text {
    color: var(--text-primary, #fff);
}

.service-card-body {
    padding: 1rem;
}

.service-data {
    display: grid;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.data-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.4rem 0;
    border-bottom: 1px solid var(--border-secondary, #3a3a3a);
}

.data-item:last-child {
    border-bottom: none;
}

.data-label {
    font-size: 0.85rem;
    color: var(--text-secondary, #ccc);
    font-weight: 500;
}

.data-value {
    font-size: 0.85rem;
    color: var(--text-primary, #fff);
    text-align: right;
    max-width: 60%;
    word-break: break-word;
}

.service-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-top: 0.75rem;
    padding-top: 0.75rem;
    border-top: 1px solid var(--border-secondary, #3a3a3a);
}

.header-actions {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

/* Metadata Services Styles - Settings Page */
.metadata-services-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 1rem;
    margin: 1rem 0;
}

.metadata-service-card {
    background: var(--bg-tertiary, #333);
    border: 1px solid var(--border-secondary, #444);
    border-radius: 8px;
    overflow: hidden;
    transition: all 0.3s ease;
}

.metadata-service-card:hover {
    border-color: var(--text-accent, #00d4ff);
    box-shadow: 0 4px 16px rgba(0, 212, 255, 0.1);
}

.service-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    background: var(--bg-quaternary, #2a2a2a);
    border-bottom: 1px solid var(--border-secondary, #444);
}

.service-info {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.service-icon {
    font-size: 1.5rem;
    color: var(--text-accent, #00d4ff);
}

.service-details h5 {
    margin: 0;
    font-size: 0.95rem;
    font-weight: 600;
    color: var(--text-primary, #fff);
}

.service-description {
    font-size: 0.8rem;
    color: var(--text-secondary, #ccc);
}

.service-status .status-indicator {
    padding: 0.25rem 0.5rem;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
}

.status-indicator.unknown {
    background: var(--bg-muted, #666);
    color: white;
}

.status-indicator.linked {
    background: var(--success-bg, #4CAF50);
    color: white;
}

.status-indicator.error {
    background: var(--danger-bg, #f44336);
    color: white;
}

.service-controls {
    padding: 1rem;
}

.service-input {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid var(--border-secondary, #444);
    border-radius: 4px;
    background: var(--bg-primary, #1a1a1a);
    color: var(--text-primary, #fff);
    margin-bottom: 0.75rem;
}

.service-actions {
    display: flex;
    gap: 0.5rem;
}

.btn-sm {
    padding: 0.375rem 0.75rem;
    font-size: 0.8rem;
}

.service-metadata {
    padding: 1rem;
    background: var(--bg-primary, #1a1a1a);
    border-top: 1px solid var(--border-secondary, #444);
}

.metadata-bulk-actions {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-top: 1.5rem;
    padding-top: 1.5rem;
    border-top: 1px solid var(--border-secondary, #444);
    flex-wrap: wrap;
}

.metadata-bulk-actions .btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

@media (max-width: 768px) {
    .metadata-services-grid {
        grid-template-columns: 1fr;
    }
    
    .metadata-bulk-actions {
        flex-direction: column;
        align-items: center;
    }
    
    .service-actions {
        flex-wrap: wrap;
    }
}

.input-group input {
    flex: 1;
}

.btn-clear, .btn-search {
    background: var(--btn-danger-bg, #dc3545);
    color: var(--btn-danger-text, white);
    border: none;
    padding: 6px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    min-width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-search {
    background: var(--btn-primary-bg, #007bff);
}

.btn-clear:hover {
    background: var(--btn-danger-hover, #c82333);
}

.btn-search:hover {
    background: var(--btn-primary-hover, #0056b3);
}

.imvdb-search-results {
    max-height: 400px;
    overflow-y: auto;
    border-radius: 6px;
    border: 1px solid var(--border-secondary, #333);
    background: var(--bg-primary, #1a1a1a);
}

.imvdb-result-item {
    padding: 16px;
    border-bottom: 1px solid var(--border-secondary, #333);
    cursor: pointer;
    transition: all 0.2s ease;
    background: var(--bg-secondary, #222);
    margin-bottom: 2px;
    border-radius: 4px;
    color: var(--text-secondary, #e0e0e0);
}

.imvdb-result-item:hover {
    background: var(--bg-hover, #2a2a2a);
    border-color: var(--text-accent, #00d4ff);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px var(--accent-shadow, rgba(0, 212, 255, 0.1));
}

.imvdb-result-item:last-child {
    border-bottom: none;
}

.result-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
}

.result-info strong {
    color: var(--text-accent, #00d4ff);
    font-weight: 600;
    font-size: 1.1em;
}

.result-id {
    font-size: 0.9em;
    color: var(--text-muted, #888);
    background: var(--bg-tertiary, #333);
    padding: 2px 8px;
    border-radius: 12px;
    font-weight: 500;
}

.result-description {
    color: var(--text-secondary, #b0b0b0);
    font-size: 0.9em;
    margin-top: 4px;
    line-height: 1.4;
}

.result-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
    font-size: 0.85em;
}

.result-number {
    color: var(--text-muted, #666);
    font-weight: 500;
    background: var(--bg-hover, #2a2a2a);
    padding: 2px 6px;
    border-radius: 10px;
}

.result-link {
    color: var(--text-accent, #00d4ff);
    text-decoration: none;
    font-weight: 500;
    transition: color 0.2s;
}

.result-link:hover {
    color: var(--accent-secondary, #00b8e6);
    text-decoration: underline;
}

/* IMVDb Match Modal Styles */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--modal-overlay, rgba(0, 0, 0, 0.8));
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    overflow-y: auto;
}

.imvdb-match-modal {
    background: var(--bg-secondary, #2a2a2a);
    border-radius: 10px;
    max-width: 90%;
    max-height: 85vh;
    width: 800px;
    display: flex;
    flex-direction: column;
    margin: 10px;
    overflow: hidden;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    border-bottom: 1px solid var(--border-primary, #444);
}

.modal-header h2 {
    margin: 0;
    color: var(--text-accent, #00d4ff);
}

.close-btn {
    background: none;
    border: none;
    font-size: 24px;
    color: var(--text-secondary, #ccc);
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.close-btn:hover {
    color: var(--text-accent, #00d4ff);
}

.modal-body {
    padding: 20px;
    flex: 1;
    overflow-y: auto;
    min-height: 0; /* Allow flexbox to shrink */
}

.imvdb-matches-table-container {
    max-height: 60vh;
    overflow-y: auto;
    border: 1px solid var(--border-primary, #444);
    border-radius: 8px;
    margin-top: 15px;
    background: var(--bg-secondary, #2a2a2a);
    box-shadow: 0 4px 8px var(--shadow, rgba(0, 0, 0, 0.3));
}

.imvdb-matches-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
    line-height: 1.4;
}

.imvdb-matches-table th {
    background: linear-gradient(135deg, var(--bg-tertiary, #444) 0%, var(--bg-quaternary, #555) 100%);
    color: var(--text-primary, #fff);
    padding: 14px 12px;
    text-align: left;
    font-weight: bold;
    border-bottom: 2px solid var(--border-secondary, #666);
    position: sticky;
    top: 0;
    z-index: 1;
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.imvdb-matches-table td {
    padding: 14px 12px;
    border-bottom: 1px solid var(--border-primary, #444);
    border-right: 1px solid var(--border-secondary, #3a3a3a);
    vertical-align: top;
    background: inherit;
    color: var(--text-secondary, #ddd);
}

.imvdb-match-row {
    cursor: pointer;
    transition: all 0.2s ease;
    background: rgba(255, 255, 255, 0.02);
    border: 1px solid transparent;
}

.imvdb-match-row:nth-child(even) {
    background: rgba(255, 255, 255, 0.05);
}

.imvdb-match-row:hover {
    background: rgba(0, 212, 255, 0.15) !important;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 212, 255, 0.2);
}

.imvdb-match-row.high {
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.3), rgba(76, 175, 80, 0.2)) !important;
    border-left: 5px solid #4CAF50 !important;
    border-right: 2px solid rgba(76, 175, 80, 0.3) !important;
}

.imvdb-match-row.medium {
    background: linear-gradient(135deg, rgba(255, 152, 0, 0.25), rgba(255, 152, 0, 0.15)) !important;
    border-left: 4px solid #FF9800 !important;
    border-right: 1px solid rgba(255, 152, 0, 0.3) !important;
}

.imvdb-match-row.low {
    background: linear-gradient(135deg, rgba(108, 117, 125, 0.2), rgba(108, 117, 125, 0.1)) !important;
    border-left: 3px solid #6c757d !important;
    opacity: 0.85;
}

.match-confidence {
    width: 90px;
    text-align: center;
}

.match-name {
    min-width: 200px;
    width: 25%;
}

.match-origin {
    width: 15%;
}

.match-genres {
    width: 20%;
}

.match-birth-date {
    width: 12%;
}

.match-bio {
    width: 28%;
    max-width: 300px;
    word-wrap: break-word;
}


.match-origin {
    width: 150px;
}

.match-genres {
    width: 200px;
}

.match-birth-date {
    width: 100px;
}

.match-bio {
    width: 300px;
    font-size: 12px;
    color: #bbb;
    line-height: 1.3;
}




.match-info {
    width: 100%;
}

.match-info h4 {
    margin: 0 0 8px 0;
    color: var(--text-accent, #00d4ff);
    font-size: 16px;
}

.imvdb-match-card.high .match-info h4 {
    color: var(--success, #4CAF50);
}

.imvdb-match-card.medium .match-info h4 {
    color: var(--warning, #FF9800);
}

.imvdb-match-card.low .match-info h4 {
    color: #adb5bd;
}

.match-info p {
    margin: 4px 0;
    font-size: 13px;
    color: #ccc;
}

.disambiguation {
    font-style: italic;
    color: #999;
}

.origin, .genres, .birth-date {
    color: #aaa;
}

.bio {
    color: #bbb;
    line-height: 1.4;
}

.confidence-badge {
    display: inline-block;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: bold;
    text-transform: uppercase;
    margin-top: 8px;
    letter-spacing: 0.5px;
}

.confidence-badge.high {
    background: #4CAF50;
    color: white;
    box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
}

.confidence-badge.medium {
    background: #FF9800;
    color: white;
    box-shadow: 0 2px 4px rgba(255, 152, 0, 0.3);
}

.confidence-badge.low {
    background: #6c757d;
    color: white;
    box-shadow: 0 2px 4px rgba(108, 117, 125, 0.3);
}

.no-data {
    color: #888;
    font-style: italic;
    font-size: 12px;
}

.match-name strong {
    color: #fff;
    font-size: 15px;
}

.disambiguation {
    color: #aaa;
    font-size: 12px;
    margin-top: 4px;
    padding: 2px 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    display: inline-block;
}

.slug-info {
    color: var(--text-accent, #00d4ff);
    font-size: 11px;
    margin-top: 4px;
    opacity: 0.8;
}

/* Source badge styles for YouTube and IMVDb videos */
.source-badge {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 10px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-right: 4px;
}

.source-badge.source-youtube {
    background: #ff0000;
    color: white;
    box-shadow: 0 1px 2px rgba(255, 0, 0, 0.3);
}

.source-badge.source-imvdb {
    background: #2196F3;
    color: white;
    box-shadow: 0 1px 2px rgba(33, 150, 243, 0.3);
}

/* Enhanced discovered video card styles for different sources */
.discovered-video-card.youtube {
    border-left: 4px solid #ff0000;
}

.discovered-video-card.imvdb {
    border-left: 4px solid #2196F3;
}

.modal-footer {
    padding: 20px;
    border-top: 1px solid #444;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.loading-placeholder {
    color: var(--text-accent, #00d4ff);
    font-style: italic;
}

.success-message {
    color: var(--success, #4CAF50);
    font-weight: bold;
}

.error-message {
    color: #f44336;
    font-weight: bold;
}

.info-message {
    color: #2196F3;
    font-weight: bold;
}

.warning-message {
    color: #ff9800;
    font-weight: bold;
    font-style: italic;
}

/* Icon button styles for video actions */
.btn-icon {
    padding: 8px !important;
    min-width: 36px !important;
    width: 36px !important;
    height: 36px !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    border-radius: 6px !important;
    margin: 0 2px !important;
    font-size: 16px !important;
    border: none !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
}

.btn-icon:hover {
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2) !important;
}

.btn-icon:disabled {
    opacity: 0.6 !important;
    cursor: not-allowed !important;
    transform: none !important;
}

.btn-icon.btn-danger {
    background: var(--btn-danger-bg, #dc3545) !important;
    color: var(--btn-danger-text, white) !important;
}

.btn-icon.btn-danger:hover:not(:disabled) {
    background: var(--btn-danger-hover, #c82333) !important;
}

.btn-icon.btn-warning {
    background: var(--btn-warning-bg, #ffc107) !important;
    color: var(--btn-warning-text, #212529) !important;
}

.btn-icon.btn-warning:hover:not(:disabled) {
    background: var(--btn-warning-hover, #e0a800) !important;
}

/* Update video-actions spacing for icons */
.video-actions {
    display: flex !important;
    align-items: center !important;
    justify-content: flex-start !important;
    gap: 4px !important;
    flex-wrap: wrap !important;
    margin-top: 8px !important;
}

/* Delete confirmation modal styles */
.delete-modal {
    max-width: 500px !important;
    border-radius: 12px !important;
}

.delete-warning {
    text-align: center;
    padding: 20px 0;
    border-bottom: 1px solid var(--border-secondary, #333);
    margin-bottom: 20px;
}

.delete-warning h4 {
    color: #ff6b6b;
    margin: 16px 0 8px 0;
    font-size: 18px;
}

.delete-warning .video-info {
    color: var(--text-primary, #e0e0e0);
    margin: 8px 0;
    font-size: 16px;
}

.delete-warning .warning-text {
    color: var(--text-secondary, #b0b0b0);
    font-size: 14px;
    margin: 12px 0 0 0;
}

.blacklist-option {
    background: var(--bg-secondary, #2a2a2a);
    border-radius: 8px;
    padding: 16px;
    margin: 16px 0;
}

.blacklist-checkbox {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 8px;
}

.blacklist-checkbox input[type="checkbox"] {
    width: 18px;
    height: 18px;
    margin: 0;
}

.blacklist-checkbox label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    color: var(--text-primary, #e0e0e0);
    font-weight: 500;
    margin: 0;
}

.blacklist-checkbox label iconify-icon {
    color: #ff9500;
    font-size: 18px;
}

.blacklist-note {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    color: var(--text-secondary, #b0b0b0);
    font-size: 13px;
    margin: 0;
    line-height: 1.4;
}

.blacklist-note iconify-icon {
    color: #17a2b8;
    font-size: 16px;
    margin-top: 1px;
    flex-shrink: 0;
}

/* Loader animation for downloading icon */
.btn-icon iconify-icon[icon="tabler:loader-2"] {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* Single-page Metadata Styles */
.single-page-metadata {
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

.settings-section {
    background: var(--bg-primary);
    border: 1px solid var(--border-primary);
    border-radius: 12px;
    padding: 1.5rem;
}

.section-title {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0 0 1rem 0;
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
    border-bottom: 2px solid var(--border-primary);
    padding-bottom: 0.5rem;
}

.section-title iconify-icon {
    font-size: 1.2rem;
    color: var(--accent-primary);
}

.settings-subsection {
    margin-top: 1.5rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-secondary);
}

.subsection-title {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0 0 1rem 0;
    font-size: 1rem;
    font-weight: 500;
    color: var(--text-secondary);
}

.subsection-title iconify-icon {
    font-size: 1rem;
    color: var(--text-muted);
}

.settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1rem;
}

.setting-group {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.setting-group.full-width {
    grid-column: 1 / -1;
}

.setting-group label {
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 0.25rem;
}

.setting-group input,
.setting-group select,
.setting-group textarea {
    padding: 0.5rem;
    border: 1px solid var(--border-secondary);
    border-radius: 6px;
    background: var(--bg-secondary);
    color: var(--text-primary);
    font-size: 0.9rem;
    transition: border-color 0.2s ease;
}

.setting-group input:focus,
.setting-group select:focus,
.setting-group textarea:focus {
    outline: none;
    border-color: var(--accent-primary);
    box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.1);
}

.field-hint {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 0.25rem;
}

.checkbox-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
}

.checkbox-group {
    display: block;
}

.checkbox-container {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    cursor: pointer;
    padding: 0.75rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-secondary);
    border-radius: 8px;
    transition: all 0.2s ease;
}

.checkbox-container:hover {
    border-color: var(--accent-primary);
    background: var(--bg-accent-subtle);
}

.checkmark {
    width: 18px;
    height: 18px;
    border: 2px solid var(--border-primary);
    border-radius: 4px;
    position: relative;
    flex-shrink: 0;
    margin-top: 2px;
}

.checkbox-container input[type="checkbox"] {
    display: none;
}

.checkbox-container input[type="checkbox"]:checked + .checkmark {
    background: var(--accent-primary);
    border-color: var(--accent-primary);
}

.checkbox-container input[type="checkbox"]:checked + .checkmark::after {
    content: 'âœ“';
    position: absolute;
    top: -2px;
    left: 2px;
    color: white;
    font-size: 12px;
    font-weight: bold;
}

.checkbox-content {
    flex: 1;
}

.checkbox-label {
    font-weight: 500;
    color: var(--text-primary);
    display: block;
    margin-bottom: 0.25rem;
}

@media (max-width: 768px) {
    .settings-grid {
        grid-template-columns: 1fr;
    }
    
    .checkbox-grid {
        grid-template-columns: 1fr;
    }
    
    .settings-section {
        padding: 1rem;
    }
    
    .single-page-metadata {
        gap: 1.5rem;
    }
}

/* Enhanced Artist Detail Layout Styles */
.overview-layout {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    max-width: 1400px;
    margin: 0 auto;
}

.artist-hero-card {
    background: linear-gradient(135deg, var(--bg-secondary, #2a2a2a) 0%, var(--bg-tertiary, #333) 100%);
    border-radius: 12px;
    padding: 1.5rem;
    border: 1px solid var(--border-secondary, #444);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.hero-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 2rem;
    flex-wrap: wrap;
}

.quick-stats {
    display: flex;
    gap: 2rem;
    flex-wrap: wrap;
}

.quick-stat {
    text-align: center;
    min-width: 80px;
}

.quick-stat-value {
    display: block;
    font-size: 2rem;
    font-weight: bold;
    color: var(--text-accent, #00d4ff);
    line-height: 1;
    margin-bottom: 0.25rem;
}

.quick-stat-label {
    font-size: 0.85rem;
    color: var(--text-muted, #888);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.metadata-actions {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
}

.btn-metadata-action {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border-radius: 8px;
    font-weight: 500;
    transition: all 0.2s ease;
    border: none;
    cursor: pointer;
}

.btn-metadata-action:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.metadata-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr) !important;
    gap: 1.5rem;
    align-items: start;
}

/* FORCE 2 COLUMNS - Maximum specificity override - CACHE BUST: 2025-08-25-14-21 */
div.overview-layout div.metadata-grid,
#overviewContent .metadata-grid,
.tab-content.active .metadata-grid,
.metadata-grid {
    display: grid !important;
    grid-template-columns: repeat(2, 1fr) !important;
    grid-template-rows: auto !important;
    gap: 1.5rem !important;
    align-items: start !important;
}

/* Ensure full-width items span both columns */
.metadata-section.full-width,
.overview-layout .metadata-grid .metadata-section.full-width,
div.metadata-grid .metadata-section.full-width {
    grid-column: 1 / -1 !important;
    width: 100% !important;
}

/* OVERRIDE any auto-fit rules that may conflict */
*[class*="grid"] {
    grid-template-columns: revert !important;
}

/* Then re-apply our 2 column rule with maximum priority */
.overview-layout .metadata-grid {
    display: grid !important;
    grid-template-columns: repeat(2, 1fr) !important;
    max-width: 100% !important;
}

/* Responsive: Switch to single column on smaller screens */
@media (max-width: 768px) {
    .metadata-grid,
    #overviewContent .metadata-grid {
        grid-template-columns: 1fr !important;
    }
}

.metadata-section,
div.metadata-section,
.overview-layout .metadata-section,
.tab-content .metadata-section {
    background: var(--bg-tertiary, #333) !important;
    border: 2px solid var(--border-primary, #444) !important;
    border-radius: 12px !important;
    padding: 15px !important;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15) !important;
    transition: transform 0.3s ease, box-shadow 0.3s ease !important;
}

.metadata-section:hover,
div.metadata-section:hover,
.overview-layout .metadata-section:hover,
.tab-content .metadata-section:hover {
    transform: translateY(-4px) !important;
    box-shadow: 0 8px 25px rgba(0, 212, 255, 0.15) !important;
    border-color: var(--text-accent, #00d4ff) !important;
}

.metadata-section.basic-info:hover {
    border-color: var(--info-color, #2196F3);
}

.metadata-section.musical-info:hover {
    border-color: var(--success-color, #4CAF50);
}

.metadata-section.statistics:hover {
    border-color: var(--warning-color, #FF9800);
}

.metadata-section.activity:hover {
    border-color: var(--accent-secondary, #00b8e6);
    overflow: hidden;
    transition: all 0.2s ease;
}

.metadata-section:hover {
    border-color: var(--text-accent, #00d4ff);
    box-shadow: 0 4px 16px rgba(0, 212, 255, 0.1);
}


.section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.25rem;
    margin: -1rem -1rem 1rem -1rem;
    background: linear-gradient(135deg, var(--bg-tertiary, #333) 0%, var(--bg-quaternary, #3a3a3a) 100%);
    border-bottom: 3px solid var(--accent-primary, #00d4ff);
    border-radius: 10px 10px 0 0;
}

.metadata-section.basic-info .section-header {
    border-bottom-color: var(--info-color, #2196F3);
}

.metadata-section.musical-info .section-header {
    border-bottom-color: var(--success-color, #4CAF50);
}

.metadata-section.statistics .section-header {
    border-bottom-color: var(--warning-color, #FF9800);
}

.metadata-section.activity .section-header {
    border-bottom-color: var(--accent-secondary, #00b8e6);
}

.section-header h3 {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary, #fff);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.section-header iconify-icon {
    font-size: 1.1rem;
    color: var(--text-accent, #00d4ff);
}

.data-quality-badge {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 12px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.data-quality-badge.excellent {
    background: var(--success-bg, #4CAF50);
    color: white;
}

.data-quality-badge.good {
    background: var(--info-bg, #2196F3);
    color: white;
}

.data-quality-badge.fair {
    background: var(--warning-bg, #ff9800);
    color: white;
}

.data-quality-badge.poor {
    background: var(--danger-bg, #f44336);
    color: white;
}

.data-quality-badge.none {
    background: var(--bg-muted, #666);
    color: white;
}

.metadata-content {
    padding: 1.25rem;
}

.metadata-item {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 0.75rem 0;
    border-bottom: 1px solid var(--border-tertiary, rgba(255, 255, 255, 0.1));
}

.metadata-item:last-child {
    border-bottom: none;
    padding-bottom: 0;
}

.metadata-item.full-width {
    flex-direction: column;
    align-items: stretch;
    gap: 0.5rem;
}

.metadata-label {
    font-weight: 500;
    color: var(--text-muted, #888);
    font-size: 0.9rem;
    min-width: 100px;
    flex-shrink: 0;
}

.metadata-value {
    color: var(--text-primary, #fff);
    font-size: 0.9rem;
    line-height: 1.4;
    text-align: right;
    flex: 1;
}

.metadata-item.full-width .metadata-value {
    text-align: left;
}

.metadata-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
}

.metadata-tag {
    background: var(--bg-accent-subtle, rgba(0, 212, 255, 0.1));
    color: var(--text-accent, #00d4ff);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-size: 0.8rem;
    border: 1px solid var(--text-accent, #00d4ff);
}

/* Enhanced metadata display styles */
.metadata-item.enhanced {
    padding: 1rem 0;
    border-bottom: 1px solid var(--border-tertiary, rgba(255, 255, 255, 0.1));
}

.metadata-item.enhanced:last-child {
    border-bottom: none;
}

.metadata-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.metadata-item.enhanced .metadata-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 600;
    color: var(--text-primary, #fff);
    font-size: 0.95rem;
}

.metadata-source {
    font-size: 0.75rem;
    padding: 0.2rem 0.5rem;
    background: var(--bg-tertiary, #333);
    color: var(--text-muted, #888);
    border-radius: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border: 1px solid var(--border-secondary, #444);
}

.metadata-item.enhanced .metadata-value {
    font-size: 0.9rem;
    color: var(--text-secondary, #ddd);
    line-height: 1.4;
}

/* Enhanced tag styles */
.metadata-tags.enhanced {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    margin-top: 0.25rem;
}

.metadata-tag-genre {
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));
    color: #4CAF50;
    border: 1px solid rgba(76, 175, 80, 0.3);
}

.metadata-tag-label {
    background: linear-gradient(135deg, rgba(255, 152, 0, 0.2), rgba(255, 152, 0, 0.1));
    color: #FF9800;
    border: 1px solid rgba(255, 152, 0, 0.3);
}

.metadata-tag-mood {
    background: linear-gradient(135deg, rgba(233, 30, 99, 0.2), rgba(233, 30, 99, 0.1));
    color: #E91E63;
    border: 1px solid rgba(233, 30, 99, 0.3);
}

.metadata-tag-theme {
    background: linear-gradient(135deg, rgba(156, 39, 176, 0.2), rgba(156, 39, 176, 0.1));
    color: #9C27B0;
    border: 1px solid rgba(156, 39, 176, 0.3);
}

/* Popularity bar styles */
.popularity-container {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    width: 100%;
}

.popularity-bar {
    flex: 1;
    height: 8px;
    background: var(--bg-tertiary, #333);
    border-radius: 4px;
    overflow: hidden;
    border: 1px solid var(--border-secondary, #444);
}

.popularity-fill {
    height: 100%;
    transition: width 0.6s ease;
    border-radius: 4px;
}

.popularity-value {
    font-size: 0.8rem;
    font-weight: 500;
    color: var(--text-muted, #888);
    min-width: 50px;
    text-align: right;
}

/* Enhanced enrichment modal styles */
.enrichment-progress-modal,
.enrichment-results-modal,
.enrichment-error-modal {
    background: var(--bg-secondary, #2a2a2a);
    border-radius: 12px;
    width: 500px;
    max-width: 90%;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    border: 1px solid var(--border-secondary, #444);
}

.enrichment-progress-container {
    padding: 1rem 0;
}

.progress-bar-container {
    margin-bottom: 1.5rem;
}

.progress-bar {
    width: 100%;
    height: 12px;
    background: var(--bg-tertiary, #333);
    border-radius: 6px;
    overflow: hidden;
    margin-bottom: 0.5rem;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--text-accent, #00d4ff), var(--accent-secondary, #00b8e6));
    border-radius: 6px;
    transition: width 0.3s ease;
}

.progress-text {
    text-align: center;
    font-size: 0.9rem;
    color: var(--text-secondary, #ddd);
    font-weight: 500;
}

.sources-progress {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.source-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem;
    background: var(--bg-tertiary, #333);
    border-radius: 8px;
    color: var(--text-muted, #888);
    transition: all 0.3s ease;
    border-left: 3px solid transparent;
}

.source-item.processing {
    color: var(--text-accent, #00d4ff);
    background: var(--bg-accent-subtle, rgba(0, 212, 255, 0.1));
    border-left-color: var(--text-accent, #00d4ff);
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

.summary-stats {
    display: flex;
    gap: 2rem;
    margin-bottom: 1.5rem;
    justify-content: center;
}

.stat-item {
    text-align: center;
}

.stat-value {
    display: block;
    font-size: 2rem;
    font-weight: bold;
    color: var(--text-accent, #00d4ff);
    margin-bottom: 0.25rem;
}

.stat-label {
    font-size: 0.8rem;
    color: var(--text-muted, #888);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.sources-used,
.enriched-fields,
.failed-sources {
    margin-bottom: 1.5rem;
}

.sources-used h4,
.enriched-fields h4,
.failed-sources h4 {
    margin: 0 0 0.75rem 0;
    color: var(--text-primary, #fff);
    font-size: 1rem;
}

.source-badges,
.field-badges {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.source-badge {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: 8px;
    font-size: 0.85rem;
    font-weight: 500;
    border: 1px solid;
}

.source-badge.success {
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));
    color: #4CAF50;
    border-color: rgba(76, 175, 80, 0.3);
}

.source-badge.error {
    background: linear-gradient(135deg, rgba(244, 67, 54, 0.2), rgba(244, 67, 54, 0.1));
    color: #f44336;
    border-color: rgba(244, 67, 54, 0.3);
}

.field-badge {
    padding: 0.4rem 0.6rem;
    background: var(--bg-accent-subtle, rgba(0, 212, 255, 0.1));
    color: var(--text-accent, #00d4ff);
    border-radius: 6px;
    font-size: 0.8rem;
    border: 1px solid var(--text-accent, #00d4ff);
}

.error-message {
    color: var(--text-secondary, #ddd);
    line-height: 1.6;
}

.error-message p {
    margin-bottom: 1rem;
    font-size: 1rem;
}

.suggestions ul {
    margin: 0.5rem 0;
    padding-left: 1.5rem;
}

.suggestions li {
    margin-bottom: 0.5rem;
    color: var(--text-muted, #888);
}

/* Quality analysis modal styles */
.quality-analysis-modal {
    background: var(--bg-secondary, #2a2a2a);
    border-radius: 12px;
    width: 700px;
    max-width: 95%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    border: 1px solid var(--border-secondary, #444);
}

.quality-overview {
    text-align: center;
    padding: 1rem 0 2rem 0;
    border-bottom: 1px solid var(--border-secondary, #444);
    margin-bottom: 2rem;
}

.overall-score {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.75rem;
}

.score-circle {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    border: 4px solid;
    position: relative;
}

.score-circle.excellent {
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));
    border-color: #4CAF50;
    color: #4CAF50;
}

.score-circle.good {
    background: linear-gradient(135deg, rgba(33, 150, 243, 0.2), rgba(33, 150, 243, 0.1));
    border-color: #2196F3;
    color: #2196F3;
}

.score-circle.fair {
    background: linear-gradient(135deg, rgba(255, 152, 0, 0.2), rgba(255, 152, 0, 0.1));
    border-color: #FF9800;
    color: #FF9800;
}

.score-circle.poor {
    background: linear-gradient(135deg, rgba(244, 67, 54, 0.2), rgba(244, 67, 54, 0.1));
    border-color: #f44336;
    color: #f44336;
}

.score-circle.none {
    background: linear-gradient(135deg, rgba(108, 117, 125, 0.2), rgba(108, 117, 125, 0.1));
    border-color: #6c757d;
    color: #6c757d;
}

.score-value {
    font-size: 2.5rem;
    font-weight: bold;
    line-height: 1;
}

.score-label {
    font-size: 1rem;
    opacity: 0.8;
}

.overall-score h4 {
    margin: 0;
    color: var(--text-primary, #fff);
    font-size: 1.25rem;
}

.score-description {
    margin: 0;
    color: var(--text-secondary, #ddd);
    font-size: 0.9rem;
    max-width: 400px;
    line-height: 1.4;
}

.section-scores {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-bottom: 2rem;
}

.section-score {
    background: var(--bg-tertiary, #333);
    border-radius: 8px;
    padding: 1rem;
    border: 1px solid var(--border-secondary, #444);
}

.section-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
}

.section-info h5 {
    margin: 0;
    color: var(--text-primary, #fff);
    font-size: 1rem;
}

.quality-badge {
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.section-details {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
}

.section-details .progress-bar {
    flex: 1;
    height: 6px;
    background: var(--bg-quaternary, #444);
    border-radius: 3px;
    overflow: hidden;
}

.section-details .progress-fill {
    height: 100%;
    background: var(--text-accent, #00d4ff);
    border-radius: 3px;
    transition: width 0.6s ease;
}

.section-stats {
    font-size: 0.85rem;
    color: var(--text-muted, #888);
    min-width: 100px;
    text-align: right;
}

.improvement-suggestions,
.metadata-strengths {
    margin-bottom: 1.5rem;
}

.improvement-suggestions h4,
.metadata-strengths h4 {
    margin: 0 0 1rem 0;
    color: var(--text-primary, #fff);
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.suggestions-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.suggestion-item {
    background: var(--bg-tertiary, #333);
    border-radius: 8px;
    padding: 1rem;
    border-left: 4px solid;
}

.suggestion-item.priority-high {
    border-left-color: #f44336;
}

.suggestion-item.priority-medium {
    border-left-color: #FF9800;
}

.suggestion-item.priority-low {
    border-left-color: #4CAF50;
}

.suggestion-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.suggestion-action {
    font-weight: 600;
    color: var(--text-primary, #fff);
    font-size: 0.95rem;
}

.priority-badge {
    font-size: 0.7rem;
    padding: 0.2rem 0.4rem;
    border-radius: 4px;
    text-transform: uppercase;
    font-weight: 500;
    letter-spacing: 0.5px;
}

.priority-badge.priority-high {
    background: rgba(244, 67, 54, 0.2);
    color: #f44336;
    border: 1px solid rgba(244, 67, 54, 0.3);
}

.priority-badge.priority-medium {
    background: rgba(255, 152, 0, 0.2);
    color: #FF9800;
    border: 1px solid rgba(255, 152, 0, 0.3);
}

.priority-badge.priority-low {
    background: rgba(76, 175, 80, 0.2);
    color: #4CAF50;
    border: 1px solid rgba(76, 175, 80, 0.3);
}

.suggestion-description {
    margin: 0.5rem 0;
    color: var(--text-secondary, #ddd);
    font-size: 0.9rem;
    line-height: 1.4;
}

.suggestion-benefit {
    margin: 0.5rem 0 0 0;
    color: var(--text-muted, #888);
    font-size: 0.85rem;
    line-height: 1.3;
}

.strengths-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.strength-badge {
    padding: 0.4rem 0.6rem;
    background: linear-gradient(135deg, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.1));
    color: #4CAF50;
    border-radius: 6px;
    font-size: 0.8rem;
    border: 1px solid rgba(76, 175, 80, 0.3);
    font-weight: 500;
}

.external-links-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 0.75rem;
}

.external-link {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem;
    background: var(--bg-tertiary, #333);
    border-radius: 6px;
    text-decoration: none;
    color: var(--text-primary, #fff);
    transition: all 0.2s ease;
    border: 1px solid var(--border-secondary, #444);
}

.external-link:hover {
    background: var(--bg-hover, #444);
    border-color: var(--text-accent, #00d4ff);
    color: var(--text-accent, #00d4ff);
    transform: translateY(-1px);
}

.external-link iconify-icon {
    font-size: 1.2rem;
    flex-shrink: 0;
}

.biography-content {
    font-size: 0.95rem;
    line-height: 1.6;
    color: var(--text-secondary, #ccc);
}

.biography-content.expanded {
    max-height: none;
}

.biography-toggle {
    display: inline-block;
    margin-top: 1rem;
    padding: 0.5rem 1rem;
    background: var(--bg-tertiary, #333);
    color: var(--text-accent, #00d4ff);
    border: 1px solid var(--text-accent, #00d4ff);
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.2s ease;
}

.biography-toggle:hover {
    background: var(--text-accent, #00d4ff);
    color: var(--bg-primary, #1a1a1a);
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 1rem;
}

.stat-item {
    text-align: center;
    padding: 1rem 0.5rem;
    background: var(--bg-tertiary, #333);
    border-radius: 8px;
    border: 1px solid var(--border-secondary, #444);
    transition: all 0.2s ease;
}

.stat-item:hover {
    border-color: var(--text-accent, #00d4ff);
    background: var(--bg-hover, #444);
}

.stat-value {
    display: block;
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--text-accent, #00d4ff);
    margin-bottom: 0.25rem;
}

.stat-label {
    font-size: 0.8rem;
    color: var(--text-muted, #888);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.activity-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.activity-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem;
    background: var(--bg-tertiary, #333);
    border-radius: 6px;
    border: 1px solid var(--border-secondary, #444);
}

.activity-type {
    font-weight: 500;
    color: var(--text-accent, #00d4ff);
    font-size: 0.9rem;
}

.activity-description {
    color: var(--text-secondary, #ccc);
    font-size: 0.9rem;
    flex: 1;
    margin: 0 1rem;
}

.activity-time {
    color: var(--text-muted, #888);
    font-size: 0.8rem;
}

/* Responsive design */
@media (max-width: 768px) {
    .hero-content {
        flex-direction: column;
        align-items: stretch;
        text-align: center;
    }
    
    .metadata-item {
        flex-direction: column;
        align-items: stretch;
        gap: 0.5rem;
    }
    
    .metadata-value {
        text-align: left;
    }
    
    .external-links-grid {
        grid-template-columns: 1fr;
    }
}

/* Artist Header Actions */
.artist-header-content {
    display: flex;
    align-items: center;
    gap: 2rem;
    padding: 1.5rem;
    background: var(--bg-secondary, #2a2a2a);
    border-radius: 12px;
    margin-bottom: 2rem;
}

.artist-header-info {
    flex: 1;
}

.artist-header-stats {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
    margin-bottom: 0.5rem;
}

.artist-header-actions {
    display: flex;
    gap: 0.75rem;
    align-items: center;
}

.artist-header-actions .btn {
    font-size: 0.8rem !important;
    padding: 0.4rem 0.6rem !important;
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 0.3rem !important;
}

.artist-header-actions .btn iconify-icon {
    font-size: 0.9rem !important;
}

@media (max-width: 768px) {
    .artist-header-content {
        flex-direction: column;
        text-align: center;
        gap: 1rem;
    }
    
    .artist-header-stats {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .artist-header-actions {
        margin-left: 0;
        width: 100%;
        justify-content: center;
    }
    
    .artist-header-actions .btn {
        flex: 1;
        justify-content: center;
    }
}

/* Empty State Styling */
.empty-state {
    text-align: center;
    padding: 2rem;
    color: var(--text-muted, #888);
}

.empty-state-hint {
    font-size: 0.9rem;
    opacity: 0.8;
    margin-top: 0.5rem;
}

.empty-state p {
    margin: 0.5rem 0;
}

/* Spotify Recommendations Styling */
.spotify-section {
    margin-bottom: 2rem;
}

.spotify-section h4 {
    margin-bottom: 1rem;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.artist-grid, .song-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1rem;
}

.song-list, .artist-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.song-item, .artist-item {
    padding: 0.75rem 0;
    border-bottom: 1px solid var(--border-secondary, #333);
}

.song-item:last-child, .artist-item:last-child {
    border-bottom: none;
}

.song-title, .artist-name {
    color: var(--accent-primary, #00d4ff);
    text-decoration: none;
    font-weight: 500;
    transition: color 0.2s ease;
}

.song-title:hover, .artist-name:hover {
    color: var(--accent-secondary, #00b8e6);
    text-decoration: underline;
}

.artist-card, .song-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-primary);
    border-radius: 8px;
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    transition: all 0.2s ease;
}

.artist-card:hover, .song-card:hover {
    border-color: var(--accent-primary);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.artist-info, .song-info {
    flex-grow: 1;
}

.artist-name, .song-title {
    font-weight: bold;
    color: var(--accent-primary);
    text-decoration: none;
    display: block;
    margin-bottom: 0.25rem;
    font-size: 1.1rem;
}

.artist-name:hover, .song-title:hover {
    text-decoration: underline;
}

.artist-details, .song-details {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    font-size: 0.9rem;
    color: var(--text-secondary);
}

.song-artists {
    margin-bottom: 0.5rem;
}

.artist-link {
    color: var(--accent-primary);
    text-decoration: none;
}

.artist-link:hover {
    text-decoration: underline;
}

.popularity {
    color: #1db954; /* Spotify green */
    font-weight: 500;
}

.genres, .album {
    color: var(--text-muted);
    font-style: italic;
}

.spotify-link {
    color: #1db954;
    font-size: 1.2rem;
    text-decoration: none;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: rgba(29, 185, 84, 0.1);
    transition: all 0.2s ease;
}

.spotify-link:hover {
    background: rgba(29, 185, 84, 0.2);
    transform: scale(1.1);
}

.song-actions {
    display: flex;
    gap: 0.5rem;
    align-items: flex-start;
}

.no-data-message {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
}

.no-data-message iconify-icon {
    font-size: 3rem;
    color: var(--text-muted);
    margin-bottom: 1rem;
    display: block;
}

.error-message {
    background: rgba(244, 67, 54, 0.1);
    border: 1px solid rgba(244, 67, 54, 0.3);
    border-radius: 8px;
    padding: 1rem;
    color: #f44336;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.loading-spinner {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .artist-grid, .song-grid {
        grid-template-columns: 1fr;
    }
    
    .artist-card, .song-card {
        flex-direction: column;
        gap: 1rem;
    }
    
    .song-item, .artist-item {
        padding: 0.5rem 0;
    }
    
    .song-actions {
        align-self: stretch;
        justify-content: center;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="artist-detail-container">
    <!-- Artist Header -->
    <div class="artist-header" id="artistHeader">
        <div class="loading-placeholder">Loading artist details...</div>
    </div>
    
    <!-- Artist Navigation Controls -->
    <div class="artist-navigation-controls" id="artistNavigationControls" style="display: none;">
        <div class="nav-info">
            <span id="artistPositionInfo"></span>
        </div>
        <div class="nav-buttons">
            <button id="prevArtistBtn" class="btn btn-secondary" onclick="navigateToPrevArtist()" disabled>
                <span>â†</span> Previous Artist
            </button>
            <button id="nextArtistBtn" class="btn btn-secondary" onclick="navigateToNextArtist()" disabled>
                Next Artist <span>â†’</span>
            </button>
        </div>
    </div>
    
    <!-- Artist Navigation Tabs -->
    <div class="artist-nav-tabs">
        <button class="tab-button active" onclick="showTab('overview')" id="overviewTab">Overview</button>
        <button class="tab-button" onclick="showTab('videos')" id="videosTab">Videos</button>
        <button class="tab-button" onclick="showTab('discover')" id="discoverTab">Discover</button>
        <button class="tab-button" onclick="showTab('settings')" id="settingsTab">Settings</button>
    </div>
    
    <!-- Overview Tab -->
    <div class="tab-content active" id="overviewContent">
        <div class="overview-layout">
            <!-- Hero section with key info -->
            <div class="artist-hero-card">
                <div class="hero-content">
                    <!-- Metadata actions moved to artist header -->
                </div>
            </div>

            <!-- Main content grid -->
            <div class="metadata-grid" style="display: grid !important; grid-template-columns: repeat(2, 1fr) !important; gap: 1.5rem !important;">
                <!-- Row 1: Library Statistics (Full Width) -->
                <div class="metadata-section statistics full-width library-stats-card" style="grid-column: 1 / -1 !important; width: 100% !important;">
                    <div class="section-header">
                        <h3><iconify-icon icon="tabler:chart-bar"></iconify-icon> Library Statistics</h3>
                    </div>
                    <div class="stats-grid" id="artistStats">
                        <div class="loading-placeholder">Loading statistics...</div>
                    </div>
                </div>

                <!-- Row 2: Biography & Overview -->
                <div class="metadata-section biography">
                    <div class="section-header">
                        <h3><iconify-icon icon="tabler:book"></iconify-icon> Biography & Overview</h3>
                        <span class="data-quality-badge" id="biographyQuality">Loading...</span>
                    </div>
                    <div class="metadata-content biography-content" id="biographyContent">
                        <div class="loading-placeholder">Loading biography...</div>
                    </div>
                </div>

                <!-- Row 2: External Services & Metadata -->
                <div class="metadata-section external-services">
                    <div class="section-header">
                        <h3><iconify-icon icon="tabler:cloud"></iconify-icon> Metadata Sources</h3>
                        <div class="header-actions">
                            <span class="data-quality-badge" id="externalServicesQuality">Loading...</span>
                        </div>
                    </div>
                    <div class="metadata-content">
                        <div class="services-list" id="externalServicesContent">
                            <div class="loading-placeholder">Loading external services...</div>
                        </div>
                    </div>
                </div>

                <!-- Song Recommendations Section -->
                <div class="metadata-section song-recommendations">
                    <div class="section-header">
                        <h3><iconify-icon icon="mdi:music-note"></iconify-icon> Song Recommendations</h3>
                    </div>
                    <div class="metadata-content">
                        <div id="songRecommendationsContent">
                            <div class="empty-state">
                                <p>No song recommendations available</p>
                                <p class="empty-state-hint">Use "Enrich from All Services" to populate song recommendations.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Recommended Artists Section -->
                <div class="metadata-section recommended-artists">
                    <div class="section-header">
                        <h3><iconify-icon icon="mdi:account-group"></iconify-icon> Recommended Artists</h3>
                    </div>
                    <div class="metadata-content">
                        <div id="recommendedArtistsContent">
                            <div class="empty-state">
                                <p>No recommended artists available</p>
                                <p class="empty-state-hint">Use "Enrich from All Services" to populate recommended artists.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Row 3: Musical Profile -->
                <div class="metadata-section musical-info">
                    <div class="section-header">
                        <h3><iconify-icon icon="tabler:music"></iconify-icon> Musical Profile</h3>
                        <span class="data-quality-badge" id="musicalInfoQuality">Loading...</span>
                    </div>
                    <div class="metadata-content" id="musicalInfoContent">
                        <div class="loading-placeholder">Loading musical information...</div>
                    </div>
                </div>

                <!-- Row 3: Basic Information -->
                <div class="metadata-section basic-info">
                    <div class="section-header">
                        <h3><iconify-icon icon="tabler:info-circle"></iconify-icon> Basic Information</h3>
                        <span class="data-quality-badge" id="basicInfoQuality">Loading...</span>
                    </div>
                    <div class="metadata-content" id="basicInfoContent">
                        <div class="loading-placeholder">Loading basic information...</div>
                    </div>
                </div>

                <!-- Row 4: Empty Cell -->
                <div class="metadata-section empty-cell" style="visibility: hidden;">
                    <!-- Empty placeholder for layout -->
                </div>

                <!-- Row 4: Recent Activity -->
                <div class="metadata-section activity">
                    <div class="section-header">
                        <h3><iconify-icon icon="tabler:clock"></iconify-icon> Recent Activity</h3>
                    </div>
                    <div class="activity-list" id="recentActivity">
                        <div class="loading-placeholder">Loading activity...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Videos Tab -->
    <div class="tab-content" id="videosContent">
        <div class="videos-toolbar">
            <div class="videos-filters">
                <select id="videoStatusFilter" onchange="filterVideos()">
                    <option value="">All Videos</option>
                    <option value="WANTED">Wanted</option>
                    <option value="DOWNLOADING">Downloading</option>
                    <option value="DOWNLOADED">Downloaded</option>
                    <option value="FAILED">Failed</option>
                    <option value="IGNORED">Ignored</option>
                </select>
                
                <select id="videoYearFilter" onchange="filterVideos()">
                    <option value="">All Years</option>
                    <option value="2024">2024</option>
                    <option value="2023">2023</option>
                    <option value="2022">2022</option>
                    <option value="2021">2021</option>
                    <option value="2020">2020</option>
                    <option value="older">2019 and older</option>
                </select>
                
                <select id="videoQualityFilter" onchange="filterVideos()">
                    <option value="">All Qualities</option>
                    <option value="4K">4K</option>
                    <option value="1080p">1080p</option>
                    <option value="720p">720p</option>
                    <option value="480p">480p</option>
                </select>
                
                <select id="videoSortBy" onchange="sortVideos()">
                    <option value="title">Sort by Title</option>
                    <option value="year">Sort by Year</option>
                    <option value="created_at">Sort by Added Date</option>
                    <option value="status">Sort by Status</option>
                    <option value="duration">Sort by Duration</option>
                </select>
                
                <input type="text" id="videoSearchInput" placeholder="Search titles, directors, producers..." onkeyup="searchVideos()">
                
                <button onclick="toggleAdvancedVideoFilters()" class="btn btn-secondary" id="advancedFiltersBtn">
                    <span>Advanced</span>
                </button>
            </div>
            
            <div class="videos-actions enhanced" id="videosActions">
                <div class="selection-info" id="selectionInfo" style="display: none;">
                    <span class="count" id="selectionCount">0</span>
                    <span>videos selected</span>
                    <button onclick="toggleSelectionMode()" class="selection-mode-toggle" id="selectionModeToggle">
                        <span>ðŸ“‹</span> Selection Mode
                    </button>
                </div>
                
                <div class="action-buttons">
                    <button onclick="selectAllVideos()" class="btn btn-secondary">Select All</button>
                    <button onclick="deselectAllVideos()" class="btn btn-secondary">Deselect All</button>
                    <button onclick="bulkDownloadSelected()" class="btn btn-primary" id="bulkDownloadBtn" disabled>
                        <iconify-icon icon="tabler:download"></iconify-icon>
                        <span id="downloadBtnText">Download Selected</span>
                    </button>
                    <button onclick="bulkAddToPlaylist()" class="btn btn-success" id="bulkPlaylistBtn" disabled>
                        <iconify-icon icon="tabler:playlist-add"></iconify-icon>
                        <span>Add to Playlist</span>
                    </button>
                    <button onclick="bulkUpdateStatus()" class="btn btn-secondary" id="bulkStatusBtn" disabled>
                        <iconify-icon icon="tabler:edit"></iconify-icon>
                        <span id="statusBtnText">Update Status</span>
                    </button>
                    <button onclick="bulkDeleteSelected()" class="btn btn-danger" id="bulkDeleteBtn" disabled>
                        <iconify-icon icon="tabler:trash"></iconify-icon>
                        <span>Delete Selected</span>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="advanced-video-filters" id="advancedVideoFilters" style="display: none;">
            <div class="advanced-filters-grid">
                <div class="filter-group">
                    <label for="videoDurationFilter">Duration:</label>
                    <select id="videoDurationFilter" onchange="filterVideos()">
                        <option value="">Any Duration</option>
                        <option value="short">Short (< 3 min)</option>
                        <option value="medium">Medium (3-6 min)</option>
                        <option value="long">Long (> 6 min)</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="videoDirectorFilter">Director:</label>
                    <input type="text" id="videoDirectorFilter" placeholder="Director name..." onkeyup="filterVideos()">
                </div>
                
                <div class="filter-group">
                    <label for="videoProducerFilter">Producer:</label>
                    <input type="text" id="videoProducerFilter" placeholder="Producer name..." onkeyup="filterVideos()">
                </div>
                
                <div class="filter-group">
                    <label for="videoAlbumFilter">Album:</label>
                    <input type="text" id="videoAlbumFilter" placeholder="Album name..." onkeyup="filterVideos()">
                </div>
                
                <div class="filter-group">
                    <label for="videoDateFromFilter">Added After:</label>
                    <input type="date" id="videoDateFromFilter" onchange="filterVideos()">
                </div>
                
                <div class="filter-group">
                    <label for="videoDateToFilter">Added Before:</label>
                    <input type="date" id="videoDateToFilter" onchange="filterVideos()">
                </div>
            </div>
            
            <div class="advanced-filters-actions">
                <button onclick="clearVideoFilters()" class="btn btn-secondary">Clear All Filters</button>
                <button onclick="exportFilteredVideos()" class="btn btn-info">Export Results</button>
            </div>
        </div>
        
        <div class="videos-grid" id="videosGrid">
            <div class="loading-placeholder">Loading videos...</div>
        </div>
    </div>
    
    
    <!-- Discover Tab -->
    <div class="tab-content" id="discoverContent">
        <div class="discover-panel">
            <div class="discover-header">
                <h3>Discover New Videos</h3>
                <p>Search for new videos by this artist</p>
            </div>
            
            <div class="discover-controls">
                <div class="discover-options-compact">
                    <div class="discover-row">
                        <div class="discover-input-group">
                            <label for="discoverLimit">Videos to discover:</label>
                            <input type="number" id="discoverLimit" value="50" min="1" max="200">
                            <span class="input-hint">(max 200)</span>
                        </div>
                    </div>
                    
                    <div class="discover-row">
                        <div class="discover-checkbox-grid">
                            <label class="checkbox-compact">
                                <input type="checkbox" id="autoImport">
                                Auto-import all
                            </label>
                            
                            <label class="checkbox-compact">
                                <input type="checkbox" id="smartImport">
                                Smart import
                            </label>
                            
                            <label class="checkbox-compact">
                                <input type="checkbox" id="autoDownload">
                                Auto-download
                            </label>
                            
                            <label class="checkbox-compact">
                                <input type="checkbox" id="includeExisting" checked>
                                Include existing
                            </label>
                        </div>
                    </div>
                </div>
                    
                    <div class="discover-filters" style="display: none;">
                        <h4>Filters</h4>
                        <div class="filter-row">
                            <label>Year range:</label>
                            <input type="number" id="yearFrom" placeholder="From" min="1950" max="2030">
                            <span>to</span>
                            <input type="number" id="yearTo" placeholder="To" min="1950" max="2030">
                        </div>
                        
                        <div class="filter-row">
                            <label>Directors (comma-separated):</label>
                            <input type="text" id="directorsFilter" placeholder="e.g. David Fincher, Spike Jonze">
                        </div>
                    </div>
                    
                    <div class="discover-sorting" style="display: none;">
                        <h4>Sorting</h4>
                        <div class="sort-row">
                            <label>Sort by:</label>
                            <select id="sortBy">
                                <option value="year">Year</option>
                                <option value="title">Title</option>
                                <option value="directors">Directors</option>
                                <option value="search_score">Relevance</option>
                            </select>
                            
                            <select id="sortOrder">
                                <option value="desc">Descending</option>
                                <option value="asc">Ascending</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="discover-actions">
                    <button onclick="discoverVideos()" class="btn btn-primary" id="discoverBtn">Discover Videos</button>
                    <button onclick="clearDiscoverFilters()" class="btn btn-secondary">Clear Filters</button>
                    <button onclick="toggleAdvancedDiscovery()" class="btn btn-info" id="advancedDiscoveryBtn">
                        Advanced Options
                    </button>
                </div>
            </div>
            
            <div class="discover-results" id="discoverResults" style="display: none;">
                <div class="discover-results-header">
                    <div class="discover-summary" id="discoverSummary"></div>
                    <div class="discovery-stats" id="discoveryStats"></div>
                </div>
                
                <!-- Batch Import Controls -->
                <div class="batch-import-controls" id="batchImportControls" style="display: none;">
                    <div class="batch-selection">
                        <div class="selection-summary">
                            <span id="selectedForImportCount">0</span> videos selected for import
                        </div>
                        <div class="batch-actions">
                            <button onclick="selectAllForImport()" class="btn btn-secondary">ðŸ“‹ Select All</button>
                            <button onclick="selectNoneForImport()" class="btn btn-secondary">âŒ Select None</button>
                            <button onclick="selectByYear()" class="btn btn-secondary">ðŸ“… Select by Year</button>
                            <button onclick="selectByQuality()" class="btn btn-secondary">â­ Select High Quality</button>
                        </div>
                    </div>
                    
                    <div class="import-options">
                        <div class="import-settings">
                            <label>
                                <input type="checkbox" id="batchAutoDownload" checked>
                                ðŸ“¥ Auto-download imported videos
                            </label>
                            <label>
                                <input type="checkbox" id="batchSkipExisting" checked>
                                ðŸ”„ Skip existing videos
                            </label>
                            <label>
                                <input type="checkbox" id="batchHighPriority">
                                âš¡ High priority downloads
                            </label>
                        </div>
                        
                        <div class="import-execution">
                            <button onclick="executeBatchImport()" class="btn btn-primary btn-large" id="batchImportBtn" disabled>
                                <span id="batchImportText">ðŸš€ Import Selected Videos (0)</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Batch Import Progress -->
                    <div class="batch-progress" id="batchProgress" style="display: none;">
                        <div class="progress-header">
                            <h4>Import Progress</h4>
                            <button onclick="cancelBatchImport()" class="btn btn-warning btn-small" id="cancelBatchBtn">â¹ï¸ Cancel</button>
                        </div>
                        <div class="progress-container">
                            <div class="progress-bar">
                                <div class="progress-fill" id="batchProgressFill" style="width: 0%"></div>
                                <div class="progress-text" id="batchProgressText">0%</div>
                            </div>
                            <div class="progress-details" id="batchProgressDetails">Preparing import...</div>
                        </div>
                        <div class="import-results" id="importResults">
                            <div class="result-summary">
                                <span class="success-count" id="successCount">0</span> imported,
                                <span class="error-count" id="errorCount">0</span> failed,
                                <span class="skip-count" id="skipCount">0</span> skipped
                            </div>
                            <div class="result-details" id="resultDetails"></div>
                        </div>
                    </div>
                </div>
                
                <div class="discovered-videos-grid" id="discoveredVideosGrid"></div>
            </div>
        </div>
    </div>
    
    <!-- Settings Tab -->
    <div class="tab-content" id="settingsContent">
        <!-- Metadata Management Panel -->
        <div class="settings-panel">
            <h3>Link IMVDb Artist</h3>
            <div class="metadata-management">
                <div class="metadata-info">
                    <p>Search and link this artist to their IMVDb profile to automatically fetch metadata including biography, genres, and external links.</p>
                    <div class="metadata-status" id="metadataStatus">
                        <div class="loading-placeholder" style="display: none;">Updating metadata...</div>
                    </div>
                </div>
                
                <div class="metadata-actions">
                    <button type="button" onclick="updateMetadataFromImvdb()" class="btn btn-info">Update from IMVDb</button>
                </div>
            </div>
        </div>
        
        <!-- Enrichment Information Panel -->
        <div class="settings-panel enrichment-info">
            <h3>ðŸ¤– Enrichment Information</h3>
            <div id="enrichmentInfoPanel">
                <div class="empty-state">
                    <p>No enrichment data available</p>
                    <p class="empty-state-hint">Use "Enrich from All Services" to populate metadata</p>
                </div>
            </div>
        </div>
        
        <!-- Enhanced Artist Metadata Editing Panel -->
        <div class="settings-panel enhanced-artist-editing">
            <h3>ðŸŽµ Enhanced Artist Metadata</h3>
            <form id="artistSettingsForm">
                <!-- Basic Information Tab -->
                <!-- Removed metadata tabs for single-page design -->
                
                <!-- Single-page Metadata Form - All sections combined -->
                <div class="single-page-metadata">
                    <!-- Basic Information Section -->
                    <div class="settings-section">
                        <h4 class="section-title">
                            <iconify-icon icon="tabler:user"></iconify-icon>
                            Basic Information
                        </h4>
                        <div class="settings-grid">
                            <div class="setting-group">
                                <label for="artistNameSetting">Artist Name: *</label>
                                <input type="text" id="artistNameSetting" name="name" required>
                                <small class="field-hint">The primary name for this artist</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="sortNameSetting">Sort Name:</label>
                                <input type="text" id="sortNameSetting" name="sort_name">
                                <small class="field-hint">Name used for alphabetical sorting (e.g., "Beatles, The")</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="folderPathSetting">Folder Path:</label>
                                <input type="text" id="folderPathSetting" name="folder_path">
                                <small class="field-hint">Custom folder path for this artist's files</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="keywordsSetting">Keywords:</label>
                                <input type="text" id="keywordsSetting" name="keywords">
                                <small class="field-hint">Comma-separated search keywords</small>
                            </div>
                            
                            <div class="setting-group full-width">
                                <label for="overviewSetting">Biography/Overview:</label>
                                <textarea id="overviewSetting" name="overview" rows="4"></textarea>
                                <small class="field-hint">Artist biography or description</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="genresSetting">Genres:</label>
                                <input type="text" id="genresSetting" name="genres">
                                <small class="field-hint">Comma-separated music genres</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="imvdbIdSetting">IMVDb ID:</label>
                                <div class="input-group">
                                    <input type="number" id="imvdbIdSetting" name="imvdb_id" placeholder="Enter IMVDb ID or leave empty">
                                    <button type="button" id="clearImvdbId" class="btn-clear" title="Clear IMVDb ID">
                                        <i class="fas fa-times"></i>
                                    </button>
                                    <button type="button" id="searchImvdbId" class="btn-search" title="Search for correct IMVDb ID">
                                        <i class="fas fa-search"></i>
                                    </button>
                                </div>
                                <small class="field-hint">
                                    Manually enter the correct IMVDb ID, search for it, or clear if incorrect. 
                                    <a href="https://imvdb.com" target="_blank" rel="noopener">Find ID on IMVDb</a>
                                </small>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Extended Information Section -->
                    <div class="settings-section">
                        <h4 class="section-title">
                            <iconify-icon icon="tabler:info-circle"></iconify-icon>
                            Extended Information
                        </h4>
                        <div class="settings-grid">
                            <div class="setting-group">
                                <label for="formedYearSetting">Formed Year:</label>
                                <input type="number" id="formedYearSetting" name="formed_year" min="1800" max="2030">
                                <small class="field-hint">Year the artist/band was formed</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="disbandedYearSetting">Disbanded Year:</label>
                                <input type="number" id="disbandedYearSetting" name="disbanded_year" min="1800" max="2030">
                                <small class="field-hint">Year the band disbanded (if applicable)</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="originCountrySetting">Origin Country:</label>
                                <select id="originCountrySetting" name="origin_country">
                                    <option value="">Select Country...</option>
                                    <option value="US">United States</option>
                                    <option value="UK">United Kingdom</option>
                                    <option value="CA">Canada</option>
                                    <option value="AU">Australia</option>
                                    <option value="DE">Germany</option>
                                    <option value="FR">France</option>
                                    <option value="JP">Japan</option>
                                    <option value="other">Other</option>
                                </select>
                                <small class="field-hint">Country or region of origin</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="labelsSetting">Record Labels:</label>
                                <input type="text" id="labelsSetting" name="labels">
                                <small class="field-hint">Comma-separated record labels</small>
                            </div>
                            
                            <div class="setting-group full-width">
                                <label for="membersSetting">Band Members:</label>
                                <textarea id="membersSetting" name="members" rows="3"></textarea>
                                <small class="field-hint">Current or notable band members</small>
                            </div>
                        </div>
                    </div>
                    
                    <!-- External Links Section -->
                    <div class="settings-section">
                        <h4 class="section-title">
                            <iconify-icon icon="tabler:link"></iconify-icon>
                            External Links
                        </h4>
                        <div class="settings-grid">
                            <div class="setting-group">
                                <label for="websiteUrlSetting">Official Website:</label>
                                <input type="url" id="websiteUrlSetting" name="website_url">
                                <small class="field-hint">Artist's official website</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="spotifyUrlSetting">Spotify URL:</label>
                                <input type="url" id="spotifyUrlSetting" name="spotify_url">
                                <small class="field-hint">Spotify artist page</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="youtubeUrlSetting">YouTube URL:</label>
                                <input type="url" id="youtubeUrlSetting" name="youtube_url">
                                <small class="field-hint">YouTube channel or artist page</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="appleMusicUrlSetting">Apple Music URL:</label>
                                <input type="url" id="appleMusicUrlSetting" name="apple_music_url">
                                <small class="field-hint">Apple Music artist page</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="twitterUrlSetting">Twitter/X URL:</label>
                                <input type="url" id="twitterUrlSetting" name="twitter_url">
                                <small class="field-hint">Official Twitter/X account</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="facebookUrlSetting">Facebook URL:</label>
                                <input type="url" id="facebookUrlSetting" name="facebook_url">
                                <small class="field-hint">Official Facebook page</small>
                            </div>
                            
                            <div class="setting-group">
                                <label for="instagramUrlSetting">Instagram URL:</label>
                                <input type="url" id="instagramUrlSetting" name="instagram_url">
                                <small class="field-hint">Official Instagram account</small>
                            </div>
                            
                        </div>
                    </div>
                    

                    
                    <!-- Settings Section -->
                    <div class="settings-section">
                        <h4 class="section-title">
                            <iconify-icon icon="tabler:settings"></iconify-icon>
                            Monitoring & Download Settings
                        </h4>
                        
                        <!-- Monitoring Settings -->
                        <div class="settings-subsection">
                            <h5 class="subsection-title">
                                <iconify-icon icon="tabler:eye"></iconify-icon>
                                Monitoring & Discovery
                            </h5>
                            <div class="checkbox-grid">
                                <div class="setting-group checkbox-group">
                                    <label class="checkbox-container">
                                        <input type="checkbox" id="monitoredSetting" name="monitored">
                                        <span class="checkmark"></span>
                                        <div class="checkbox-content">
                                            <span class="checkbox-label">Monitor for new videos</span>
                                            <small class="field-hint">Automatically check for new video releases</small>
                                        </div>
                                    </label>
                                </div>
                                
                                <div class="setting-group checkbox-group">
                                    <label class="checkbox-container">
                                        <input type="checkbox" id="autoDownloadSetting" name="auto_download">
                                        <span class="checkmark"></span>
                                        <div class="checkbox-content">
                                            <span class="checkbox-label">Auto-download new videos</span>
                                            <small class="field-hint">Automatically download newly discovered videos</small>
                                        </div>
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Download Settings -->
                        <div class="settings-subsection">
                            <h5 class="subsection-title">
                                <iconify-icon icon="tabler:download"></iconify-icon>
                                Download Preferences
                            </h5>
                            <div class="settings-grid">
                                <div class="setting-group">
                                    <label for="qualityProfileSetting">Quality Profile:</label>
                                    <select id="qualityProfileSetting" name="quality_profile">
                                        <option value="any">Any Quality</option>
                                        <option value="hd_preferred">HD Preferred</option>
                                        <option value="hd_only">HD Only</option>
                                        <option value="4k_preferred">4K Preferred</option>
                                    </select>
                                    <small class="field-hint">Preferred video quality for downloads</small>
                                </div>
                                
                                <div class="setting-group">
                                    <label for="prioritySetting">Download Priority:</label>
                                    <select id="prioritySetting" name="priority">
                                        <option value="normal">Normal</option>
                                        <option value="high">High</option>
                                        <option value="low">Low</option>
                                    </select>
                                    <small class="field-hint">Priority level for downloads</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="settings-actions">
                    <button type="submit" class="btn btn-primary">ðŸ’¾ Save All Changes</button>
                    <button type="button" onclick="resetSettings()" class="btn btn-secondary">ðŸ”„ Reset</button>
                    <button type="button" onclick="validateMetadata()" class="btn btn-secondary">âœ… Validate</button>
                </div>
            </form>
        </div>
        
        <!-- Enhanced Thumbnail Management Panel -->
        <div class="settings-panel thumbnail-management-enhanced">
            <h3>ðŸ–¼ï¸ Thumbnail Management</h3>
            
            <!-- Current Thumbnail Display -->
            <div class="current-thumbnail-section">
                <div class="thumbnail-display">
                    <div class="thumbnail-container" id="thumbnailContainer">
                        <img id="currentThumbnailImg" src="" alt="Artist thumbnail" style="display: none;">
                        <div id="noThumbnailPlaceholder" class="no-thumbnail-placeholder">
                            <div class="placeholder-icon">ðŸ–¼ï¸</div>
                            <div class="placeholder-text">No thumbnail available</div>
                        </div>
                        <div class="thumbnail-overlay" id="thumbnailOverlay" style="display: none;">
                            <div class="thumbnail-info" id="thumbnailInfo"></div>
                            <div class="thumbnail-actions-overlay">
                                <button onclick="cropThumbnail()" class="btn-overlay" title="Crop">âœ‚ï¸</button>
                                <button onclick="replaceThumbnail()" class="btn-overlay" title="Replace">ðŸ”„</button>
                                <button onclick="deleteThumbnail()" class="btn-overlay" title="Delete">ðŸ—‘ï¸</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Thumbnail Sizes Preview -->
                    <div class="thumbnail-sizes" id="thumbnailSizes" style="display: none;">
                        <h5>Available Sizes:</h5>
                        <div class="sizes-grid">
                            <div class="size-item" data-size="small">
                                <img id="thumbnailSmall" src="" alt="Small thumbnail">
                                <span>Small (150x150)</span>
                            </div>
                            <div class="size-item" data-size="medium">
                                <img id="thumbnailMedium" src="" alt="Medium thumbnail">
                                <span>Medium (300x300)</span>
                            </div>
                            <div class="size-item" data-size="large">
                                <img id="thumbnailLarge" src="" alt="Large thumbnail">
                                <span>Large (600x600)</span>
                            </div>
                            <div class="size-item" data-size="original">
                                <img id="thumbnailOriginal" src="" alt="Original thumbnail">
                                <span>Original</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Thumbnail Metadata -->
                <div class="thumbnail-metadata" id="thumbnailMetadata" style="display: none;">
                    <h5>Thumbnail Information:</h5>
                    <div class="metadata-grid">
                        <div class="metadata-item">
                            <span class="metadata-label">Source:</span>
                            <span class="metadata-value" id="thumbnailSource">-</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Uploaded:</span>
                            <span class="metadata-value" id="thumbnailUploaded">-</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Size:</span>
                            <span class="metadata-value" id="thumbnailSize">-</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Format:</span>
                            <span class="metadata-value" id="thumbnailFormat">-</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Upload Methods -->
            <div class="upload-methods">
                <div class="upload-tabs">
                    <button class="upload-tab active" onclick="switchUploadTab('manual')" id="manualUploadTab">
                        ðŸ“ Manual Upload
                    </button>
                    <button class="upload-tab" onclick="switchUploadTab('url')" id="urlUploadTab">
                        ðŸ”— From URL
                    </button>
                    <button class="upload-tab" onclick="switchUploadTab('search')" id="searchUploadTab">
                        ðŸ” Search Online
                    </button>
                </div>
                
                <!-- Manual Upload Panel -->
                <div class="upload-panel active" id="manualUploadPanel">
                    <div class="drag-drop-area" id="dragDropArea">
                        <div class="drag-drop-content">
                            <div class="upload-icon">ðŸ“¤</div>
                            <div class="upload-text">
                                <h4>Drag & Drop Image Here</h4>
                                <p>Or click to browse and select an image</p>
                                <small>Supported formats: JPEG, PNG, WebP, GIF (max 10MB)</small>
                            </div>
                            <input type="file" id="thumbnailFileInput" accept="image/*" style="display: none;">
                        </div>
                        <div class="upload-progress" id="uploadProgress" style="display: none;">
                            <div class="progress-bar">
                                <div class="progress-fill" id="uploadProgressFill"></div>
                            </div>
                            <div class="progress-text" id="uploadProgressText">Uploading...</div>
                        </div>
                    </div>
                    
                    <!-- Image Preview and Crop -->
                    <div class="image-preview" id="imagePreview" style="display: none;">
                        <div class="preview-header">
                            <h5>Preview & Crop</h5>
                            <div class="preview-actions">
                                <button onclick="cancelImagePreview()" class="btn btn-secondary btn-small">âŒ Cancel</button>
                                <button onclick="uploadSelectedImage()" class="btn btn-primary btn-small">âœ… Upload</button>
                            </div>
                        </div>
                        <div class="preview-container">
                            <canvas id="cropCanvas" width="400" height="300"></canvas>
                            <div class="crop-controls">
                                <button onclick="resetCrop()" class="btn btn-secondary btn-small">ðŸ”„ Reset</button>
                                <button onclick="cropToSquare()" class="btn btn-info btn-small">â¬œ Square</button>
                                <span class="crop-info" id="cropInfo">Click and drag to select crop area</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- URL Upload Panel -->
                <div class="upload-panel" id="urlUploadPanel" style="display: none;">
                    <div class="url-upload-form">
                        <div class="form-group">
                            <label for="thumbnailUrlInput">Image URL:</label>
                            <input type="url" id="thumbnailUrlInput" placeholder="https://example.com/image.jpg" class="form-control">
                        </div>
                        <div class="form-actions">
                            <button onclick="previewUrlImage()" class="btn btn-info">ðŸ” Preview</button>
                            <button onclick="uploadFromUrl()" class="btn btn-primary">ðŸ“¥ Upload</button>
                        </div>
                        <div class="url-preview" id="urlPreview" style="display: none;">
                            <img id="urlPreviewImg" alt="URL preview">
                        </div>
                    </div>
                </div>
                
                <!-- Search Upload Panel -->
                <div class="upload-panel" id="searchUploadPanel" style="display: none;">
                    <div class="search-options">
                        <div class="search-form">
                            <button onclick="searchAllProviders()" class="btn btn-primary provider-btn">
                                ðŸ” Search All Sources
                            </button>
                            <p class="search-info">Searches IMVDb, Wikipedia, and Google Images</p>
                        </div>
                        <div class="search-results" id="searchResults" style="display: none;">
                            <h5>Search Results:</h5>
                            <div class="search-grid" id="searchGrid"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="thumbnail-actions-main">
                <button onclick="refreshThumbnailInfo()" class="btn btn-secondary">
                    ðŸ”„ Refresh Info
                </button>
                <button onclick="showThumbnailStatistics()" class="btn btn-info">
                    ðŸ“Š Statistics
                </button>
                <button onclick="exportThumbnail()" class="btn btn-secondary">
                    ðŸ’¾ Export
                </button>
            </div>
        </div>
        
        <!-- Delete Artist -->
        <div class="settings-panel danger-zone">
            <h3>âš ï¸ Delete Artist</h3>
            <p>Permanently remove this artist and all associated data.</p>
            <button type="button" onclick="confirmDeleteArtist()" class="btn btn-danger">
                ðŸ—‘ï¸ Delete Artist
            </button>
            
            <!-- Analysis Results Container -->
            <div id="analysisResults" class="analysis-results" style="display: none;">
                <div class="results-container">
                    <h4>Deletion Impact Analysis</h4>
                    <div id="dependencySummary"></div>
                    <div id="dependencyDetails"></div>
                    
                    <!-- Deletion Options -->
                    <div id="deletionOptions" style="display: none;" class="deletion-confirmation-section">
                        <h4>Confirm Deletion</h4>
                        <p>Type <strong>"DELETE"</strong> to confirm this action:</p>
                        <input type="text" id="confirmationText" placeholder="Type DELETE to confirm" class="form-control">
                        <div class="button-group">
                            <button id="confirmDeleteBtn" class="btn btn-danger" disabled onclick="deleteArtist()">
                                Permanently Delete Artist
                            </button>
                            <button class="btn btn-secondary" onclick="cancelDeletion()">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Video Selection Modal -->
<div id="videoSelectionModal" class="modal">
    <div class="modal-content large-modal">
        <span class="close">&times;</span>
        <h2>Select Videos to Import</h2>
        <div class="video-selection-grid" id="videoSelectionGrid">
            <div class="loading-placeholder">Loading videos...</div>
        </div>
        <div class="modal-actions">
            <button onclick="importSelectedVideos()" class="btn btn-primary">Import Selected</button>
            <button onclick="hideVideoSelectionModal()" class="btn btn-secondary">Cancel</button>
        </div>
    </div>
</div>

<!-- Status Update Modal -->
<div id="statusUpdateModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2 id="statusModalTitle">Update Video Status</h2>
        <div class="status-selection">
            <h3>Select New Status:</h3>
            <div class="status-options">
                <label><input type="radio" name="statusOption" value="WANTED"> <span class="status-badge status-wanted">Wanted</span></label>
                <label><input type="radio" name="statusOption" value="DOWNLOADING"> <span class="status-badge status-downloading">Downloading</span></label>
                <label><input type="radio" name="statusOption" value="DOWNLOADED"> <span class="status-badge status-downloaded">Downloaded</span></label>
                <label><input type="radio" name="statusOption" value="FAILED"> <span class="status-badge status-failed">Failed</span></label>
                <label><input type="radio" name="statusOption" value="IGNORED"> <span class="status-badge status-ignored">Ignored</span></label>
                <label><input type="radio" name="statusOption" value="MONITORED"> <span class="status-badge status-monitored">Monitored</span></label>
            </div>
        </div>
        <div class="modal-actions">
            <button onclick="confirmStatusUpdate()" class="btn btn-primary">Update Status</button>
            <button onclick="hideStatusUpdateModal()" class="btn btn-secondary">Cancel</button>
        </div>
    </div>
</div>

<!-- Global Queue Modal -->
<div id="globalQueueModal" class="modal">
    <div class="modal-content large-modal">
        <span class="close">&times;</span>
        <h2>Global Download Queue</h2>
        <div class="global-queue-toolbar">
            <div class="queue-stats" id="globalQueueStats">
                <div class="loading-placeholder">Loading queue statistics...</div>
            </div>
            <div class="queue-actions">
                <button onclick="refreshGlobalQueue()" class="btn btn-secondary">Refresh</button>
                <button onclick="clearCompletedGlobal()" class="btn btn-secondary">Clear Completed</button>
            </div>
        </div>
        <div class="global-queue-list" id="globalQueueList">
            <div class="loading-placeholder">Loading global queue...</div>
        </div>
        <div class="modal-actions">
            <button onclick="hideGlobalQueueModal()" class="btn btn-secondary">Close</button>
        </div>
    </div>
</div>

<!-- Video Preview Modal -->
<div id="videoPreviewModal" class="modal">
    <div class="modal-content large-modal">
        <span class="close">&times;</span>
        <h2>Video Metadata Preview</h2>
        <div class="video-preview-container" id="videoPreviewContainer">
            <div class="loading-placeholder">Loading video metadata...</div>
        </div>
        <div class="modal-actions">
            <button onclick="downloadPreviewedVideos()" class="btn btn-primary">Download All</button>
            <button onclick="hideVideoPreviewModal()" class="btn btn-secondary">Close</button>
        </div>
    </div>
</div>

<!-- Merge Artists Modal -->
<div id="mergeArtistModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="hideMergePrompt()">&times;</span>
        <h2>ðŸ”„ Merge Artists Required</h2>
        <div class="merge-explanation">
            <p><strong>Duplicate IMVDb ID Detected!</strong></p>
            <p>The IMVDb ID <span id="conflictImvdbId"></span> is already assigned to another artist. This usually means these artists should be merged.</p>
        </div>
        <div class="merge-content">
            <div class="merge-artists-info" id="mergeArtistsInfo">
                <!-- Artist info will be populated here -->
            </div>
        </div>
        <div class="modal-actions">
            <button onclick="proceedWithMerge()" class="btn btn-warning" id="mergeBtn">Merge Artists</button>
            <button onclick="hideMergePrompt()" class="btn btn-secondary">Cancel</button>
        </div>
    </div>
</div>

<!-- Playlist Selection Modal -->
<div id="playlistModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Add Videos to Playlist</h2>
        <div class="playlist-selection">
            <div class="selection-summary">
                <p>Selected videos: <span id="playlistSelectedCount">0</span></p>
            </div>
            
            <div class="playlist-options">
                <div class="option-group">
                    <h3>Select Playlist:</h3>
                    <select id="playlistSelect" class="form-control">
                        <option value="">Loading playlists...</option>
                    </select>
                </div>
                
                <div class="option-group">
                    <h3>Or Create New Playlist:</h3>
                    <div class="new-playlist-form">
                        <input type="text" id="newPlaylistName" placeholder="Enter playlist name" class="form-control">
                        <textarea id="newPlaylistDescription" placeholder="Optional description" class="form-control" rows="2"></textarea>
                    </div>
                </div>
            </div>
        </div>
        <div class="modal-actions">
            <button onclick="addVideosToPlaylist()" class="btn btn-primary">Add to Playlist</button>
            <button onclick="hidePlaylistModal()" class="btn btn-secondary">Cancel</button>
        </div>
    </div>
</div>

<script>
let currentArtistId = null;
let currentArtistData = null;
let activeTab = 'overview';
let selectedVideos = new Set();
let currentStatusOperation = null; // 'single' or 'bulk'
let currentVideoId = null;
let navigationData = null; // Store navigation data for next/prev artists

document.addEventListener('DOMContentLoaded', function() {
    // Get artist ID from URL path or query parameter
    const pathParts = window.location.pathname.split('/');
    const artistIndex = pathParts.indexOf('artist');
    if (artistIndex !== -1 && pathParts[artistIndex + 1]) {
        currentArtistId = parseInt(pathParts[artistIndex + 1]);
    } else {
        const urlParams = new URLSearchParams(window.location.search);
        currentArtistId = urlParams.get('id');
    }
    
    if (currentArtistId) {
        loadArtistDetails();
        loadArtistNavigation();
    } else {
        document.getElementById('artistHeader').innerHTML = '<div class="error-message">No artist ID provided</div>';
    }
    
    setupEventListeners();
    setupDeletionListeners();
});

function setupEventListeners() {
    // Artist settings form
    document.getElementById('artistSettingsForm').addEventListener('submit', function(e) {
        e.preventDefault();
        saveArtistSettings();
    });
    
    // Video selection modal
    const videoModal = document.getElementById('videoSelectionModal');
    const videoCloseBtn = videoModal.querySelector('.close');
    videoCloseBtn.onclick = hideVideoSelectionModal;
    
    // Status update modal
    const statusModal = document.getElementById('statusUpdateModal');
    const statusCloseBtn = statusModal.querySelector('.close');
    statusCloseBtn.onclick = hideStatusUpdateModal;
    
    // Global queue modal
    const queueModal = document.getElementById('globalQueueModal');
    const queueCloseBtn = queueModal.querySelector('.close');
    queueCloseBtn.onclick = hideGlobalQueueModal;
    
    // Video preview modal
    const previewModal = document.getElementById('videoPreviewModal');
    const previewCloseBtn = previewModal.querySelector('.close');
    previewCloseBtn.onclick = hideVideoPreviewModal;
    
    // Merge artist modal
    const mergeModal = document.getElementById('mergeArtistModal');
    
    // Playlist modal
    const playlistModal = document.getElementById('playlistModal');
    const playlistCloseBtn = playlistModal.querySelector('.close');
    playlistCloseBtn.onclick = hidePlaylistModal;
    
    window.onclick = function(event) {
        if (event.target === videoModal) {
            hideVideoSelectionModal();
        }
        if (event.target === statusModal) {
            hideStatusUpdateModal();
        }
        if (event.target === queueModal) {
            hideGlobalQueueModal();
        }
        if (event.target === previewModal) {
            hideVideoPreviewModal();
        }
        if (event.target === mergeModal) {
            hideMergePrompt();
        }
        if (event.target === playlistModal) {
            hidePlaylistModal();
        }
    };
}

function loadArtistDetails() {
    fetch(`/api/artists/${currentArtistId}/detailed`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                throw new Error(data.error);
            }
            currentArtistData = data;
            renderArtistHeader(data);
            renderOverviewTab(data);
            renderVideosTab(data.videos);
            populateSettings(data);
        })
        .catch(error => {
            console.error('Error loading artist details:', error);
            document.getElementById('artistHeader').innerHTML = `<div class="error-message">Error loading artist: ${error.message}</div>`;
        });
}

function loadArtistVideos() {
    if (!currentArtistId) {
        console.error('No artist ID available for loading videos');
        return;
    }
    
    // If we already have current artist data, just re-render the videos
    if (currentArtistData && currentArtistData.videos) {
        renderVideosTab(currentArtistData.videos);
        return;
    }
    
    // Otherwise fetch fresh data
    fetch(`/api/artists/${currentArtistId}/detailed`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                throw new Error(data.error);
            }
            
            // Update current artist data and render videos
            currentArtistData = data;
            renderVideosTab(data.videos);
        })
        .catch(error => {
            console.error('Error loading artist videos:', error);
            document.getElementById('videosGrid').innerHTML = `<div class="error-message">Error loading videos: ${error.message}</div>`;
        });
}

function renderArtistHeader(artist) {
    const headerHtml = `
        <div class="artist-header-content">
            <div class="artist-thumbnail-large">
                <img src="/api/artists/${artist.id}/thumbnail" alt="${artist.name}" onerror="handleThumbnailError(this)">
            </div>
            <div class="artist-header-info">
                <h1>${artist.name}</h1>
                <div class="artist-header-stats">
                    <span class="header-stat">${artist.statistics.total_videos} videos</span>
                    <span class="header-stat ${artist.monitored ? 'monitored' : 'not-monitored'}">
                        ${artist.monitored ? 'Monitored' : 'Not Monitored'}
                    </span>
                    ${artist.auto_download ? '<span class="header-stat auto-download">Auto-Download</span>' : ''}
                </div>
                <div class="artist-header-actions">
                    <button type="button" onclick="enrichMetadataAllSources(event)" class="btn btn-success">
                        <iconify-icon icon="tabler:sparkles"></iconify-icon>
                        Enrich from All Services
                    </button>
                    <button type="button" onclick="autoMatchServices()" class="btn btn-primary">
                        <iconify-icon icon="tabler:wand"></iconify-icon>
                        Auto-Match Services
                    </button>
                    <button type="button" onclick="viewEnrichmentHistory()" class="btn btn-secondary">
                        <iconify-icon icon="tabler:history"></iconify-icon>
                        Enrichment History
                    </button>
                </div>
                ${artist.last_discovery ? `<p class="last-discovery">Last scan: ${new Date(artist.last_discovery).toLocaleString()}</p>` : ''}
            </div>
        </div>
    `;
    document.getElementById('artistHeader').innerHTML = headerHtml;
}

// Consolidate all metadata from different sources into a single structure
function consolidateArtistMetadata(artist, enrichedMetadata) {
    // There are TWO data storage patterns in this system:
    // 1. Enrichment service data stored directly in imvdb_metadata (biography, enrichment_date, etc.)
    // 2. IMVDb native metadata stored in nested service objects (allmusic_metadata, etc.)
    const imvdbData = artist.imvdb_metadata || {};
    const allmusicData = imvdbData.allmusic_metadata || {};
    const spotifyData = imvdbData.spotify_metadata || {};
    const lastfmData = imvdbData.lastfm_metadata || {};
    const wikipediaData = imvdbData.wikipedia_metadata || {};
    
    // Prepare consolidated metadata structure
    
    const consolidated = {
        // Basic artist info
        id: artist.id,
        name: artist.name,
        spotify_id: artist.spotify_id,
        lastfm_name: artist.lastfm_name,
        imvdb_id: artist.imvdb_id,
        
        // Core fields - check both direct and nested sources
        genres: (() => {
            const artistGenres = artist.genres ? (Array.isArray(artist.genres) ? artist.genres : artist.genres.split(', ')) : null;
            const directGenres = imvdbData.genres ? (Array.isArray(imvdbData.genres) ? imvdbData.genres : imvdbData.genres.split(', ')) : null;
            const allmusicGenres = allmusicData.genres ? (Array.isArray(allmusicData.genres) ? allmusicData.genres : allmusicData.genres.split(', ')) : null;
            const spotifyGenres = spotifyData.genres ? (Array.isArray(spotifyData.genres) ? spotifyData.genres : spotifyData.genres.split(', ')) : null;
            return artistGenres || directGenres || allmusicGenres || spotifyGenres || null;
        })(),
        
        // Biography - check ALL possible sources (both direct and nested)
        biography: artist.overview || artist.biography || imvdbData.biography || imvdbData.bio || 
                  allmusicData.biography || allmusicData.bio || lastfmData.biography || 
                  wikipediaData.biography || null,
        
        // Enriched metadata fields - check both direct and nested sources
        popularity: imvdbData.popularity || spotifyData.popularity || allmusicData.popularity || null,
        followers: imvdbData.followers || spotifyData.followers || null,
        listeners: imvdbData.listeners || lastfmData.listeners || null,
        playcount: imvdbData.playcount || lastfmData.playcount || null,
        
        // Musical info - check both direct and nested sources
        related_artists: imvdbData.related_artists || lastfmData.related_artists || spotifyData.related_artists || [],
        similar_artists: imvdbData.similar_artists || lastfmData.similar_artists || allmusicData.similar_artists || [],
        top_tracks: imvdbData.top_tracks || lastfmData.top_tracks || spotifyData.top_tracks || [],
        
        // Extended info - check both direct and nested sources
        formed_year: imvdbData.formed_year || allmusicData.formed_year || wikipediaData.formed_year || null,
        disbanded_year: imvdbData.disbanded_year || allmusicData.disbanded_year || wikipediaData.disbanded_year || null,
        origin_country: imvdbData.origin_country || allmusicData.origin_country || wikipediaData.origin_country || null,
        labels: imvdbData.labels || allmusicData.labels || spotifyData.labels || null,
        members: imvdbData.members || allmusicData.members || wikipediaData.members || null,
        
        // AllMusic specific fields
        moods: imvdbData.moods || allmusicData.moods || [],
        themes: imvdbData.themes || allmusicData.themes || [],
        
        // External links - check both direct and nested sources
        website_url: imvdbData.website_url || allmusicData.website_url || spotifyData.website_url || null,
        spotify_url: imvdbData.spotify_url || spotifyData.spotify_url || null,
        youtube_url: imvdbData.youtube_url || allmusicData.youtube_url || null,
        apple_music_url: imvdbData.apple_music_url || spotifyData.apple_music_url || null,
        twitter_url: imvdbData.twitter_url || allmusicData.twitter_url || null,
        facebook_url: imvdbData.facebook_url || allmusicData.facebook_url || null,
        instagram_url: imvdbData.instagram_url || allmusicData.instagram_url || null,
        wikipedia_url: imvdbData.wikipedia_url || null,
        
        // Metadata about metadata - enrichment service fields
        enrichment_date: imvdbData.enrichment_date || null,
        sources_used: imvdbData.sources_used || [],
        confidence_score: imvdbData.confidence_score || 0,
        
        // Images - check both direct and nested sources
        images: imvdbData.images || spotifyData.images || allmusicData.images || [],
        
        // IDs from different services
        musicbrainz_id: imvdbData.musicbrainz_id || null,
        allmusic_id: imvdbData.allmusic_id || null,
        
        // Spotify recommendations from enrichment service (stored directly in imvdbData)
        related_artists: (() => {
            const result = imvdbData.related_artists || [];
            return result;
        })(),
        top_tracks: (() => {
            const result = imvdbData.top_tracks || [];
            return result;
        })(),
    };
    
    return consolidated;
}

function renderOverviewTab(artist) {
    const metadata = artist.imvdb_metadata || {};
    
    // Debug logging to understand the data structure
    // Overview tab rendering with metadata
    
    // Extract enriched metadata from deeper in the structure
    let enrichedMetadata = { ...metadata };
    
    // Check if metadata services stored their data in sub-objects
    if (metadata.allmusic_metadata) {
        enrichedMetadata = { ...enrichedMetadata, ...metadata.allmusic_metadata };
    }
    if (metadata.spotify_metadata) {
        enrichedMetadata = { ...enrichedMetadata, ...metadata.spotify_metadata };
    }
    if (metadata.musicbrainz_metadata) {
        enrichedMetadata = { ...enrichedMetadata, ...metadata.musicbrainz_metadata };
    }
    if (metadata.lastfm_metadata) {
        enrichedMetadata = { ...enrichedMetadata, ...metadata.lastfm_metadata };
    }
    if (metadata.wikipedia_metadata) {
        enrichedMetadata = { ...enrichedMetadata, ...metadata.wikipedia_metadata };
    }
    
    // Consolidate all metadata into a single accessible structure
    const consolidatedMetadata = consolidateArtistMetadata(artist, enrichedMetadata);
    
    // Consolidated metadata prepared
    
    // Render each metadata section using consolidated metadata
    renderBasicInfo(artist, consolidatedMetadata);
    renderMusicalInfo(artist, consolidatedMetadata);
    renderExternalLinks(artist, consolidatedMetadata);
    renderBiography(artist, consolidatedMetadata);
    renderStatistics(artist);
    renderRecentActivity(artist);
    
    // Display Spotify recommendations from enriched metadata if available
    renderSpotifyRecommendationsFromMetadata(consolidatedMetadata);
    
    // Update enrichment info panel in Settings tab
    renderEnrichmentInfo(artist, consolidatedMetadata);
}

// Render Spotify recommendations from enriched metadata
function renderSpotifyRecommendationsFromMetadata(metadata) {
    // Updated to use separate containers
    
    console.log('ðŸŽµ renderSpotifyRecommendationsFromMetadata called with metadata:', metadata);
    
    const hasRelatedArtists = metadata.related_artists && metadata.related_artists.length > 0;
    const hasTopTracks = metadata.top_tracks && metadata.top_tracks.length > 0;
    
    console.log('ðŸŽµ Has related artists:', hasRelatedArtists, 'Has top tracks:', hasTopTracks);
    
    if (hasRelatedArtists || hasTopTracks) {
        console.log('ðŸŽµ Displaying Spotify data from enriched metadata:', {
            related_artists: metadata.related_artists,
            top_tracks: metadata.top_tracks
        });
        
        // Populate separate containers for songs and artists
        renderSongRecommendations(metadata.top_tracks || []);
        renderRecommendedArtists(metadata.related_artists || []);
    } else {
        console.log('ðŸŽµ No Spotify data found in enriched metadata, showing empty states');
        // Show empty state in both containers
        renderSongRecommendations([]);
        renderRecommendedArtists([]);
    }
}

// Render enrichment info panel for Settings tab
function renderEnrichmentInfo(artist, metadata) {
    const panel = document.getElementById('enrichmentInfoPanel');
    if (!panel) return;
    
    const hasEnrichmentData = metadata.enrichment_date;
    
    if (hasEnrichmentData) {
        const sourcesUsed = metadata.sources_used || [];
        const enrichmentDate = new Date(metadata.enrichment_date).toLocaleString();
        const confidence = Math.round((metadata.confidence_score || 0) * 100);
        
        panel.innerHTML = `
            <div class="enrichment-details">
                <div class="enrichment-summary">
                    <div class="enrichment-stat">
                        <label>Last Enriched:</label>
                        <span>${enrichmentDate}</span>
                    </div>
                    <div class="enrichment-stat">
                        <label>Confidence Score:</label>
                        <span>${confidence}%</span>
                    </div>
                    <div class="enrichment-stat">
                        <label>Sources Used:</label>
                        <span>${sourcesUsed.join(', ')}</span>
                    </div>
                </div>
                <div class="enrichment-data">
                    <h4>Available Data:</h4>
                    <div class="data-grid">
                        ${metadata.biography ? '<div class="data-item">âœ… Biography</div>' : ''}
                        ${metadata.playcount ? `<div class="data-item">âœ… Play Count: ${metadata.playcount.toLocaleString()}</div>` : ''}
                        ${metadata.listeners ? `<div class="data-item">âœ… Listeners: ${metadata.listeners.toLocaleString()}</div>` : ''}
                        ${metadata.wikipedia_url ? '<div class="data-item">âœ… Wikipedia Link</div>' : ''}
                        ${metadata.musicbrainz_id ? '<div class="data-item">âœ… MusicBrainz ID</div>' : ''}
                        ${metadata.allmusic_id ? '<div class="data-item">âœ… AllMusic ID</div>' : ''}
                    </div>
                </div>
            </div>
        `;
    } else {
        panel.innerHTML = `
            <div class="empty-state">
                <p>No enrichment data available</p>
                <p class="empty-state-hint">Use "Enrich from All Services" to populate metadata</p>
            </div>
        `;
    }
}

// Load Spotify recommendations and related artists
function loadSpotifyRecommendations() {
    const artistId = window.currentArtistId || currentArtistId;
    if (!artistId) {
        console.error('No artist ID available');
        return;
    }
    
    const button = document.getElementById('spotifyRefreshBtn');
    const songContent = document.getElementById('songRecommendationsContent');
    const artistContent = document.getElementById('recommendedArtistsContent');
    
    if (button) {
        button.disabled = true;
        button.innerHTML = '<iconify-icon icon="tabler:loader-2"></iconify-icon> Loading...';
    }
    
    // Show loading state in both containers
    const loadingHtml = '<div class="loading-placeholder"><iconify-icon icon="tabler:loader-2" class="loading-spinner"></iconify-icon> Loading recommendations...</div>';
    if (songContent) {
        songContent.innerHTML = loadingHtml;
    }
    if (artistContent) {
        artistContent.innerHTML = loadingHtml;
    }
    
    fetch(`/api/metadata-enrichment/spotify/recommendations/${artistId}`, {
        method: 'GET',
        credentials: 'include'  // Include cookies for session auth
    })
        .then(response => response.json())
        .then(data => {
            if (data.error && !data.related_artists && !data.recommendations) {
                throw new Error(data.error);
            }
            
            // Render to separate containers
            renderSongRecommendations(data.recommendations || []);
            renderRecommendedArtists(data.related_artists || []);
        })
        .catch(error => {
            console.error('Failed to load Spotify recommendations:', error);
            let errorMessage = error.message;
            if (error.message.includes('404') || error.message.includes('Not Found')) {
                errorMessage = 'Spotify recommendations endpoint not available. The application may need to be restarted to register new API endpoints.';
            }
            
            const errorHtml = `
                <div class="error-message">
                    <iconify-icon icon="tabler:alert-circle"></iconify-icon>
                    Failed to load recommendations: ${errorMessage}
                </div>
            `;
            
            if (songContent) {
                songContent.innerHTML = errorHtml;
            }
            if (artistContent) {
                artistContent.innerHTML = errorHtml;
            }
        })
        .finally(() => {
            if (button) {
                button.disabled = false;
                button.innerHTML = '<iconify-icon icon="tabler:refresh"></iconify-icon> Refresh';
            }
        });
}

// Render Spotify recommendations data
function renderSpotifyRecommendations(data) {
    const content = document.getElementById('spotifyRecommendationsContent');
    if (!content) return;
    
    console.log('ðŸŽµ data.related_artists:', data.related_artists);
    
    let html = '';
    
    // Song Recommendations Section
    if (data.recommendations && data.recommendations.length > 0) {
        console.log('ðŸŽµ Rendering Song Recommendations section');
        html += `
            <div class="spotify-section">
                <h4><iconify-icon icon="mdi:music-note"></iconify-icon> Song Recommendations</h4>
                <ul class="song-list">
        `;
        
        data.recommendations.forEach(track => {
            // Use just the track name for the discover search
            const searchUrl = `/discover?q=${encodeURIComponent(track.name)}`;
            
            html += `
                <li class="song-item">
                    <a href="${searchUrl}" class="song-title" title="Search for ${track.name}">
                        ${track.name}
                    </a>
                </li>
            `;
        });
        
        html += `
                </ul>
            </div>
        `;
    }
    
    // Related Artists Section
    if (data.related_artists && data.related_artists.length > 0) {
        console.log('ðŸŽµ Rendering Recommended Artists section');
        html += `
            <div class="spotify-section">
                <h4><iconify-icon icon="mdi:account-group"></iconify-icon> Recommended Artists</h4>
                <ul class="artist-list">
        `;
        
        data.related_artists.forEach(artist => {
            const searchUrl = `/discover?q=${encodeURIComponent(artist.name)}`;
            html += `
                <li class="artist-item">
                    <a href="${searchUrl}" class="artist-name" title="Search for ${artist.name}">
                        ${artist.name}
                    </a>
                </li>
            `;
        });
        
        html += `
                </ul>
            </div>
        `;
    }
    
    if (html === '') {
        console.log('ðŸŽµ No Spotify data - showing empty state');
        html = `
            <div class="no-data-message">
                <iconify-icon icon="mdi:spotify"></iconify-icon>
                <p>No Spotify recommendations available. Make sure the artist has a Spotify ID and your Spotify integration is configured.</p>
            </div>
        `;
    }
    
    content.innerHTML = html;
}

// Render song recommendations in separate card
function renderSongRecommendations(tracks) {
    const content = document.getElementById('songRecommendationsContent');
    if (!content) return;
    
    console.log('ðŸŽµ renderSongRecommendations called with:', tracks);
    
    if (tracks && tracks.length > 0) {
        let html = '<ul class="song-list">';
        tracks.forEach(track => {
            // Handle both string and object formats
            const trackName = typeof track === 'string' ? track : (track.name || track);
            const searchUrl = `/discover?q=${encodeURIComponent(trackName)}`;
            html += `
                <li class="song-item">
                    <a href="${searchUrl}" class="song-title" title="Search for ${trackName}">
                        ${trackName}
                    </a>
                </li>
            `;
        });
        html += '</ul>';
        content.innerHTML = html;
    } else {
        content.innerHTML = `
            <div class="empty-state">
                <p>No song recommendations available</p>
                <p class="empty-state-hint">Use "Enrich from All Services" to populate song recommendations.</p>
            </div>
        `;
    }
}

// Render recommended artists in separate card
function renderRecommendedArtists(artists) {
    const content = document.getElementById('recommendedArtistsContent');
    if (!content) return;
    
    console.log('ðŸŽµ renderRecommendedArtists called with:', artists);
    
    if (artists && artists.length > 0) {
        let html = '<ul class="song-list">';
        artists.forEach(artist => {
            // Handle both string and object formats
            const artistName = typeof artist === 'string' ? artist : (artist.name || artist);
            const searchUrl = `/discover?q=${encodeURIComponent(artistName)}`;
            html += `
                <li class="song-item">
                    <a href="${searchUrl}" class="song-title" title="Search for ${artistName}">
                        ${artistName}
                    </a>
                </li>
            `;
        });
        html += '</ul>';
        content.innerHTML = html;
    } else {
        content.innerHTML = `
            <div class="empty-state">
                <p>No recommended artists available</p>
                <p class="empty-state-hint">Use "Enrich from All Services" to populate recommended artists.</p>
            </div>
        `;
    }
}

// Handle audio preview playback
function playPreview(previewUrl) {
    // Stop any currently playing audio
    const existingAudio = document.querySelector('audio.preview-audio');
    if (existingAudio) {
        existingAudio.pause();
        existingAudio.remove();
    }
    
    // Create and play new audio element
    const audio = document.createElement('audio');
    audio.src = previewUrl;
    audio.className = 'preview-audio';
    audio.controls = false;
    audio.autoplay = true;
    
    // Add to DOM temporarily for playback
    document.body.appendChild(audio);
    
    // Remove when done playing
    audio.addEventListener('ended', () => {
        audio.remove();
    });
    
    // Remove after 30 seconds max (Spotify previews are 30s)
    setTimeout(() => {
        if (document.body.contains(audio)) {
            audio.pause();
            audio.remove();
        }
    }, 30000);
}

// renderQuickStats function removed - quick stats section was removed from layout

function renderBasicInfo(artist, metadata) {
    let basicInfoHtml = '';
    
    // Core information - clean display without source attribution
    basicInfoHtml += createCleanMetadataItem('Added', new Date(artist.created_at).toLocaleDateString(), 'calendar');
    basicInfoHtml += createCleanMetadataItem('Updated', new Date(artist.updated_at).toLocaleDateString(), 'clock');
    
    if (artist.source) {
        const sourceIcon = getSourceIcon(artist.source);
        basicInfoHtml += createCleanMetadataItem('Source', artist.source, sourceIcon);
    }
    
    if (artist.last_discovery) {
        basicInfoHtml += createCleanMetadataItem('Last Discovery', new Date(artist.last_discovery).toLocaleDateString(), 'search');
    }
    
    // Formation/active years - clean display
    if (artist.formed_year || metadata.formed_year) {
        const formedYear = artist.formed_year || metadata.formed_year;
        let yearText = formedYear.toString();
        if (artist.disbanded_year || metadata.disbanded_year) {
            const disbandedYear = artist.disbanded_year || metadata.disbanded_year;
            yearText += ` - ${disbandedYear}`;
        }
        basicInfoHtml += createCleanMetadataItem('Active Years', yearText, 'timeline');
    }
    
    if (artist.origin_country || metadata.origin_country) {
        const origin = artist.origin_country || metadata.origin_country;
        basicInfoHtml += createCleanMetadataItem('Origin', origin, 'location');
    }
    
    // Members - clean display with human readable text
    if (artist.members || metadata.members) {
        const members = artist.members || metadata.members;
        let memberText = Array.isArray(members) ? members.join(', ') : members;
        
        // Enhanced cleaning - same as biography cleaning
        memberText = cleanMetadataText(memberText);
        
        basicInfoHtml += createCleanMetadataItem('Members', memberText, 'users', true);
    }
    
    document.getElementById('basicInfoContent').innerHTML = basicInfoHtml;
    // Set quality class but remove text content
    const quality = calculateSectionQuality('basic', artist, metadata);
    document.getElementById('basicInfoQuality').className = 'data-quality-badge ' + quality;
    document.getElementById('basicInfoQuality').textContent = '';
}

function renderMusicalInfo(artist, metadata) {
    let musicalInfoHtml = '';
    
    // Debug logging for musical info
    
    // Genres with enhanced styling - create human readable comma-separated list
    const artistGenres = artist.genres ? (Array.isArray(artist.genres) ? artist.genres : artist.genres.split(', ')) : null;
    const metadataGenres = metadata.genres ? (Array.isArray(metadata.genres) ? metadata.genres : metadata.genres.split(', ')) : null;
    
    if ((artistGenres && artistGenres.length > 0) || (metadataGenres && metadataGenres.length > 0)) {
        const genres = artistGenres || metadataGenres;
        // Create human readable comma-separated list and clean it
        let genreText = genres.join(', ');
        genreText = cleanMetadataText(genreText);
        musicalInfoHtml += createCleanMetadataItem('Genres', genreText, 'music');
    }
    
    // Labels with record label styling - create human readable comma-separated list
    if (artist.labels || metadata.labels) {
        const labels = artist.labels || metadata.labels;
        const labelArray = Array.isArray(labels) ? labels : [labels];
        // Create human readable comma-separated list and clean it
        let labelText = labelArray.join(', ');
        labelText = cleanMetadataText(labelText);
        musicalInfoHtml += createCleanMetadataItem('Labels', labelText, 'building');
    }
    
    // AllMusic-specific fields - create human readable comma-separated lists
    if (metadata.moods && metadata.moods.length > 0) {
        let moodsText = metadata.moods.join(', ');
        moodsText = cleanMetadataText(moodsText);
        musicalInfoHtml += createCleanMetadataItem('Moods', moodsText, 'heart');
    }
    
    if (metadata.themes && metadata.themes.length > 0) {
        let themesText = metadata.themes.join(', ');
        themesText = cleanMetadataText(themesText);
        musicalInfoHtml += createCleanMetadataItem('Themes', themesText, 'palette');
    }
    
    // Spotify popularity if available - with source attribution
    if (metadata.spotify_popularity || metadata.popularity) {
        const popularityValue = metadata.spotify_popularity || metadata.popularity;
        const popularityBar = createPopularityBar(popularityValue);
        musicalInfoHtml += createMetadataItemWithSource('Popularity', popularityBar, 'Spotify', 'trending-up');
    }
    
    // Last.fm statistics - with source attribution
    if (metadata.playcount) {
        const formattedPlaycount = (metadata.playcount / 1000000).toFixed(1) + 'M plays';
        musicalInfoHtml += createMetadataItemWithSource('Play Count', formattedPlaycount, 'Last.fm', 'play');
    }
    
    if (metadata.listeners) {
        const formattedListeners = (metadata.listeners / 1000).toFixed(0) + 'K listeners';
        musicalInfoHtml += createMetadataItemWithSource('Listeners', formattedListeners, 'Last.fm', 'users');
    }
    
    if (metadata.followers) {
        const formattedFollowers = (metadata.followers / 1000).toFixed(0) + 'K followers';
        musicalInfoHtml += createMetadataItemWithSource('Followers', formattedFollowers, 'Last.fm', 'user-plus');
    }
    
    if (metadata.similar_artists && metadata.similar_artists.length > 0) {
        musicalInfoHtml += createMetadataItem('Similar Artists', metadata.similar_artists.join(', '), true);
    }
    
    // Music-related metadata
    if (metadata.discography) {
        const disco = metadata.discography;
        if (disco.album_count || (disco.popular_albums && disco.popular_albums.length > 0)) {
            let discoText = '';
            if (disco.album_count) discoText += `${disco.album_count} albums`;
            if (disco.popular_albums && disco.popular_albums.length > 0) {
                if (discoText) discoText += ' â€¢ ';
                discoText += `Popular: ${disco.popular_albums.slice(0, 3).join(', ')}`;
            }
            musicalInfoHtml += createMetadataItem('Discography', discoText, true);
        }
    }
    
    if (!musicalInfoHtml) {
        musicalInfoHtml = `
            <div class="empty-state">
                <p>No musical information available</p>
                <p class="empty-state-hint">Use "Enrich from All Services" to fetch genres, styles, moods, and other musical data</p>
            </div>
        `;
    }
    
    document.getElementById('musicalInfoContent').innerHTML = musicalInfoHtml;
    document.getElementById('musicalInfoQuality').className = 'data-quality-badge ' + calculateSectionQuality('musical', artist, metadata);
    document.getElementById('musicalInfoQuality').textContent = '';
}

function renderExternalLinks(artist, metadata) {
    // This function is now replaced by renderExternalServices
    renderExternalServices(artist, metadata);
}

function renderExternalServices(artist, metadata) {
    const services = [
        {
            id: 'spotify',
            name: 'Spotify',
            searchFunction: 'searchSpotify',
            syncFunction: 'syncFromSpotify',
            connected: !!artist.spotify_id,
            serviceId: artist.spotify_id
        },
        {
            id: 'musicbrainz',
            name: 'MusicBrainz',
            searchFunction: 'searchMusicBrainz',
            syncFunction: 'enrichFromMusicBrainz',
            connected: !!(metadata.musicbrainz_id || (artist.imvdb_metadata && artist.imvdb_metadata.musicbrainz_id)),
            serviceId: metadata.musicbrainz_id || (artist.imvdb_metadata && artist.imvdb_metadata.musicbrainz_id)
        },
        {
            id: 'lastfm',
            name: 'Last.fm',
            searchFunction: 'searchLastfm',
            syncFunction: 'enrichFromLastfm',
            connected: !!artist.lastfm_name,
            serviceId: artist.lastfm_name
        },
        {
            id: 'imvdb',
            name: 'IMVDb',
            searchFunction: 'showImvdbIdentifyModal',
            syncFunction: 'syncFromImvdb',
            connected: !!artist.imvdb_id,
            serviceId: artist.imvdb_id
        },
        {
            id: 'allmusic',
            name: 'AllMusic',
            searchFunction: 'searchAllMusic',
            syncFunction: 'enrichFromAllMusic',
            connected: !!(metadata.allmusic_id || (artist.imvdb_metadata && artist.imvdb_metadata.allmusic_id)),
            serviceId: metadata.allmusic_id || (artist.imvdb_metadata && artist.imvdb_metadata.allmusic_id) || 'Not Linked'
        },
        {
            id: 'wikipedia',
            name: 'Wikipedia',
            searchFunction: 'searchWikipedia',
            syncFunction: 'enrichFromWikipedia',
            connected: !!(metadata.wikipedia_url),
            serviceId: 'Connected' // Wikipedia uses URLs not IDs
        }
    ];

    const servicesHtml = services.map(service => `
        <div class="service-item-new">
            <strong>
                <a href="javascript:void(0)" onclick="${service.searchFunction}()" class="service-name-link" style="color: var(--text-accent, #00d4ff); text-decoration: none; font-weight: bold;">
                    ${service.name}
                </a>:
            </strong>
            <span class="service-id" style="margin-left: 5px; color: ${service.connected ? 'var(--success-color, #4CAF50)' : 'var(--text-muted, #888)'};">
                ${service.connected ? (service.serviceId || 'Connected') : 'Not Linked'}
            </span>
            <br>
        </div>
    `).join('');

    document.getElementById('externalServicesContent').innerHTML = servicesHtml;
    
    // Update quality badge
    const connectedServices = services.filter(s => s.connected).length;
    const totalServices = services.length;
    const qualityScore = (connectedServices / totalServices) * 100;
    
    let quality = 'poor';
    if (qualityScore >= 75) quality = 'excellent';
    else if (qualityScore >= 50) quality = 'good';
    else if (qualityScore >= 25) quality = 'fair';
    
    document.getElementById('externalServicesQuality').className = 'data-quality-badge ' + quality;
    document.getElementById('externalServicesQuality').textContent = `${connectedServices}/${totalServices} Connected`;
}

function showImvdbIdentifyModal() {
    // Use the proper search function instead of opening external site
    searchImvdb();
}

async function refreshAllMetadataProviders() {
    const artistId = getCurrentArtistId();
    if (!artistId) {
        showError('No artist ID found');
        return;
    }
    
    showLoading('Refreshing all metadata providers...');
    try {
        const response = await apiRequest(`/api/metadata-enrichment/enrich/${artistId}`, {
            method: 'POST',
            body: JSON.stringify({
                force_refresh: true
            })
        });
        
        if (response.success) {
            showSuccess('All metadata providers refreshed successfully');
            // Refresh the artist data display
            loadArtistDetails();
        } else {
            showError('Failed to refresh some metadata providers: ' + (response.errors && response.errors.join(', ') || 'Unknown error'));
        }
    } catch (error) {
        showError('Failed to refresh metadata providers: ' + error.message);
    }
}

function renderBiography(artist, metadata) {
    // Check multiple possible sources for biography data
    // The metadata parameter here is the consolidated metadata from consolidateArtistMetadata
    const bio = artist.overview || 
                artist.biography || 
                metadata.biography ||
                (artist.imvdb_metadata && artist.imvdb_metadata.biography) ||
                (artist.imvdb_metadata && artist.imvdb_metadata.overview) ||
                (artist.imvdb_metadata && artist.imvdb_metadata.bio);
    
    // Debug logging to understand data structure
    
    // Try to extract biography from nested structures
    if (!bio && artist.imvdb_metadata && typeof artist.imvdb_metadata === 'object') {
        const imvdbKeys = Object.keys(artist.imvdb_metadata);
        console.log('IMVDb metadata keys:', imvdbKeys);
        console.log('IMVDb metadata content:', artist.imvdb_metadata);
    }
    
    if (bio) {
        // Use the same cleaning function as other metadata sections
        const cleanBio = cleanMetadataText(bio);
        
        const isLong = cleanBio.length > 500;
        const shortBio = isLong ? cleanBio.substring(0, 500) + '...' : cleanBio;
        
        const biographyHtml = `
            <div class="biography-text" id="biographyText">
                ${isLong ? shortBio : cleanBio}
            </div>
            ${isLong ? `
                <button class="biography-toggle" onclick="toggleBiography()">
                    <span id="biographyToggleText">Read More</span>
                </button>
                <div class="biography-full" id="biographyFull" style="display: none;">
                    ${cleanBio}
                </div>
            ` : ''}
        `;
        document.getElementById('biographyContent').innerHTML = biographyHtml;
    } else {
        document.getElementById('biographyContent').innerHTML = `
            <div class="empty-state">
                <p>No biography available</p>
                <p class="empty-state-hint">Use "Enrich from All Services" to fetch biography from Wikipedia and other sources</p>
            </div>
        `;
    }
    
    document.getElementById('biographyQuality').className = 'data-quality-badge ' + (bio ? 'good' : 'none');
    document.getElementById('biographyQuality').textContent = '';
}

function renderStatistics(artist) {
    const statsHtml = `
        <div class="stat-item">
            <span class="stat-value">${artist.statistics.total_videos}</span>
            <span class="stat-label">Total Videos</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${artist.statistics.downloaded_videos}</span>
            <span class="stat-label">Downloaded</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${artist.statistics.wanted_videos}</span>
            <span class="stat-label">Wanted</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${artist.statistics.downloading_videos}</span>
            <span class="stat-label">Downloading</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${artist.statistics.failed_videos}</span>
            <span class="stat-label">Failed</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${artist.statistics.monitored_videos || 0}</span>
            <span class="stat-label">Monitored</span>
        </div>
        <div class="stat-item">
            <span class="stat-value">${artist.statistics.ignored_videos || 0}</span>
            <span class="stat-label">Ignored</span>
        </div>
    `;
    document.getElementById('artistStats').innerHTML = statsHtml;
}

function renderRecentActivity(artist) {
    const activityItems = [];
    
    if (artist.last_discovery) {
        activityItems.push({
            type: 'Discovery',
            description: 'Last video discovery',
            time: new Date(artist.last_discovery).toLocaleDateString()
        });
    }
    
    if (artist.updated_at) {
        activityItems.push({
            type: 'Update',
            description: 'Artist information updated',
            time: new Date(artist.updated_at).toLocaleDateString()
        });
    }
    
    const metadata = artist.imvdb_metadata || {};
    if (metadata.enrichment_date) {
        activityItems.push({
            type: 'Enrichment',
            description: 'Metadata enriched from external sources',
            time: new Date(metadata.enrichment_date).toLocaleDateString()
        });
    }
    
    const activityHtml = activityItems.length > 0 ? 
        activityItems.map(item => `
            <div class="activity-item">
                <span class="activity-type">${item.type}</span>
                <span class="activity-description">${item.description}</span>
                <span class="activity-time">${item.time}</span>
            </div>
        `).join('') :
        '<div class="loading-placeholder">No recent activity</div>';
    
    document.getElementById('recentActivity').innerHTML = activityHtml;
}

// Helper functions
function createMetadataItem(label, value, fullWidth = false) {
    if (!value) return '';
    return `
        <div class="metadata-item ${fullWidth ? 'full-width' : ''}">
            <span class="metadata-label">${label}:</span>
            <span class="metadata-value">${value}</span>
        </div>
    `;
}

function createTagList(items) {
    if (!Array.isArray(items)) return items;
    return `<div class="metadata-tags">${items.map(item => `<span class="metadata-tag">${item}</span>`).join('')}</div>`;
}

function calculateDataCompleteness(artist) {
    const metadata = artist.imvdb_metadata || {};
    let score = 0;
    let total = 0;
    
    // Basic fields (40% weight)
    const basicFields = ['name', 'created_at'];
    basicFields.forEach(field => {
        total += 4;
        if (artist[field]) score += 4;
    });
    
    // Extended fields (30% weight)
    const extendedFields = ['formed_year', 'origin_country', 'genres', 'imvdb_id'];
    extendedFields.forEach(field => {
        total += 3;
        if (artist[field] || metadata[field]) score += 3;
    });
    
    // Rich metadata (30% weight)
    const richFields = ['biography', 'members', 'moods', 'themes', 'similar_artists'];
    richFields.forEach(field => {
        total += 3;
        if (artist[field] || metadata[field]) score += 3;
    });
    
    return Math.round((score / total) * 100);
}

function calculateSectionQuality(section, artist, metadata) {
    switch (section) {
        case 'basic':
            const basicScore = [
                artist.formed_year || metadata.formed_year,
                artist.origin_country || metadata.origin_country,
                artist.members || metadata.members,
                artist.source
            ].filter(Boolean).length;
            return basicScore >= 3 ? 'excellent' : basicScore >= 2 ? 'good' : basicScore >= 1 ? 'fair' : 'none';
            
        case 'musical':
            const musicalScore = [
                artist.genres || metadata.genres,
                metadata.moods,
                metadata.themes,
                metadata.similar_artists,
                artist.labels || metadata.labels
            ].filter(x => x && (Array.isArray(x) ? x.length > 0 : true)).length;
            return musicalScore >= 4 ? 'excellent' : musicalScore >= 3 ? 'good' : musicalScore >= 1 ? 'fair' : 'none';
            
        case 'external':
            const externalScore = [
                artist.imvdb_id,
                artist.spotify_id,
                artist.lastfm_name,
                metadata.allmusic_id || (metadata.imvdb_metadata && metadata.imvdb_metadata.allmusic_id),
                artist.website_url
            ].filter(Boolean).length;
            return externalScore >= 4 ? 'excellent' : externalScore >= 3 ? 'good' : externalScore >= 1 ? 'fair' : 'none';
            
        default:
            return 'none';
    }
}

function getQualityLabel(quality) {
    const labels = {
        'excellent': 'Excellent',
        'good': 'Good',
        'fair': 'Fair',
        'poor': 'Poor',
        'none': 'None'
    };
    return labels[quality] || 'Unknown';
}

// Enhanced metadata quality analysis
function calculateEnhancedMetadataQuality(artist, metadata) {
    const analysis = {
        overall: 0,
        sections: {},
        missing: [],
        suggestions: [],
        strengths: []
    };
    
    // Basic Information Analysis
    const basicFields = {
        name: { weight: 10, present: !!artist.name },
        formed_year: { weight: 8, present: !!(artist.formed_year || metadata.formed_year) },
        origin_country: { weight: 8, present: !!(artist.origin_country || metadata.origin_country) },
        members: { weight: 6, present: !!(artist.members || metadata.members) },
        disbanded_year: { weight: 4, present: !!(artist.disbanded_year || metadata.disbanded_year) },
        source: { weight: 3, present: !!artist.source }
    };
    
    const basicAnalysis = analyzeFieldGroup('Basic Information', basicFields, analysis);
    analysis.sections.basic = basicAnalysis;
    
    // Musical Information Analysis
    const musicalFields = {
        genres: { weight: 10, present: !!((artist.genres && artist.genres.length > 0) || (metadata.genres && metadata.genres.length > 0)) },
        labels: { weight: 6, present: !!(artist.labels || metadata.labels) },
        moods: { weight: 4, present: !!(metadata.moods && metadata.moods.length > 0) },
        themes: { weight: 4, present: !!(metadata.themes && metadata.themes.length > 0) },
        similar_artists: { weight: 3, present: !!(metadata.similar_artists && metadata.similar_artists.length > 0) },
        spotify_popularity: { weight: 2, present: !!metadata.spotify_popularity }
    };
    
    const musicalAnalysis = analyzeFieldGroup('Musical Profile', musicalFields, analysis);
    analysis.sections.musical = musicalAnalysis;
    
    // External Links Analysis
    const externalFields = {
        imvdb_id: { weight: 10, present: !!artist.imvdb_id },
        spotify_id: { weight: 8, present: !!artist.spotify_id },
        lastfm_name: { weight: 6, present: !!artist.lastfm_name },
        allmusic_id: { weight: 5, present: !!(metadata.allmusic_id || (metadata.imvdb_metadata && metadata.imvdb_metadata.allmusic_id)) },
        website_url: { weight: 4, present: !!artist.website_url },
        youtube_url: { weight: 3, present: !!artist.youtube_url }
    };
    
    const externalAnalysis = analyzeFieldGroup('External Services', externalFields, analysis);
    analysis.sections.external = externalAnalysis;
    
    // Biography Analysis
    const biographyFields = {
        biography: { weight: 10, present: !!(artist.biography || artist.overview || metadata.biography) },
        description: { weight: 5, present: !!metadata.description }
    };
    
    const biographyAnalysis = analyzeFieldGroup('Biography & Overview', biographyFields, analysis);
    analysis.sections.biography = biographyAnalysis;
    
    // Calculate overall score
    const totalWeight = Object.values({...basicFields, ...musicalFields, ...externalFields, ...biographyFields})
        .reduce((sum, field) => sum + field.weight, 0);
    const achievedWeight = Object.values({...basicFields, ...musicalFields, ...externalFields, ...biographyFields})
        .filter(field => field.present)
        .reduce((sum, field) => sum + field.weight, 0);
        
    analysis.overall = Math.round((achievedWeight / totalWeight) * 100);
    
    // Generate suggestions based on missing high-value fields
    generateQualityImprovementSuggestions(analysis, artist, metadata);
    
    return analysis;
}

function analyzeFieldGroup(groupName, fields, globalAnalysis) {
    const totalWeight = Object.values(fields).reduce((sum, field) => sum + field.weight, 0);
    const achievedWeight = Object.values(fields)
        .filter(field => field.present)
        .reduce((sum, field) => sum + field.weight, 0);
    
    const percentage = Math.round((achievedWeight / totalWeight) * 100);
    const quality = percentage >= 80 ? 'excellent' : percentage >= 60 ? 'good' : percentage >= 40 ? 'fair' : percentage >= 20 ? 'poor' : 'none';
    
    // Track missing high-value fields
    Object.entries(fields).forEach(([fieldName, fieldData]) => {
        if (!fieldData.present && fieldData.weight >= 6) {
            globalAnalysis.missing.push({
                field: fieldName,
                group: groupName,
                weight: fieldData.weight,
                impact: fieldData.weight >= 8 ? 'high' : 'medium'
            });
        }
    });
    
    // Track strengths
    Object.entries(fields).forEach(([fieldName, fieldData]) => {
        if (fieldData.present && fieldData.weight >= 8) {
            globalAnalysis.strengths.push({
                field: fieldName,
                group: groupName,
                weight: fieldData.weight
            });
        }
    });
    
    return {
        percentage,
        quality,
        totalFields: Object.keys(fields).length,
        presentFields: Object.values(fields).filter(f => f.present).length,
        missingHighValue: Object.values(fields).filter(f => !f.present && f.weight >= 6).length
    };
}

function generateQualityImprovementSuggestions(analysis, artist, metadata) {
    const suggestions = [];
    
    // Priority suggestions based on missing high-impact fields
    if (!artist.imvdb_id) {
        suggestions.push({
            priority: 'high',
            action: 'Connect to IMVDb',
            description: 'Link this artist to IMVDb for video discovery and metadata enhancement',
            benefit: 'Enables automatic video discovery and rich metadata'
        });
    }
    
    if (!artist.spotify_id) {
        suggestions.push({
            priority: 'high',
            action: 'Connect to Spotify',
            description: 'Link this artist to Spotify for music metadata and popularity data',
            benefit: 'Provides genres, popularity metrics, and related artists'
        });
    }
    
    if (!(artist.genres && artist.genres.length > 0) && !(metadata.genres && metadata.genres.length > 0)) {
        suggestions.push({
            priority: 'high',
            action: 'Add Genre Information',
            description: 'Specify musical genres for better categorization',
            benefit: 'Improves discovery and filtering capabilities'
        });
    }
    
    if (!artist.formed_year && !metadata.formed_year) {
        suggestions.push({
            priority: 'medium',
            action: 'Add Formation Year',
            description: 'Specify when the artist/band was formed',
            benefit: 'Enables timeline-based filtering and historical context'
        });
    }
    
    if (!artist.origin_country && !metadata.origin_country) {
        suggestions.push({
            priority: 'medium',
            action: 'Add Origin Information',
            description: 'Specify the artist\'s country or region of origin',
            benefit: 'Enables geographical filtering and cultural context'
        });
    }
    
    if (!artist.biography && !artist.overview && !metadata.biography) {
        suggestions.push({
            priority: 'medium',
            action: 'Add Biography',
            description: 'Provide background information about the artist',
            benefit: 'Enriches user experience with artist context and history'
        });
    }
    
    analysis.suggestions = suggestions;
}

function showMetadataQualityAnalysis() {
    if (!currentArtistData) {
        showWarning('No artist data available for quality analysis');
        return;
    }
    
    const analysis = calculateEnhancedMetadataQuality(currentArtistData, currentArtistData.imvdb_metadata || {});
    displayQualityAnalysisModal(analysis);
}

function displayQualityAnalysisModal(analysis) {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
        <div class="quality-analysis-modal">
            <div class="modal-header">
                <h3><iconify-icon icon="tabler:chart-pie"></iconify-icon> Metadata Quality Analysis</h3>
                <button type="button" class="close-btn" onclick="this.closest('.modal-overlay').remove()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="quality-overview">
                    <div class="overall-score">
                        <div class="score-circle ${getScoreClass(analysis.overall)}">
                            <span class="score-value">${analysis.overall}</span>
                            <span class="score-label">%</span>
                        </div>
                        <h4>Overall Quality Score</h4>
                        <p class="score-description">${getScoreDescription(analysis.overall)}</p>
                    </div>
                </div>
                
                <div class="section-scores">
                    ${Object.entries(analysis.sections).map(([section, data]) => `
                        <div class="section-score">
                            <div class="section-info">
                                <h5>${data.group || section}</h5>
                                <span class="quality-badge ${data.quality}">${getQualityLabel(data.quality)}</span>
                            </div>
                            <div class="section-details">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${data.percentage}%"></div>
                                </div>
                                <span class="section-stats">${data.presentFields}/${data.totalFields} fields complete</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                ${analysis.suggestions.length > 0 ? `
                    <div class="improvement-suggestions">
                        <h4>Improvement Suggestions</h4>
                        <div class="suggestions-list">
                            ${analysis.suggestions.map(suggestion => `
                                <div class="suggestion-item priority-${suggestion.priority}">
                                    <div class="suggestion-header">
                                        <span class="suggestion-action">${suggestion.action}</span>
                                        <span class="priority-badge priority-${suggestion.priority}">${suggestion.priority}</span>
                                    </div>
                                    <p class="suggestion-description">${suggestion.description}</p>
                                    <p class="suggestion-benefit"><strong>Benefit:</strong> ${suggestion.benefit}</p>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
                
                ${analysis.strengths.length > 0 ? `
                    <div class="metadata-strengths">
                        <h4>Data Strengths</h4>
                        <div class="strengths-list">
                            ${analysis.strengths.map(strength => `
                                <span class="strength-badge">${strength.field} (${strength.group})</span>
                            `).join('')}
                        </div>
                    </div>
                ` : ''}
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

function getScoreClass(score) {
    if (score >= 80) return 'excellent';
    if (score >= 60) return 'good';
    if (score >= 40) return 'fair';
    if (score >= 20) return 'poor';
    return 'none';
}

function getScoreDescription(score) {
    if (score >= 80) return 'Excellent metadata coverage with comprehensive information';
    if (score >= 60) return 'Good metadata quality with most important fields present';
    if (score >= 40) return 'Fair metadata coverage with room for improvement';
    if (score >= 20) return 'Poor metadata quality - consider enriching from external sources';
    return 'Minimal metadata present - significant enrichment needed';
}

function toggleBiography() {
    const biographyText = document.getElementById('biographyText');
    const biographyFull = document.getElementById('biographyFull');
    const toggleText = document.getElementById('biographyToggleText');
    
    if (biographyFull.style.display === 'none') {
        biographyText.style.display = 'none';
        biographyFull.style.display = 'block';
        toggleText.textContent = 'Read Less';
    } else {
        biographyText.style.display = 'block';
        biographyFull.style.display = 'none';
        toggleText.textContent = 'Read More';
    }
}

// Enhanced metadata display functions
function createEnhancedMetadataItem(label, value, icon = 'info', source = '', fullWidth = false) {
    if (!value) return '';
    return `
        <div class="metadata-item enhanced ${fullWidth ? 'full-width' : ''}">
            <div class="metadata-header">
                <span class="metadata-label">
                    <iconify-icon icon="tabler:${icon}"></iconify-icon>
                    ${label}:
                </span>
                ${source ? `<span class="metadata-source">${source}</span>` : ''}
            </div>
            <div class="metadata-value">${value}</div>
        </div>
    `;
}

function createEnhancedTagList(items, tagType = 'default') {
    if (!Array.isArray(items)) items = [items];
    const typeClass = `metadata-tag-${tagType}`;
    return `<div class="metadata-tags enhanced">${items.map(item => 
        `<span class="metadata-tag ${typeClass}" title="${item}">${item}</span>`
    ).join('')}</div>`;
}

function createMetadataItemWithSource(label, value, source, icon = 'info', fullWidth = false) {
    if (!value) return '';
    return `
        <div class="metadata-item enhanced ${fullWidth ? 'full-width' : ''}">
            <div class="metadata-header">
                <span class="metadata-label">
                    <iconify-icon icon="tabler:${icon}"></iconify-icon>
                    ${label}:
                </span>
                <span class="metadata-source">${source}</span>
            </div>
            <div class="metadata-value">${value}</div>
        </div>
    `;
}

function createCleanMetadataItem(label, value, icon = 'info', fullWidth = false) {
    if (!value) return '';
    return `
        <div class="metadata-item enhanced ${fullWidth ? 'full-width' : ''}">
            <div class="metadata-header">
                <span class="metadata-label">
                    <iconify-icon icon="tabler:${icon}"></iconify-icon>
                    ${label}:
                </span>
            </div>
            <div class="metadata-value">${value}</div>
        </div>
    `;
}

function cleanMetadataText(text) {
    if (!text) return text;
    
    // Debug logging
    console.log('Cleaning metadata text:', JSON.stringify(text));
    
    let cleanText = text;
    
    // Enhanced patterns to remove quality indicators and source prefixes
    const patternsToRemove = [
        /^Good\s*\n*/i,           // Remove "Good" at start with optional newline
        /^Good\s+/i,              // Remove "Good" followed by space
        /^Excellent\s*\n*/i,      // Remove "Excellent" at start with optional newline
        /^Excellent\s+/i,         // Remove "Excellent" followed by space
        /^Fair\s*\n*/i,           // Remove "Fair" at start with optional newline
        /^Fair\s+/i,              // Remove "Fair" followed by space
        /^Poor\s*\n*/i,           // Remove "Poor" at start with optional newline
        /^Poor\s+/i,              // Remove "Poor" followed by space
        /^None\s*\n*/i,           // Remove "None" at start with optional newline
        /^None\s+/i,              // Remove "None" followed by space
        /^User\s*\n*/i,           // Remove "User" at start with optional newline
        /^User\s+/i,              // Remove "User" followed by space
        /^\s*Good\s*$/m,          // Remove standalone "Good" on its own line
        /^\s*Excellent\s*$/m,     // Remove standalone "Excellent" on its own line
        /^\s*Fair\s*$/m,          // Remove standalone "Fair" on its own line
        /^\s*Poor\s*$/m,          // Remove standalone "Poor" on its own line
        /^\s*User\s*$/m,          // Remove standalone "User" on its own line
        /,\s*Good\s*,/gi,         // Remove "Good" from middle of comma-separated lists
        /,\s*Excellent\s*,/gi,    // Remove "Excellent" from middle of comma-separated lists
        /,\s*Fair\s*,/gi,         // Remove "Fair" from middle of comma-separated lists
        /,\s*Poor\s*,/gi,         // Remove "Poor" from middle of comma-separated lists
        /,\s*User\s*,/gi,         // Remove "User" from middle of comma-separated lists
        /,\s*Good\s*$/gi,         // Remove "Good" at end of comma-separated lists
        /,\s*Excellent\s*$/gi,    // Remove "Excellent" at end of comma-separated lists
        /,\s*Fair\s*$/gi,         // Remove "Fair" at end of comma-separated lists
        /,\s*Poor\s*$/gi,         // Remove "Poor" at end of comma-separated lists
        /,\s*User\s*$/gi,         // Remove "User" at end of comma-separated lists
        /^Good\s*,\s*/gi,         // Remove "Good" at start of comma-separated lists
        /^Excellent\s*,\s*/gi,    // Remove "Excellent" at start of comma-separated lists
        /^Fair\s*,\s*/gi,         // Remove "Fair" at start of comma-separated lists
        /^Poor\s*,\s*/gi,         // Remove "Poor" at start of comma-separated lists
        /^User\s*,\s*/gi          // Remove "User" at start of comma-separated lists
    ];
    
    patternsToRemove.forEach(pattern => {
        cleanText = cleanText.replace(pattern, '');
    });
    
    // Clean up any resulting double commas or spaces
    cleanText = cleanText.replace(/,\s*,/g, ',').replace(/^\s*,\s*/, '').replace(/,\s*$/, '');
    
    // Remove any resulting empty lines at the start and trim whitespace
    cleanText = cleanText.replace(/^\s*\n+/g, '').trim();
    
    console.log('Cleaned metadata text:', JSON.stringify(cleanText));
    
    return cleanText;
}

function getSourceIcon(source) {
    const icons = {
        'IMVDB': 'database',
        'AllMusic': 'music',
        'Spotify': 'brand-spotify',
        'MusicBrainz': 'vinyl',
        'Last.fm': 'brand-lastfm',
        'YouTube': 'brand-youtube',
        'Manual': 'user'
    };
    return icons[source] || 'info';
}

function getRegionFromCountry(country) {
    // Simple region mapping - could be expanded
    const regions = {
        'United States': 'North America',
        'Canada': 'North America', 
        'United Kingdom': 'Europe',
        'Germany': 'Europe',
        'France': 'Europe',
        'Japan': 'Asia',
        'Australia': 'Oceania'
    };
    return regions[country] || 'Unknown';
}

function getMetadataSource(metadata, field) {
    // Try to determine source based on metadata structure
    if (metadata.allmusic_data && metadata.allmusic_data[field]) return 'AllMusic';
    if (metadata.spotify_data && metadata.spotify_data[field]) return 'Spotify';
    if (metadata.musicbrainz_data && metadata.musicbrainz_data[field]) return 'MusicBrainz';
    return 'External Source';
}

function createPopularityBar(popularity) {
    const percentage = Math.max(0, Math.min(100, popularity));
    const color = percentage > 70 ? '#4CAF50' : percentage > 40 ? '#FF9800' : '#f44336';
    return `
        <div class="popularity-container">
            <div class="popularity-bar">
                <div class="popularity-fill" style="width: ${percentage}%; background: ${color};"></div>
            </div>
            <span class="popularity-value">${percentage}/100</span>
        </div>
    `;
}

function updateSectionQuality(elementId, section, artist, metadata) {
    const quality = calculateSectionQuality(section, artist, metadata);
    const element = document.getElementById(elementId);
    if (element) {
        element.className = 'data-quality-badge ' + quality;
        element.textContent = getQualityLabel(quality);
    }
}

function showMetadataHistory() {
    // Placeholder for metadata enrichment history
    showInfo('Metadata enrichment history feature coming soon!');
}

function renderVideosTab(videos) {
    if (!videos || videos.length === 0) {
        document.getElementById('videosGrid').innerHTML = '<div class="no-results">No videos found. Try discovering videos from IMVDb.</div>';
        return;
    }
    
    const videosHtml = videos.map(video => `
        <div class="video-card" data-video-id="${video.id}" data-status="${video.status}" onclick="handleVideoCardClick(event, ${video.id})">
            <input type="checkbox" class="video-select" onchange="toggleVideoSelection(${video.id})" onclick="event.stopPropagation()">
            <div class="selection-indicator"></div>
            <div class="video-thumbnail">
                <img src="${video.thumbnail_url || '/static/placeholder-video.png'}" alt="${video.title}" onerror="this.src='/static/placeholder-video.png'">
                <div class="video-status status-${video.status ? video.status.toLowerCase() : 'unknown'}">${video.status || 'Unknown'}</div>
            </div>
            <div class="video-info">
                <h4>${video.title}</h4>
                <div class="video-metadata">
                    ${video.year ? `<span class="video-year">${video.year}</span>` : ''}
                    ${video.duration ? `<span class="video-duration">${formatDuration(video.duration)}</span>` : ''}
                    ${video.directors && video.directors.length > 0 ? `<span class="video-directors">Dir: ${video.directors.join(', ')}</span>` : ''}
                </div>
                <div class="video-actions">
                    <button type="button" onclick="event.stopPropagation(); viewVideoDetails(${video.id})" class="btn btn-icon btn-info" title="View Details">
                        <iconify-icon icon="tabler:eye"></iconify-icon>
                    </button>
                    <button type="button" onclick="event.stopPropagation(); downloadVideo(${video.id})" class="btn btn-icon btn-primary" ${video.status === 'DOWNLOADED' ? 'disabled' : ''} title="${video.status === 'DOWNLOADING' ? 'Downloading...' : video.status === 'DOWNLOADED' ? 'Downloaded' : 'Download'}">
                        <iconify-icon icon="${video.status === 'DOWNLOADING' ? 'tabler:loader-2' : video.status === 'DOWNLOADED' ? 'tabler:check' : 'tabler:download'}"></iconify-icon>
                    </button>
                    <button type="button" onclick="event.stopPropagation(); updateVideoStatus(${video.id})" class="btn btn-icon btn-secondary" title="Update Status">
                        <iconify-icon icon="tabler:edit"></iconify-icon>
                    </button>
                    <button type="button" onclick="event.stopPropagation(); refreshVideoMetadata(${video.id})" class="btn btn-icon btn-warning" title="Refresh Metadata">
                        <iconify-icon icon="tabler:refresh"></iconify-icon>
                    </button>
                    <button 
                        type="button"
                        class="btn btn-icon btn-danger delete-video-btn" 
                        data-video-id="${video.id}" 
                        data-video-title="${(video.title || 'Unknown Video').replace(/"/g, '&quot;')}" 
                        data-youtube-id="${video.youtube_id || ''}" 
                        title="Delete Video">
                        <iconify-icon icon="tabler:trash"></iconify-icon>
                    </button>
                </div>
            </div>
        </div>
    `).join('');
    
    document.getElementById('videosGrid').innerHTML = videosHtml;
    updateVideoSelectionButtons();
    
    // Add event listeners for delete buttons
    document.querySelectorAll('.delete-video-btn').forEach(btn => {
        btn.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            const videoId = this.dataset.videoId;
            deleteVideo(videoId);
        });
    });
}



function discoverVideos() {
    if (!currentArtistId) return;
    
    // Get enhanced discovery options
    const limit = parseInt(document.getElementById('discoverLimit').value) || 50;
    const autoImport = document.getElementById('autoImport').checked;
    const smartImport = document.getElementById('smartImport').checked;
    const autoDownload = document.getElementById('autoDownload').checked;
    const includeExisting = document.getElementById('includeExisting').checked;
    
    // Get filter options
    const yearFrom = document.getElementById('yearFrom').value ? 
                    parseInt(document.getElementById('yearFrom').value) : null;
    const yearTo = document.getElementById('yearTo').value ? 
                  parseInt(document.getElementById('yearTo').value) : null;
    const directorsFilterText = document.getElementById('directorsFilter').value.trim();
    const directorsFilter = directorsFilterText ? 
                           directorsFilterText.split(',').map(d => d.trim()).filter(d => d) : [];
    
    // Get sorting options
    const sortBy = document.getElementById('sortBy').value;
    const sortOrder = document.getElementById('sortOrder').value;
    
    const discoverBtn = document.getElementById('discoverBtn');
    discoverBtn.disabled = true;
    discoverBtn.textContent = 'Discovering...';
    
    // Build enhanced request payload
    const requestData = {
        limit: limit,
        auto_import: autoImport,
        smart_import: smartImport,
        auto_download: autoDownload,
        filters: {
            year_from: yearFrom,
            year_to: yearTo,
            include_existing: includeExisting,
            directors: directorsFilter
        },
        sort_by: sortBy,
        sort_order: sortOrder
    };
    
    fetch(`/api/artists/${currentArtistId}/videos/discover`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            throw new Error(data.error);
        }
        
        renderDiscoverResults(data);
        
        if (autoImport && data.imported_count > 0) {
            // Refresh the videos tab
            loadArtistDetails();
        }
    })
    .catch(error => {
        console.error('Error discovering videos:', error);
        showError('Error discovering videos: ' + error.message);
    })
    .finally(() => {
        discoverBtn.disabled = false;
        discoverBtn.textContent = 'Discover Videos';
    });
}

function renderDiscoverResults(data) {
    console.log('ðŸ”§ Entering renderDiscoverResults function at line:', new Error().stack.split('\n')[1]);
    const resultsDiv = document.getElementById('discoverResults');
    const summaryDiv = document.getElementById('discoverSummary');
    const videosDiv = document.getElementById('discoveredVideosGrid');
    const statsDiv = document.getElementById('discoveryStats');
    const batchControlsDiv = document.getElementById('batchImportControls');
    
    // Enhanced Summary with filtering and sorting info
    const filtersApplied = data.filters_applied || {};
    const statistics = data.statistics || {};
    
    // Use fallback for artist name and validate discovery date
    const artistName = data.artist_name || (currentArtistData ? currentArtistData.name : 'Unknown Artist');
    const discoveryDate = data.discovery_date ? new Date(data.discovery_date) : new Date();
    
    console.log('ðŸ”§ About to set summaryDiv.innerHTML at line:', new Error().stack.split('\n')[1]);
    // Simplified template to isolate syntax error
    summaryDiv.innerHTML = '<div>Test content</div>';
    
    // Render discovery statistics
    const newVideosCount = data.discovered_videos ? data.discovered_videos.filter(v => !v.already_exists && !v.imported).length : 0;
    const qualityStats = calculateQualityStats(data.discovered_videos || []);
    
    statsDiv.innerHTML = `
        <div class="stats-grid">
            <div class="stat-card">
                <span class="stat-value">${newVideosCount}</span>
                <span class="stat-label">Available for Import</span>
            </div>
            <div class="stat-card">
                <span class="stat-value">${qualityStats.highQuality}</span>
                <span class="stat-label">High Quality</span>
            </div>
            <div class="stat-card">
                <span class="stat-value">${qualityStats.withThumbnails}</span>
                <span class="stat-label">With Thumbnails</span>
            </div>
            <div class="stat-card">
                <span class="stat-value">${qualityStats.recentVideos}</span>
                <span class="stat-label">Recent (5 years)</span>
            </div>
        </div>
    `;
    
    // Show batch import controls if there are videos to import
    if (newVideosCount > 0) {
        batchControlsDiv.style.display = 'block';
        initializeBatchImportSelection(data.discovered_videos);
    } else {
        batchControlsDiv.style.display = 'none';
    }
    
    // Videos
    if (data.discovered_videos && data.discovered_videos.length > 0) {
        const videosHtml = data.discovered_videos.map(video => `
            <div class="discovered-video-card enhanced ${video.already_exists ? 'already-exists' : ''} ${video.imported ? 'imported' : ''} ${video.source || 'imvdb'}" 
                 data-imvdb-id="${video.imvdb_id || ''}" 
                 data-youtube-id="${video.youtube_id || ''}"
                 data-source="${video.source || 'imvdb'}"
                 data-existing="${video.already_exists}" 
                 data-year="${video.year || 0}"
                 data-quality="${getVideoQuality(video)}"
                 data-selectable="${!video.already_exists && !video.imported}">
                
                ${!video.already_exists && !video.imported ? `
                    <div class="batch-select-overlay">
                        <input type="checkbox" class="video-batch-select" 
                               onchange="updateBatchSelection()" 
                               data-imvdb-id="${video.imvdb_id || ''}"
                               data-youtube-id="${video.youtube_id || ''}"
                               data-source="${video.source || 'imvdb'}">
                    </div>
                ` : ''}
                
                <div class="discovered-video-thumbnail">
                    <img src="${video.thumbnail_url || '/static/placeholder-video.png'}" alt="${video.title}" onerror="this.src='/static/placeholder-video.png'">
                    <div class="video-badges">
                        <div class="source-badge source-${video.source || 'imvdb'}">${(video.source || 'imvdb').toUpperCase()}</div>
                        ${video.already_exists ? `<div class="exists-badge">Exists (${video.existing_status || 'Unknown'})</div>` : ''}
                        ${video.imported ? '<div class="imported-badge">Imported</div>' : ''}
                        <div class="quality-badge quality-${getVideoQuality(video).toLowerCase()}">
                            ${getVideoQuality(video)}
                        </div>
                    </div>
                </div>
                
                <div class="discovered-video-info">
                    <h5>${video.title}</h5>
                    <div class="discovered-video-metadata">
                        ${video.year ? '<span class="meta-year">ðŸ“… ' + video.year + '</span>' : ''}
                        ${video.source === 'youtube' && video.channel_title ? '<span class="meta-channel">ðŸ“º ' + video.channel_title + '</span>' : ''}
                        ${video.source === 'youtube' && video.view_count ? '<span class="meta-views">ðŸ‘ï¸ ' + formatNumber(video.view_count) + ' views</span>' : ''}
                        ${video.source === 'youtube' && video.like_count ? '<span class="meta-likes">ðŸ‘ ' + formatNumber(video.like_count) + '</span>' : ''}
                        ${video.source === 'youtube' && video.published_at ? '<span class="meta-published">ðŸ“… ' + new Date(video.published_at).toLocaleDateString() + '</span>' : ''}
                        ${video.source !== 'youtube' && video.directors && video.directors.length > 0 ? '<span class="meta-directors">ðŸŽ¥ ' + video.directors.join(', ') + '</span>' : ''}
                        ${video.source !== 'youtube' && video.producers && video.producers.length > 0 ? '<span class="meta-producers">ðŸŽ¤ ' + video.producers.join(', ') + '</span>' : ''}
                        ${video.source !== 'youtube' && video.album ? '<span class="meta-album">ðŸ’¿ ' + video.album + '</span>' : ''}
                        ${video.source !== 'youtube' && video.genre ? '<span class="meta-genre">ðŸŽµ ' + video.genre + '</span>' : ''}
                        ${video.duration ? '<span class="meta-duration">â±ï¸ ' + formatDuration(video.duration) + '</span>' : ''}
                    </div>
                    
                    ${video.description ? `
                        <div class="discovered-video-description">
                            ${video.description.substring(0, 100)}${video.description.length > 100 ? '...' : ''}
                        </div>
                    ` : ''}
                    
                    <div class="discovered-video-actions">
                        ${!video.already_exists && !video.imported ? `
                            <button onclick="importSingleVideo('${video.youtube_id || video.imvdb_id}', '${video.youtube_id ? 'youtube' : 'imvdb'}', this)" class="btn btn-small btn-primary" data-video-data="${JSON.stringify(video).replace(/'/g, '&apos;')}" data-debug-source="${video.source || 'imvdb'}" data-debug-youtube="${video.youtube_id || 'none'}" data-debug-imvdb="${video.imvdb_id || 'none'}">ðŸš€ Import</button>
                        ` : ''}
                        ${video.already_exists && video.existing_video_id ? `
                            <button onclick="viewVideoDetails(${video.existing_video_id})" class="btn btn-small btn-info">ðŸ” View Details</button>
                        ` : ''}
                        ${video.source === 'youtube' && video.youtube_url ? `
                            <button onclick="window.open('${video.youtube_url}', '_blank')" class="btn btn-small btn-secondary">â–¶ï¸ YouTube</button>
                        ` : ''}
                        ${video.source === 'imvdb' && video.imvdb_url ? `
                            <button onclick="window.open('${video.imvdb_url}', '_blank')" class="btn btn-small btn-secondary">ðŸŒ IMVDb</button>
                        ` : ''}
                    </div>
                </div>
            </div>
        `).join('');
        
        videosDiv.innerHTML = videosHtml;
    } else {
        videosDiv.innerHTML = '<div class="no-results">No videos discovered</div>';
    }
    
    resultsDiv.style.display = 'block';
}

function clearDiscoverFilters() {
    document.getElementById('yearFrom').value = '';
    document.getElementById('yearTo').value = '';
    document.getElementById('directorsFilter').value = '';
    document.getElementById('includeExisting').checked = true;
    document.getElementById('sortBy').value = 'year';
    document.getElementById('sortOrder').value = 'desc';
    document.getElementById('discoverLimit').value = '50';
    document.getElementById('autoImport').checked = false;
    document.getElementById('smartImport').checked = false;
    document.getElementById('autoDownload').checked = false;
}

function toggleAdvancedDiscovery() {
    const filtersDiv = document.querySelector('.discover-filters');
    const sortingDiv = document.querySelector('.discover-sorting');
    const btn = document.getElementById('advancedDiscoveryBtn');
    
    const isVisible = filtersDiv.style.display !== 'none';
    
    if (isVisible) {
        filtersDiv.style.display = 'none';
        sortingDiv.style.display = 'none';
        btn.textContent = 'Advanced Options';
        btn.classList.remove('active');
    } else {
        filtersDiv.style.display = 'block';
        sortingDiv.style.display = 'block';
        btn.textContent = 'Hide Advanced';
        btn.classList.add('active');
    }
}

// Utility functions
function formatDuration(seconds) {
    if (!seconds) return 'Unknown';
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    } else {
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
}

function formatFileSize(bytes) {
    if (!bytes) return 'Unknown';
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
}

function formatNumber(num) {
    if (!num) return '0';
    if (num >= 1000000000) {
        return (num / 1000000000).toFixed(1) + 'B';
    } else if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
    } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
    }
    return num.toString();
}

function toggleVideoSelection(videoId) {
    const videoCard = document.querySelector(`[data-video-id="${videoId}"]`);
    const checkbox = videoCard.querySelector('.video-select');
    
    if (selectedVideos.has(videoId)) {
        selectedVideos.delete(videoId);
        checkbox.checked = false;
        videoCard.classList.remove('selected');
    } else {
        selectedVideos.add(videoId);
        checkbox.checked = true;
        videoCard.classList.add('selected');
        
        // Add animation class temporarily
        videoCard.classList.add('just-selected');
        setTimeout(() => videoCard.classList.remove('just-selected'), 300);
    }
    
    updateVideoSelectionButtons();
}

// Enhanced selection workflow functions
function handleVideoCardClick(event, videoId) {
    // Prevent action if clicking on buttons, icons, or checkbox
    if (event.target.tagName === 'BUTTON' || 
        event.target.type === 'checkbox' ||
        event.target.tagName === 'ICONIFY-ICON' ||
        event.target.closest('button') ||
        event.target.closest('.video-actions')) {
        console.log('Click ignored - button or icon clicked');
        return;
    }
    
    // Toggle selection if in bulk selection mode or if ctrl/cmd is held
    if (isInBulkSelectionMode() || event.ctrlKey || event.metaKey) {
        event.preventDefault();
        toggleVideoSelection(videoId);
    } else {
        // Double-click to edit video
        if (event.detail === 2) {
            editVideo(videoId);
        }
    }
}

function editVideo(videoId) {
    // Set current video for thumbnail manager
    window.currentEditVideoId = videoId;
    
    // Load video details for editing
    fetch(`/api/videos/${videoId}`)
        .then(response => response.json())
        .then(video => {
            showVideoEditModal(video);
        })
        .catch(error => {
            console.error('Error loading video:', error);
            showError('Failed to load video details');
        });
}

function showVideoEditModal(video) {
    const modalHtml = `
        <div id="videoEditModal" class="modal-overlay" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 9999;">
            <div class="modal-content" style="background: white; padding: 20px; border-radius: 8px; max-width: 90vw; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header">
                    <h2>Edit Video: ${video.title}</h2>
                    <button onclick="closeVideoEditModal()" style="float: right; background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label>Title:</label>
                        <input type="text" id="editVideoTitle" value="${video.title}" style="width: 100%; padding: 8px; margin: 5px 0;">
                    </div>
                    <div class="form-group">
                        <label>Artist Name:</label>
                        <div class="artist-input-container" style="display: flex; align-items: center; position: relative;">
                            <input type="text" id="editVideoArtist" value="${video.artist_name || ''}" style="width: 100%; padding: 8px; margin: 5px 0;">
                            <button type="button" id="identifyArtistBtn" onclick="identifyArtistInModal()" style="margin-left: 10px; padding: 6px 12px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                ðŸ” Identify Artist
                            </button>
                            <div id="artistSuggestions" class="artist-suggestions" style="display: none; position: absolute; top: calc(100% + 5px); left: 0; right: 0; background-color: #2d2d2d; border: 1px solid #444; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); z-index: 10000; max-height: 200px; overflow-y: auto;">
                                <!-- Artist suggestions will be populated here -->
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Year:</label>
                        <input type="number" id="editVideoYear" value="${video.year || ''}" style="width: 100%; padding: 8px; margin: 5px 0;">
                    </div>
                    <div class="form-group">
                        <label>Status:</label>
                        <select id="editVideoStatus" style="width: 100%; padding: 8px; margin: 5px 0;">
                            <option value="pending" ${video.status === 'pending' ? 'selected' : ''}>Pending</option>
                            <option value="available" ${video.status === 'available' ? 'selected' : ''}>Available</option>
                            <option value="downloaded" ${video.status === 'downloaded' ? 'selected' : ''}>Downloaded</option>
                            <option value="archived" ${video.status === 'archived' ? 'selected' : ''}>Archived</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <button onclick="openVideoThumbnailManager()" class="btn btn-primary">Manage Thumbnails</button>
                    </div>
                </div>
                <div class="modal-footer">
                    <button onclick="saveVideoChanges()" class="btn btn-primary">Save Changes</button>
                    <button onclick="closeVideoEditModal()" class="btn btn-secondary">Cancel</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeVideoEditModal() {
    const modal = document.getElementById('videoEditModal');
    if (modal) {
        modal.remove();
    }
    window.currentEditVideoId = null;
}

function saveVideoChanges() {
    const videoId = window.currentEditVideoId;
    if (!videoId) return;
    
    const updates = {
        title: document.getElementById('editVideoTitle').value,
        artist_name: document.getElementById('editVideoArtist').value,
        year: parseInt(document.getElementById('editVideoYear').value) || null,
        status: document.getElementById('editVideoStatus').value
    };
    
    fetch(`/api/videos/${videoId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(updates)
    })
    .then(response => response.json())
    .then(data => {
        showSuccess('Video updated successfully');
        closeVideoEditModal();
        loadVideos(); // Refresh the videos list
    })
    .catch(error => {
        console.error('Error updating video:', error);
        showError('Failed to update video');
    });
}

function openVideoThumbnailManager() {
    if (!window.currentEditVideoId) {
        showError('No video selected for thumbnail management');
        return;
    }
    
    // Launch thumbnail search for the current video
    searchVideoThumbnails(window.currentEditVideoId);
}

function identifyArtistInModal() {
    const videoId = window.currentEditVideoId;
    if (!videoId) {
        showWarning('No video selected');
        return;
    }
    
    const button = document.getElementById('identifyArtistBtn');
    const originalText = button.innerHTML;
    button.innerHTML = 'ðŸ”„ Identifying...';
    button.disabled = true;
    
    fetch(`/api/videos/${videoId}/identify-artist`, {
        method: 'POST'
    })
    .then(response => response.json())
    .then(result => {
        displayArtistSuggestionsInModal(result);
        button.innerHTML = originalText;
        button.disabled = false;
    })
    .catch(error => {
        console.error('Error identifying artist:', error);
        showError('Failed to identify artist');
        button.innerHTML = originalText;
        button.disabled = false;
    });
}

function displayArtistSuggestionsInModal(data) {
    const suggestionsDiv = document.getElementById('artistSuggestions');
    
    if (!data.success || !data.suggestions || data.suggestions.length === 0) {
        suggestionsDiv.innerHTML = '<div style="padding: 10px; color: #888;">No artist suggestions found</div>';
        suggestionsDiv.style.display = 'block';
        return;
    }
    
    let suggestionsHtml = '';
    data.suggestions.forEach(suggestion => {
        const confidencePercent = Math.round(suggestion.confidence * 100);
        suggestionsHtml += `
            <div class="artist-suggestion" onclick="selectArtistInModal('${suggestion.artist.replace(/'/g, "\\'")}', ${suggestion.artist_id})" 
                 style="padding: 10px; border-bottom: 1px solid #555; cursor: pointer; color: white;">
                <strong>${suggestion.artist}</strong>
                <span style="float: right; color: #888; font-size: 0.9em;">${confidencePercent}% match</span>
            </div>
        `;
    });
    
    suggestionsDiv.innerHTML = suggestionsHtml;
    suggestionsDiv.style.display = 'block';
    
    // Hide suggestions when clicking outside
    setTimeout(() => {
        document.addEventListener('click', function hideOnClickOutside(event) {
            if (!suggestionsDiv.contains(event.target) && event.target.id !== 'identifyArtistBtn') {
                suggestionsDiv.style.display = 'none';
                document.removeEventListener('click', hideOnClickOutside);
            }
        });
    }, 100);
}

function selectArtistInModal(artistName, artistId) {
    document.getElementById('editVideoArtist').value = artistName;
    document.getElementById('artistSuggestions').style.display = 'none';
}

function searchVideoThumbnails(videoId) {
    showSuccess('Searching for thumbnails...');
    
    fetch(`/api/videos/${videoId}/thumbnail/search`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            showError(`Thumbnail search failed: ${data.error}`);
            return;
        }
        
        if (!data.thumbnails || data.thumbnails.length === 0) {
            showError('No thumbnails found for this video');
            return;
        }
        
        showThumbnailSelectionModal(data.thumbnails, videoId);
    })
    .catch(error => {
        console.error('Error searching thumbnails:', error);
        showError('Failed to search for thumbnails');
    });
}

function showThumbnailSelectionModal(thumbnails, videoId) {
    const modalHtml = `
        <div id="thumbnailSelectionModal" class="modal-overlay" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 10000;">
            <div class="modal-content" style="background: white; padding: 20px; border-radius: 8px; max-width: 90vw; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header">
                    <h2>Select Thumbnail</h2>
                    <button onclick="closeThumbnailSelectionModal()" style="float: right; background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="thumbnail-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">
                        ${thumbnails.map((thumb, index) => `
                            <div class="thumbnail-option" style="border: 2px solid #ddd; border-radius: 8px; padding: 10px; cursor: pointer; text-align: center;" onclick="selectThumbnail('${thumb.url}', ${videoId}, ${index})">
                                <img src="${thumb.url}" style="width: 100%; height: 120px; object-fit: cover; border-radius: 4px;" onerror="this.style.display='none'">
                                <div style="margin-top: 8px; font-size: 12px;">
                                    <div><strong>Source:</strong> ${thumb.source}</div>
                                    <div><strong>Quality:</strong> ${thumb.quality}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div class="modal-footer">
                    <button onclick="closeThumbnailSelectionModal()" class="btn btn-secondary">Cancel</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function selectThumbnail(thumbnailUrl, videoId, index) {
    fetch(`/api/videos/${videoId}/thumbnail`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            thumbnail_url: thumbnailUrl
        })
    })
    .then(response => response.json())
    .then(data => {
        showSuccess('Thumbnail updated successfully');
        closeThumbnailSelectionModal();
        loadVideos(); // Refresh the videos list
    })
    .catch(error => {
        console.error('Error updating thumbnail:', error);
        showError('Failed to update thumbnail');
    });
}

function closeThumbnailSelectionModal() {
    const modal = document.getElementById('thumbnailSelectionModal');
    if (modal) {
        modal.remove();
    }
}

function toggleSelectionMode() {
    const container = document.querySelector('.artist-detail-container');
    const toggleBtn = document.getElementById('selectionModeToggle');
    
    if (container.classList.contains('bulk-selection-mode')) {
        // Exit selection mode
        container.classList.remove('bulk-selection-mode');
        toggleBtn.innerHTML = '<span>ðŸ“‹</span> Selection Mode';
        toggleBtn.classList.remove('active');
        
        // Clear all selections
        deselectAllVideos();
        
        showInfo('Selection mode disabled');
    } else {
        // Enter selection mode
        container.classList.add('bulk-selection-mode');
        toggleBtn.innerHTML = '<span>âœ“</span> Exit Selection';
        toggleBtn.classList.add('active');
        
        showInfo('Selection mode enabled - click video cards to select');
    }
}

function isInBulkSelectionMode() {
    return document.querySelector('.artist-detail-container').classList.contains('bulk-selection-mode');
}

function updateVideoCardSelectionStates() {
    document.querySelectorAll('.video-card').forEach(card => {
        const videoId = parseInt(card.dataset.videoId);
        const checkbox = card.querySelector('.video-select');
        
        if (selectedVideos.has(videoId)) {
            card.classList.add('selected');
            checkbox.checked = true;
        } else {
            card.classList.remove('selected');
            checkbox.checked = false;
        }
    });
}

function updateVideoSelectionButtons() {
    const bulkDownloadBtn = document.getElementById('bulkDownloadBtn');
    const bulkStatusBtn = document.getElementById('bulkStatusBtn');
    const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
    const selectionInfo = document.getElementById('selectionInfo');
    const selectionCount = document.getElementById('selectionCount');
    const hasSelection = selectedVideos.size > 0;
    
    bulkDownloadBtn.disabled = !hasSelection;
    bulkStatusBtn.disabled = !hasSelection;
    bulkDeleteBtn.disabled = !hasSelection;
    
    // Update button text
    bulkDownloadBtn.textContent = `Download Selected (${selectedVideos.size})`;
    bulkStatusBtn.textContent = `Update Status (${selectedVideos.size})`;
    bulkDeleteBtn.innerHTML = `<iconify-icon icon="tabler:trash"></iconify-icon><span>Delete Selected (${selectedVideos.size})</span>`;
    
    // Update selection info display
    if (hasSelection) {
        selectionInfo.style.display = 'flex';
        selectionCount.textContent = selectedVideos.size;
    } else {
        selectionInfo.style.display = 'none';
    }
    
    // Update video card visual states
    updateVideoCardSelectionStates();
}

function selectAllVideos() {
    let selectedCount = 0;
    
    document.querySelectorAll('.video-select').forEach(checkbox => {
        const videoCard = checkbox.closest('.video-card');
        // Only select videos that are currently visible (not filtered out)
        if (videoCard.style.display !== 'none') {
            checkbox.checked = true;
            const videoId = parseInt(videoCard.dataset.videoId);
            selectedVideos.add(videoId);
            videoCard.classList.add('selected');
            selectedCount++;
        }
    });
    
    updateVideoSelectionButtons();
    
    if (selectedCount > 0) {
        showSuccess(`Selected ${selectedCount} videos`);
    }
}

function deselectAllVideos() {
    let deselectedCount = 0;
    
    document.querySelectorAll('.video-select').forEach(checkbox => {
        const videoCard = checkbox.closest('.video-card');
        // Only deselect videos that are currently visible (not filtered out)
        if (videoCard.style.display !== 'none') {
            checkbox.checked = false;
            const videoId = parseInt(videoCard.dataset.videoId);
            selectedVideos.delete(videoId);
            videoCard.classList.remove('selected');
            deselectedCount++;
        }
    });
    
    updateVideoSelectionButtons();
    
    if (deselectedCount > 0) {
        showInfo(`Deselected ${deselectedCount} videos`);
    }
}

// Video management functions
function downloadVideo(videoId) {
    // Removed download confirmation popup - direct download
    
    const downloadBtn = event.target;
    downloadBtn.disabled = true;
    downloadBtn.textContent = 'Downloading...';
    
    fetch(`/api/videos/${videoId}/download`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            // Refresh the videos tab to show updated status
            loadArtistDetails();
        } else {
            showError('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error downloading video:', error);
        showError('Error downloading video');
    })
    .finally(() => {
        downloadBtn.disabled = false;
        downloadBtn.textContent = 'Download';
    });
}

function viewVideoDetails(videoId) {
    // Navigate to video detail page
    window.location.href = `/video/${videoId}`;
}

function updateVideoStatus(videoId) {
    currentStatusOperation = 'single';
    currentVideoId = videoId;
    
    document.getElementById('statusModalTitle').textContent = 'Update Video Status';
    
    // Clear any existing radio button selections
    document.querySelectorAll('input[name="statusOption"]').forEach(radio => {
        radio.checked = false;
    });
    
    showStatusUpdateModal();
}

// Use existing delete video functionality from videos.html
function deleteVideo(id) {
    // Get video information from the card
    const videoCard = document.querySelector(`[data-video-id="${id}"]`);
    if (!videoCard) {
        console.error('Video card not found for ID:', id);
        return;
    }
    
    const title = (videoCard.querySelector('h4') && videoCard.querySelector('h4').textContent) || 'Unknown Video';
    const artistElement = videoCard.closest('.video-card') && videoCard.closest('.video-card').querySelector('.video-metadata');
    const artist = artistElement ? 'Unknown Artist' : 'Unknown Artist'; // Artist info not readily available in this template
    
    // Fetch video details to get YouTube URL
    fetch(`/api/videos/${id}`)
        .then(response => response.json())
        .then(video => {
            if (video.error) {
                console.error('Error fetching video details:', video.error);
                showDeleteVideoModal(id, title, artist, '');
                return;
            }
            
            // Try multiple URL fields to find YouTube URL
            const url = video.video_url || video.url || video.youtube_url || '';
            showDeleteVideoModal(id, title, artist, url);
        })
        .catch(error => {
            console.error('Error fetching video details:', error);
            // Fallback to show modal without URL
            showDeleteVideoModal(id, title, artist, '');
        });
}

function showDeleteVideoModal(videoId, title, artist, url) {
    const modal = document.getElementById('deleteVideoModal');
    if (!modal) {
        console.error('Delete video modal not found');
        return;
    }
    
    // Store video ID for use in confirm function
    modal.dataset.videoId = videoId;
    
    // Populate modal with video information
    const titleElement = document.getElementById('deleteVideoTitle');
    const artistElement = document.getElementById('deleteVideoArtist');
    const urlElement = document.getElementById('deleteVideoUrl');
    
    if (titleElement) titleElement.textContent = title;
    if (artistElement) artistElement.textContent = artist;
    if (urlElement) urlElement.textContent = url || 'No URL available';
    
    // Show/hide blacklist option based on whether URL exists
    const blacklistGroup = document.getElementById('deleteBlacklistGroup');
    const blacklistCheckbox = document.getElementById('deleteAddToBlacklist');
    
    if (blacklistGroup && blacklistCheckbox) {
        if (url) {
            blacklistGroup.style.display = 'block';
            blacklistCheckbox.checked = true; // Default to checked when URL exists
            
            // Add note if it's not a YouTube URL
            const checkboxText = blacklistGroup.querySelector('.checkbox-text span');
            if (!url.includes('youtube.com') && !url.includes('youtu.be')) {
                blacklistGroup.style.opacity = '0.8';
                if (checkboxText) {
                    checkboxText.textContent = 'Add to blacklist (Non-YouTube URL)';
                }
            } else {
                blacklistGroup.style.opacity = '1';
                if (checkboxText) {
                    checkboxText.textContent = 'Add to blacklist';
                }
            }
        } else {
            blacklistGroup.style.display = 'none';
        }
    }
    
    modal.style.display = 'block';
}

function closeDeleteVideoModal() {
    const modal = document.getElementById('deleteVideoModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

function confirmDeleteVideo() {
    const modal = document.getElementById('deleteVideoModal');
    if (!modal) {
        console.error('Delete video modal not found');
        return;
    }
    
    const videoId = modal.dataset.videoId;
    if (!videoId) {
        safeShowError('No video ID found');
        return;
    }
    
    const blacklistCheckbox = document.getElementById('deleteAddToBlacklist');
    const addToBlacklist = blacklistCheckbox ? blacklistCheckbox.checked : false;
    
    const requestBody = {};
    if (addToBlacklist) {
        requestBody.add_to_blacklist = true;
    }
    
    fetch(`/api/videos/${videoId}`, {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
    })
    .then(response => {
        if (!response.ok) {
            return response.text().then(text => {
                throw new Error(`HTTP ${response.status}: ${text}`);
            });
        }
        return response.json();
    })
    .then(result => {
        
        // Check for success - API returns message field, not success field
        if (result.message && result.message.includes('deleted successfully')) {
            closeDeleteVideoModal();
            
            if (result.blacklisted) {
                safeShowSuccess(`Video deleted successfully and added to blacklist!`);
            } else {
                safeShowSuccess(`Video deleted successfully!`);
            }
            
            // Refresh the videos display
            if (typeof loadArtistVideos === 'function') {
                // Mark videos as not loaded to force refresh
                window.videosLoaded = false;
                loadArtistVideos();
            } else if (currentArtistData) {
                // Reload artist details to get updated video list
                loadArtistDetails();
            }
        } else {
            console.log('Delete failed with result:', result);
            throw new Error(result.error || result.message || 'Delete failed');
        }
    })
    .catch(error => {
        console.error('Error deleting video:', error);
        safeShowError(`Failed to delete video: ${error.message}`);
    });
}

// Notification helper functions (fallback if not available globally)
function safeShowInfo(message) {
    if (typeof showInfo === 'function') {
        showInfo(message);
    } else {
        console.log('INFO:', message);
        // Simple visual feedback
        const toast = document.createElement('div');
        toast.textContent = message;
        toast.style.cssText = 'position:fixed;top:20px;right:20px;background:#2196F3;color:white;padding:12px 20px;border-radius:6px;z-index:10000;';
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
    }
}

function safeShowSuccess(message) {
    if (typeof showSuccess === 'function') {
        showSuccess(message);
    } else {
        console.log('SUCCESS:', message);
        // Simple visual feedback
        const toast = document.createElement('div');
        toast.textContent = message;
        toast.style.cssText = 'position:fixed;top:20px;right:20px;background:#4CAF50;color:white;padding:12px 20px;border-radius:6px;z-index:10000;';
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
    }
}

function safeShowError(message) {
    if (typeof showError === 'function') {
        showError(message);
    } else {
        console.error('ERROR:', message);
        // Simple visual feedback
        const toast = document.createElement('div');
        toast.textContent = message;
        toast.style.cssText = 'position:fixed;top:20px;right:20px;background:#f44336;color:white;padding:12px 20px;border-radius:6px;z-index:10000;';
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
    }
}

async function refreshVideoMetadata(videoId) {
    try {
        // Find the refresh button and show loading state
        const refreshBtn = document.querySelector(`button[onclick*="refreshVideoMetadata(${videoId})"]`);
        if (refreshBtn) {
            refreshBtn.disabled = true;
            const icon = refreshBtn.querySelector('iconify-icon');
            icon.setAttribute('icon', 'tabler:loader-2');
        }
        
        safeShowInfo('Refreshing metadata...');
        
        // Call the FFmpeg metadata extraction endpoint
        const response = await fetch(`/api/videos/${videoId}/extract-ffmpeg-metadata`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });
        
        const result = await response.json();
        
        if (result.success) {
            safeShowSuccess(`Metadata refreshed successfully! ${result.metadata_extracted ? 'Technical metadata extracted.' : ''}`);
            
            // Refresh the videos display to show updated metadata
            if (typeof loadArtistVideos === 'function') {
                // Mark videos as not loaded to force refresh
                window.videosLoaded = false;
                loadArtistVideos();
            } else if (currentArtistData) {
                // Reload artist details to get updated video list
                loadArtistDetails();
            }
        } else {
            throw new Error(result.error || 'Metadata refresh failed');
        }
    } catch (error) {
        console.error('Error refreshing metadata:', error);
        safeShowError(`Failed to refresh metadata: ${error.message}`);
    } finally {
        // Reset button state
        const refreshBtn = document.querySelector(`button[onclick*="refreshVideoMetadata(${videoId})"]`);
        if (refreshBtn) {
            refreshBtn.disabled = false;
            const icon = refreshBtn.querySelector('iconify-icon');
            icon.setAttribute('icon', 'tabler:refresh');
        }
    }
}

function bulkDownloadSelected() {
    if (selectedVideos.size === 0) {
        showWarning('Please select videos to download');
        return;
    }
    
    // Show confirmation with progress
    showInfo(`Starting download of ${selectedVideos.size} videos...`);
    
    // Removed bulk download confirmation popup - direct download
    
    const bulkBtn = document.getElementById('bulkDownloadBtn');
    bulkBtn.disabled = true;
    bulkBtn.textContent = 'Downloading...';
    
    fetch('/api/videos/bulk/download', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ video_ids: Array.from(selectedVideos) })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            // Clear selection and refresh
            deselectAllVideos();
            loadArtistDetails();
        } else {
            showError('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error bulk downloading videos:', error);
        showError('Error bulk downloading videos');
    })
    .finally(() => {
        bulkBtn.disabled = false;
        bulkBtn.textContent = `Download Selected (${selectedVideos.size})`;
    });
}

function bulkDeleteSelected() {
    if (selectedVideos.size === 0) {
        showWarning('Please select videos to delete');
        return;
    }
    
    const videoIds = Array.from(selectedVideos);
    const confirmed = confirm(`Are you sure you want to delete ${videoIds.length} selected video(s)?\n\nThis action cannot be undone.`);
    
    if (!confirmed) {
        return;
    }
    
    const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
    bulkDeleteBtn.disabled = true;
    bulkDeleteBtn.textContent = 'ðŸ”„ Deleting...';
    
    fetch('/api/videos/bulk/delete', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.deleted_count > 0) {
            showSuccess(`Successfully deleted ${data.deleted_count} video(s)`);
            if (data.failed_count > 0) {
                showWarning(`Failed to delete ${data.failed_count} video(s)`);
            }
            
            // Clear selection and refresh the artist details
            selectedVideos.clear();
            updateVideoSelectionButtons();
            loadArtistDetails();
        } else {
            showError('Failed to delete videos: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        console.error('Error deleting videos:', error);
        showError('Failed to delete videos: ' + error.message);
    })
    .finally(() => {
        bulkDeleteBtn.disabled = false;
        bulkDeleteBtn.innerHTML = `<iconify-icon icon="tabler:trash"></iconify-icon><span>Delete Selected (${selectedVideos.size})</span>`;
    });
}

function bulkUpdateStatus() {
    if (selectedVideos.size === 0) {
        showWarning('Please select videos to update status');
        return;
    }
    
    currentStatusOperation = 'bulk';
    currentVideoId = null;
    
    document.getElementById('statusModalTitle').textContent = `Update Status for ${selectedVideos.size} Videos`;
    
    // Clear any existing radio button selections
    document.querySelectorAll('input[name="statusOption"]').forEach(radio => {
        radio.checked = false;
    });
    
    showStatusUpdateModal();
}

function importSingleVideo(videoId, source = 'imvdb', buttonElement = null) {
    if (!videoId) {
        showError('Invalid video ID');
        return;
    }
    
    if (!currentArtistId) {
        showError('Artist ID not available');
        return;
    }
    
    // Get video data from button element if available
    let videoData = null;
    if (buttonElement && buttonElement.dataset && buttonElement.dataset.videoData) {
        try {
            videoData = JSON.parse(buttonElement.dataset.videoData);
        } catch (e) {
            console.error('Failed to parse video data:', e);
        }
    }
    
    // Auto-detect source based on videoId format if source is incorrect
    if (videoData) {
        if (videoData.youtube_id && videoData.youtube_id === videoId) {
            source = 'youtube';
        } else if (videoData.imvdb_id && videoData.imvdb_id === videoId) {
            source = 'imvdb';
        }
    }
    
    // Additional safeguard: YouTube IDs are typically 11 characters
    if (videoId && videoId.length === 11 && !videoId.match(/^\d+$/)) {
        source = 'youtube';
    }
    
    // Debug logging
    
    // Debug button attributes
    if (buttonElement) {
        console.log('Debug button attributes:', {
            debugSource: buttonElement.dataset.debugSource,
            debugYoutube: buttonElement.dataset.debugYoutube,
            debugImvdb: buttonElement.dataset.debugImvdb
        });
    }
    
    // Show loading state
    const importBtn = buttonElement || event.target;
    const originalText = importBtn.textContent;
    importBtn.disabled = true;
    importBtn.textContent = 'Importing...';
    
    // Choose the appropriate endpoint based on source
    const endpoint = source === 'youtube' ? '/api/videos/import-from-youtube' : '/api/videos/import-from-imvdb';
    const bodyKey = source === 'youtube' ? 'youtube_id' : 'imvdb_id';
    
    // Debug logging
    
    // Prepare request body
    const requestBody = {
        [bodyKey]: videoId,
        artist_id: currentArtistId
    };
    
    // For YouTube videos, include additional metadata if available
    if (source === 'youtube' && videoData) {
        requestBody.title = videoData.title || `YouTube Video ${videoId}`;
        requestBody.description = videoData.description || '';
        requestBody.thumbnail_url = videoData.thumbnail_url || '';
        requestBody.duration = videoData.duration;
        requestBody.view_count = videoData.view_count;
        requestBody.like_count = videoData.like_count;
        requestBody.published_at = videoData.published_at;
        requestBody.channel_title = videoData.channel_title || '';
    }
    
    
    fetch(endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(`"${data.video.title}" imported successfully`, {
                title: 'Video Import Success'
            });
            
            // Hide the import button and show imported status
            importBtn.style.display = 'none';
            const importedBadge = document.createElement('span');
            importedBadge.className = 'imported-badge';
            importedBadge.textContent = 'Imported';
            importBtn.parentNode.appendChild(importedBadge);
            
            // Refresh the videos tab to show the new video
            loadArtistDetails();
        } else {
            if (data.error === 'Video already exists') {
                showWarning(`Video Already Exists: "${data.title}" is already in your library.`);
                
                // Hide the import button and show exists status
                importBtn.style.display = 'none';
                const existsBadge = document.createElement('span');
                existsBadge.className = 'exists-badge';
                existsBadge.textContent = 'Already Exists';
                importBtn.parentNode.appendChild(existsBadge);
            } else {
                showError('Import failed: ' + data.error);
            }
        }
    })
    .catch(error => {
        console.error('Error importing video:', error);
        showError('Error importing video: ' + error.message);
    })
    .finally(() => {
        importBtn.disabled = false;
        importBtn.textContent = originalText;
    });
}

function filterVideos() {
    const statusFilter = document.getElementById('videoStatusFilter').value;
    const yearFilter = document.getElementById('videoYearFilter').value;
    const qualityFilter = document.getElementById('videoQualityFilter').value;
    const durationFilter = document.getElementById('videoDurationFilter').value;
    const directorFilter = document.getElementById('videoDirectorFilter').value.toLowerCase();
    const producerFilter = document.getElementById('videoProducerFilter').value.toLowerCase();
    const albumFilter = document.getElementById('videoAlbumFilter').value.toLowerCase();
    const dateFromFilter = document.getElementById('videoDateFromFilter').value;
    const dateToFilter = document.getElementById('videoDateToFilter').value;
    
    const videoCards = document.querySelectorAll('.video-card');
    
    videoCards.forEach(card => {
        let shouldShow = true;
        
        // Status filter
        if (statusFilter) {
            const videoStatus = card.dataset.status;
            if (videoStatus !== statusFilter) shouldShow = false;
        }
        
        // Year filter
        if (yearFilter && shouldShow) {
            const yearElement = card.querySelector('.video-year');
            if (yearElement) {
                const videoYear = parseInt(yearElement.textContent);
                if (yearFilter === 'older') {
                    if (videoYear >= 2020) shouldShow = false;
                } else {
                    if (videoYear !== parseInt(yearFilter)) shouldShow = false;
                }
            } else if (yearFilter !== '') {
                shouldShow = false;
            }
        }
        
        // Quality filter
        if (qualityFilter && shouldShow) {
            const qualityElement = card.querySelector('.video-quality');
            if (qualityElement) {
                if (!qualityElement.textContent.includes(qualityFilter)) shouldShow = false;
            } else if (qualityFilter !== '') {
                shouldShow = false;
            }
        }
        
        // Duration filter
        if (durationFilter && shouldShow) {
            const durationElement = card.querySelector('.video-duration');
            if (durationElement) {
                const durationText = durationElement.textContent;
                const duration = parseDuration(durationText);
                if (durationFilter === 'short' && duration >= 180) shouldShow = false;
                if (durationFilter === 'medium' && (duration < 180 || duration >= 360)) shouldShow = false;
                if (durationFilter === 'long' && duration < 360) shouldShow = false;
            } else if (durationFilter !== '') {
                shouldShow = false;
            }
        }
        
        // Director filter
        if (directorFilter && shouldShow) {
            const directorsElement = card.querySelector('.video-directors');
            if (directorsElement) {
                if (!directorsElement.textContent.toLowerCase().includes(directorFilter)) shouldShow = false;
            } else if (directorFilter !== '') {
                shouldShow = false;
            }
        }
        
        // Producer filter
        if (producerFilter && shouldShow) {
            const producersElement = card.querySelector('.video-producers');
            if (producersElement) {
                if (!producersElement.textContent.toLowerCase().includes(producerFilter)) shouldShow = false;
            } else if (producerFilter !== '') {
                shouldShow = false;
            }
        }
        
        // Album filter
        if (albumFilter && shouldShow) {
            const albumElement = card.querySelector('.video-album');
            if (albumElement) {
                if (!albumElement.textContent.toLowerCase().includes(albumFilter)) shouldShow = false;
            } else if (albumFilter !== '') {
                shouldShow = false;
            }
        }
        
        // Date range filters
        if ((dateFromFilter || dateToFilter) && shouldShow) {
            const dateElement = card.querySelector('.video-created-date');
            if (dateElement) {
                const videoDate = new Date(dateElement.dataset.date);
                if (dateFromFilter && videoDate < new Date(dateFromFilter)) shouldShow = false;
                if (dateToFilter && videoDate > new Date(dateToFilter)) shouldShow = false;
            }
        }
        
        card.style.display = shouldShow ? 'block' : 'none';
    });
}

function sortVideos() {
    const sortBy = document.getElementById('videoSortBy').value;
    const videosGrid = document.getElementById('videosGrid');
    const videoCards = Array.from(videosGrid.querySelectorAll('.video-card'));
    
    videoCards.sort((a, b) => {
        const aTitle = a.querySelector('.video-info h4').textContent;
        const bTitle = b.querySelector('.video-info h4').textContent;
        
        switch (sortBy) {
            case 'title':
                return aTitle.localeCompare(bTitle);
            case 'year':
                const aYear = (a.querySelector('.video-year') && a.querySelector('.video-year').textContent) || '0';
                const bYear = (b.querySelector('.video-year') && b.querySelector('.video-year').textContent) || '0';
                return parseInt(bYear) - parseInt(aYear);
            case 'status':
                return a.dataset.status.localeCompare(b.dataset.status);
            default:
                return 0;
        }
    });
    
    // Re-append sorted cards
    videoCards.forEach(card => videosGrid.appendChild(card));
}

function searchVideos() {
    const searchTerm = document.getElementById('videoSearchInput').value.toLowerCase();
    const videoCards = document.querySelectorAll('.video-card');
    
    videoCards.forEach(card => {
        const title = card.querySelector('.video-info h4').textContent.toLowerCase();
        const shouldShow = title.includes(searchTerm);
        card.style.display = shouldShow ? 'block' : 'none';
    });
}

function filterDownloads() {
    const statusFilter = document.getElementById('downloadStatusFilter').value;
    const downloadItems = document.querySelectorAll('.download-item');
    
    downloadItems.forEach(item => {
        const status = item.querySelector('.download-status').textContent.toLowerCase();
        const shouldShow = !statusFilter || status.includes(statusFilter);
        item.style.display = shouldShow ? 'block' : 'none';
    });
}

function refreshDownloads() {
    loadArtistDetails();
}

function populateSettings(artist) {
    // Get enriched metadata
    const metadata = artist.imvdb_metadata || {};
    
    // Basic Info
    document.getElementById('artistNameSetting').value = artist.name || '';
    document.getElementById('sortNameSetting').value = artist.sort_name || '';
    document.getElementById('folderPathSetting').value = artist.folder_path || '';
    document.getElementById('keywordsSetting').value = (artist.keywords || []).join(', ');
    document.getElementById('overviewSetting').value = artist.overview || artist.biography || metadata.biography || '';
    
    // Extended Info - check both direct artist fields and enriched metadata
    document.getElementById('formedYearSetting').value = artist.formed_year || metadata.formed_year || '';
    document.getElementById('disbandedYearSetting').value = artist.disbanded_year || metadata.disbanded_year || '';
    document.getElementById('originCountrySetting').value = artist.origin_country || metadata.origin_country || '';
    
    // Genres - handle both string and array formats
    let genresValue = '';
    if (artist.genres) {
        genresValue = Array.isArray(artist.genres) ? artist.genres.join(', ') : artist.genres;
    } else if (metadata.genres) {
        genresValue = Array.isArray(metadata.genres) ? metadata.genres.join(', ') : metadata.genres;
    }
    document.getElementById('genresSetting').value = genresValue;
    
    // Labels - handle both string and array formats  
    let labelsValue = '';
    if (artist.labels) {
        labelsValue = Array.isArray(artist.labels) ? artist.labels.join(', ') : artist.labels;
    } else if (metadata.labels) {
        labelsValue = Array.isArray(metadata.labels) ? metadata.labels.join(', ') : metadata.labels;
    }
    document.getElementById('labelsSetting').value = labelsValue;
    
    document.getElementById('membersSetting').value = artist.members || metadata.members || '';
    
    // External Links - check both direct artist fields and enriched metadata
    document.getElementById('websiteUrlSetting').value = artist.website_url || metadata.website_url || '';
    document.getElementById('spotifyUrlSetting').value = artist.spotify_url || metadata.spotify_url || '';
    document.getElementById('youtubeUrlSetting').value = artist.youtube_url || metadata.youtube_url || '';
    document.getElementById('appleMusicUrlSetting').value = artist.apple_music_url || metadata.apple_music_url || '';
    document.getElementById('twitterUrlSetting').value = artist.twitter_url || metadata.twitter_url || '';
    document.getElementById('facebookUrlSetting').value = artist.facebook_url || metadata.facebook_url || '';
    document.getElementById('instagramUrlSetting').value = artist.instagram_url || metadata.instagram_url || '';
    document.getElementById('imvdbIdSetting').value = artist.imvdb_id || '';
    
    // Settings
    document.getElementById('monitoredSetting').checked = artist.monitored || false;
    document.getElementById('autoDownloadSetting').checked = artist.auto_download || false;
    document.getElementById('qualityProfileSetting').value = artist.quality_profile || 'any';
    document.getElementById('prioritySetting').value = artist.priority || 'normal';
    
    // Initialize thumbnail preview
    updateThumbnailPreview(artist.thumbnail_url);
}

function saveArtistSettings() {
    const formData = new FormData(document.getElementById('artistSettingsForm'));
    
    const settings = {
        // Basic Info
        name: formData.get('name'),
        sort_name: formData.get('sort_name'),
        folder_path: formData.get('folder_path'),
        keywords: formData.get('keywords'),
        overview: formData.get('overview'),
        
        // Extended Info  
        formed_year: formData.get('formed_year') || null,
        disbanded_year: formData.get('disbanded_year') || null,
        origin_country: formData.get('origin_country'),
        genres: formData.get('genres'),
        labels: formData.get('labels'), 
        members: formData.get('members'),
        
        // External Links
        website_url: formData.get('website_url'),
        spotify_url: formData.get('spotify_url'),
        youtube_url: formData.get('youtube_url'),
        apple_music_url: formData.get('apple_music_url'),
        twitter_url: formData.get('twitter_url'),
        facebook_url: formData.get('facebook_url'),
        instagram_url: formData.get('instagram_url'),
        imvdb_id: formData.get('imvdb_id') || null,
        
        // Settings
        monitored: formData.get('monitored') === 'on',
        auto_download: formData.get('auto_download') === 'on',
        quality_profile: formData.get('quality_profile'),
        priority: formData.get('priority')
    };
    
    fetch(`/api/artists/${currentArtistId}/settings`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(settings)
    })
    .then(response => {
        if (response.ok) {
            return response.json();
        } else if (response.status === 409) {
            // Conflict - handle duplicate IMVDb ID
            return response.json().then(conflictData => {
                showMergeDialog(conflictData);
                throw new Error('Conflict handled'); // Prevent normal error handling
            });
        } else {
            return response.json();
        }
    })
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            // Update the current artist data
            currentArtistData = { ...currentArtistData, ...data.artist };
            // Refresh the header to show updated information
            renderArtistHeader(currentArtistData);
        } else {
            showError('Error: ' + data.error);
        }
    })
    .catch(error => {
        if (error.message !== 'Conflict handled') {
            console.error('Error saving artist settings:', error);
            showError('Error saving artist settings');
        }
    });
}

function resetSettings() {
    if (currentArtistData) {
        populateSettings(currentArtistData);
    }
}

// IMVDb ID management functions
function clearImvdbId() {
    document.getElementById('imvdbIdSetting').value = '';
    showInfo('IMVDb ID cleared. Save settings to apply changes.');
}

function searchImvdbId() {
    const artistName = (currentArtistData && currentArtistData.name) || document.getElementById('nameSetting').value;
    
    if (!artistName) {
        showError('Artist name is required to search for IMVDb ID');
        return;
    }
    
    showInfo('Searching for IMVDb ID...');
    
    fetch('/api/artists/search/imvdb', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ query: artistName })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.artists && data.artists.length > 0) {
            showImvdbSearchResults(data.artists);
        } else {
            showError('No IMVDb artists found for "' + artistName + '"');
        }
    })
    .catch(error => {
        console.error('Error searching IMVDb:', error);
        showError('Error searching for IMVDb ID');
    });
}

function showImvdbSearchResults(artists) {
    // Create modal with search results
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <h3>Select Correct IMVDb Artist</h3>
                <button type="button" class="modal-close" onclick="closeModal(this)">&times;</button>
            </div>
            <div class="modal-body">
                <div class="imvdb-search-results">
                    ${artists.map((artist, index) => `
                        <div class="imvdb-result-item" onclick="selectImvdbId('${artist.id}', '${artist.name || 'Unknown Artist'}')">
                            <div class="result-info">
                                <strong>${artist.name || 'Unknown Artist'}</strong>
                                <span class="result-id">ID: ${artist.id}</span>
                            </div>
                            ${artist.description ? `<div class="result-description">${artist.description}</div>` : ''}
                            <div class="result-meta">
                                <span class="result-number">#${index + 1}</span>
                                ${artist.url ? `<a href="${artist.url}" target="_blank" rel="noopener" class="result-link" onclick="event.stopPropagation()">View on IMVDb</a>` : ''}
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="closeModal(this)">Cancel</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

function selectImvdbId(imvdbId, artistName) {
    document.getElementById('imvdbIdSetting').value = imvdbId;
    showSuccess(`Selected IMVDb ID ${imvdbId} for "${artistName}". Save settings to apply changes.`);
    
    // Close the modal
    const modal = document.querySelector('.modal.active');
    if (modal) {
        modal.remove();
    }
}

function closeModal(button) {
    const modal = button.closest('.modal');
    if (modal) {
        modal.remove();
    }
}

// Enhanced metadata editing functions
// switchMetadataTab function removed - no longer needed for single-page design

function importFromImvdb() {
    if (!currentArtistId || !(currentArtistData && currentArtistData.imvdb_id)) {
        showError('No IMVDb ID found for this artist');
        return;
    }
    
    if (!confirm('Import metadata from IMVDb? This will overwrite existing data.')) {
        return;
    }
    
    const btn = event.target;
    const originalText = btn.textContent;
    btn.disabled = true;
    btn.textContent = 'ðŸ“¥ Importing...';
    
    fetch(`/api/artists/${currentArtistId}/import-metadata`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess('Metadata imported successfully from IMVDb');
            currentArtistData = { ...currentArtistData, ...data.artist };
            populateSettings(currentArtistData);
        } else {
            showError('Failed to import metadata: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Import error:', error);
        showError('Failed to import metadata from IMVDb');
    })
    .finally(() => {
        btn.disabled = false;
        btn.textContent = originalText;
    });
}

function enrichMetadataAllSources(event) {
    if (!currentArtistId) {
        showError('No artist selected');
        return;
    }
    
    if (!confirm('Enrich metadata from all available sources (IMVDb, AllMusic, MusicBrainz, Last.fm, Spotify)? This will complement existing data with information from multiple providers.')) {
        return;
    }
    
    const btn = event.target;
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    
    // Show enhanced progress modal
    showEnrichmentProgressModal();
    
    const sources = ['IMVDb', 'AllMusic', 'MusicBrainz', 'Last.fm', 'Spotify'];
    let currentStep = 0;
    
    // Update progress with each source
    const progressInterval = setInterval(() => {
        if (currentStep < sources.length) {
            updateEnrichmentProgress(currentStep + 1, sources.length, `Processing ${sources[currentStep]}...`);
            currentStep++;
        }
    }, 1000);
    
    fetch(`/api/metadata-enrichment/enrich/${currentArtistId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ force_refresh: true })
    })
    .then(response => response.json())
    .then(data => {
        clearInterval(progressInterval);
        hideEnrichmentProgressModal();
        
        
        if (data.success) {
            const sourcesUsed = data.sources_used || [];
            // Handle enriched_fields as either array or object
            const enrichedFields = Array.isArray(data.enriched_fields) 
                ? data.enriched_fields 
                : (data.enriched_fields ? Object.keys(data.enriched_fields) : []);
            const enrichmentSummary = data.enrichment_summary || {};
            
            // Show simple success toast message
            const sourcesText = sourcesUsed && sourcesUsed.length > 0 ? sourcesUsed.join(', ') : 'multiple sources';
            const fieldsText = enrichedFields && enrichedFields.length > 0 ? `${enrichedFields.length} fields updated` : 'metadata updated';
            
            console.log('ðŸ” SHOWING SUCCESS TOAST for enrichment');
            if (typeof showSuccess === 'function') {
                showSuccess(`Metadata enriched from ${sourcesText}. ${fieldsText}.`);
            } else {
                alert(`Metadata enriched from ${sourcesText}. ${fieldsText}.`);
            }
            
            // Reload artist data to show updated metadata with animation
            console.log('ðŸ” METADATA FOUND CHECK:', {
                has_metadata_found: !!data.metadata_found,
                metadata_found_content: data.metadata_found
            });
            if (data.metadata_found) {
                console.log('ðŸ” UPDATING ARTIST DATA AND RELOADING...');
                currentArtistData = { ...currentArtistData, ...data.metadata_found };
                
                // Also search for thumbnail if artist doesn't have one
                if (!currentArtistData.thumbnail_url) {
                    console.log('ðŸ” Artist has no thumbnail, searching for one...');
                    searchArtistThumbnail().then(() => {
                        console.log('ðŸ” Thumbnail search completed, refreshing view...');
                        animateMetadataUpdate();
                        loadArtistDetails(); // Refresh the entire view
                    }).catch(error => {
                        console.log('ðŸ” Thumbnail search failed, continuing with metadata update...');
                        animateMetadataUpdate();
                        loadArtistDetails(); // Refresh the entire view
                    });
                } else {
                    animateMetadataUpdate();
                    loadArtistDetails(); // Refresh the entire view
                }
            } else {
                console.log('âŒ NO metadata_found, not reloading view');
            }
        } else {
            const errorMessage = data.error || 'Failed to enrich metadata';
            showEnrichmentError(errorMessage, data.failed_sources || []);
        }
    })
    .catch(error => {
        clearInterval(progressInterval);
        hideEnrichmentProgressModal();
        console.error('Enrichment error:', error);
        
        // Provide user-friendly error messages
        let userMessage = 'Failed to enrich metadata from external sources';
        let suggestions = [];
        
        if (error.message && error.message.includes('404')) {
            userMessage = 'Artist not found in external metadata sources';
            suggestions.push('Try checking the artist name spelling');
            suggestions.push('Verify the artist exists in external databases');
        } else if (error.message && error.message.includes('network')) {
            userMessage = 'Network error while fetching metadata';
            suggestions.push('Check your internet connection');
            suggestions.push('Try again in a few moments');
        }
        
        showEnrichmentError(userMessage, [], suggestions);
    })
    .finally(() => {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    });
}

// Enhanced enrichment UI functions
function showEnrichmentProgressModal() {
    const modal = document.createElement('div');
    modal.id = 'enrichmentProgressModal';
    modal.className = 'modal-overlay';
    modal.innerHTML = `
        <div class="enrichment-progress-modal">
            <div class="modal-header">
                <h3><iconify-icon icon="tabler:sparkles"></iconify-icon> Enriching Metadata</h3>
            </div>
            <div class="modal-body">
                <div class="enrichment-progress-container">
                    <div class="progress-bar-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="enrichmentProgressFill"></div>
                        </div>
                        <div class="progress-text" id="enrichmentProgressText">Initializing...</div>
                    </div>
                    <div class="sources-progress" id="sourcesProgress">
                        <div class="source-item" data-source="IMVDb"><iconify-icon icon="tabler:database"></iconify-icon> IMVDb</div>
                        <div class="source-item" data-source="AllMusic"><iconify-icon icon="tabler:music"></iconify-icon> AllMusic</div>
                        <div class="source-item" data-source="MusicBrainz"><iconify-icon icon="tabler:vinyl"></iconify-icon> MusicBrainz</div>
                        <div class="source-item" data-source="Last.fm"><iconify-icon icon="tabler:brand-lastfm"></iconify-icon> Last.fm</div>
                        <div class="source-item" data-source="Spotify"><iconify-icon icon="tabler:brand-spotify"></iconify-icon> Spotify</div>
                    </div>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

function updateEnrichmentProgress(current, total, message) {
    const progressFill = document.getElementById('enrichmentProgressFill');
    const progressText = document.getElementById('enrichmentProgressText');
    const percentage = (current / total) * 100;
    
    if (progressFill) progressFill.style.width = percentage + '%';
    if (progressText) progressText.textContent = message;
    
    // Update source indicators
    const sources = ['IMVDb', 'AllMusic', 'MusicBrainz', 'Last.fm', 'Spotify'];
    if (current <= sources.length) {
        const sourceElement = document.querySelector(`[data-source="${sources[current - 1]}"]`);
        if (sourceElement) {
            sourceElement.classList.add('processing');
        }
    }
}

function hideEnrichmentProgressModal() {
    const modal = document.getElementById('enrichmentProgressModal');
    if (modal) {
        modal.remove();
    }
}

function getSourceIcon(source) {
    const icons = {
        'lastfm': 'brand-lastfm',
        'spotify': 'brand-spotify', 
        'imvdb': 'database',
        'musicbrainz': 'vinyl',
        'allmusic': 'music',
        'wikipedia': 'book'
    };
    return icons[source.toLowerCase()] || 'info';
}

function showEnrichmentResults(sourcesUsed, enrichedFields, enrichmentSummary) {
    
    try {
        // Ensure arrays are properly initialized
        const safeSourcesUsed = Array.isArray(sourcesUsed) ? sourcesUsed : [];
        const safeEnrichedFields = Array.isArray(enrichedFields) ? enrichedFields : [];
        
        console.log('ðŸ” CREATING ENRICHMENT MODAL with safe arrays:', {
            safeSourcesUsed_length: safeSourcesUsed.length,
            safeEnrichedFields_length: safeEnrichedFields.length
        });
        
        const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
        <div class="enrichment-results-modal">
            <div class="modal-header">
                <h3><iconify-icon icon="tabler:check-circle"></iconify-icon> Enrichment Complete</h3>
                <button type="button" class="close-btn" onclick="this.closest('.modal-overlay').remove()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="enrichment-summary">
                    <div class="summary-stats">
                        <div class="stat-item">
                            <span class="stat-value">${safeSourcesUsed.length}</span>
                            <span class="stat-label">Sources Used</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">${safeEnrichedFields.length}</span>
                            <span class="stat-label">Fields Updated</span>
                        </div>
                    </div>
                    <div class="sources-used">
                        <h4>Sources Successfully Processed:</h4>
                        <div class="source-badges">
                            ${safeSourcesUsed.map(source => `
                                <span class="source-badge success">
                                    <iconify-icon icon="tabler:${getSourceIcon(source)}"></iconify-icon>
                                    ${source}
                                </span>
                            `).join('')}
                        </div>
                    </div>
                    ${safeEnrichedFields.length > 0 ? `
                        <div class="enriched-fields">
                            <h4>Updated Fields:</h4>
                            <div class="field-badges">
                                ${safeEnrichedFields.map(field => `<span class="field-badge">${field}</span>`).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            </div>
        </div>
    `;
    
        console.log('ðŸ” APPENDING MODAL TO BODY');
        document.body.appendChild(modal);
        console.log('ðŸ” MODAL APPENDED, setting auto-close timeout');
        
        // Auto-close after 5 seconds
        setTimeout(() => {
            if (modal.parentNode) {
                modal.remove();
                console.log('ðŸ” MODAL AUTO-CLOSED');
            }
        }, 5000);
        
        console.log('âœ… SUCCESS MODAL DISPLAYED');
    } catch (error) {
        console.error('âŒ ERROR CREATING SUCCESS MODAL:', error);
        // Fallback: simple alert using safe arrays
        const safeSourcesUsed = Array.isArray(sourcesUsed) ? sourcesUsed : [];
        const safeEnrichedFields = Array.isArray(enrichedFields) ? enrichedFields : [];
        alert(`Enrichment Complete! Sources: ${safeSourcesUsed.join(', ')}, Fields: ${safeEnrichedFields.length}`);
    }
}

function showEnrichmentError(message, failedSources = [], suggestions = []) {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.innerHTML = `
        <div class="enrichment-error-modal">
            <div class="modal-header">
                <h3><iconify-icon icon="tabler:exclamation-circle"></iconify-icon> Enrichment Failed</h3>
                <button type="button" class="close-btn" onclick="this.closest('.modal-overlay').remove()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="error-message">
                    <p>${message}</p>
                    ${failedSources.length > 0 ? `
                        <div class="failed-sources">
                            <h4>Failed Sources:</h4>
                            <div class="source-badges">
                                ${failedSources.map(source => `
                                    <span class="source-badge error">
                                        <iconify-icon icon="tabler:${getSourceIcon(source)}"></iconify-icon>
                                        ${source}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                    ${suggestions.length > 0 ? `
                        <div class="suggestions">
                            <h4>Suggestions:</h4>
                            <ul>
                                ${suggestions.map(suggestion => `<li>${suggestion}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

function animateMetadataUpdate() {
    // Add a subtle animation to metadata sections to indicate they've been updated
    const metadataSections = document.querySelectorAll('.metadata-section');
    metadataSections.forEach(section => {
        section.style.transition = 'all 0.3s ease';
        section.style.transform = 'scale(1.02)';
        section.style.boxShadow = '0 6px 20px rgba(0, 212, 255, 0.2)';
        
        setTimeout(() => {
            section.style.transform = 'scale(1)';
            section.style.boxShadow = '0 4px 16px rgba(0, 212, 255, 0.1)';
        }, 300);
    });
}

function validateMetadata() {
    const form = document.getElementById('artistSettingsForm');
    const formData = new FormData(form);
    const errors = [];
    const warnings = [];
    
    // Validate required fields
    if (!(formData.get('name') && formData.get('name').trim())) {
        errors.push('Artist name is required');
    }
    
    // Validate URLs
    const urlFields = ['website_url', 'spotify_url', 'youtube_url', 'apple_music_url', 'twitter_url', 'facebook_url', 'instagram_url'];
    urlFields.forEach(field => {
        const value = formData.get(field) && formData.get(field).trim();
        if (value && !isValidUrl(value)) {
            errors.push(`Invalid URL format for ${field.replace('_', ' ')}`);
        }
    });
    
    // Validate years
    const currentYear = new Date().getFullYear();
    const formedYear = parseInt(formData.get('formed_year'));
    const disbandedYear = parseInt(formData.get('disbanded_year'));
    
    if (formedYear && (formedYear < 1800 || formedYear > currentYear)) {
        errors.push('Formed year must be between 1800 and current year');
    }
    
    if (disbandedYear && (disbandedYear < 1800 || disbandedYear > currentYear)) {
        errors.push('Disbanded year must be between 1800 and current year');
    }
    
    if (formedYear && disbandedYear && disbandedYear <= formedYear) {
        errors.push('Disbanded year must be after formed year');
    }
    
    // Check for warnings
    if (!(formData.get('overview') && formData.get('overview').trim())) {
        warnings.push('Biography/overview is empty');
    }
    
    if (!(formData.get('genres') && formData.get('genres').trim())) {
        warnings.push('No genres specified');
    }
    
    // Display results
    if (errors.length > 0) {
        showError('Validation errors: ' + errors.join(', '));
        return false;
    }
    
    if (warnings.length > 0) {
        showWarning('Validation warnings: ' + warnings.join(', '));
    } else {
        showSuccess('All metadata validates successfully');
    }
    
    return true;
}

function isValidUrl(string) {
    try {
        new URL(string);
        return true;
    } catch (_) {
        return false;
    }
}

function handleThumbnailError(img) {
    img.src = '/static/placeholder-artist.png';
}

function hideVideoSelectionModal() {
    document.getElementById('videoSelectionModal').style.display = 'none';
}

function showStatusUpdateModal() {
    document.getElementById('statusUpdateModal').style.display = 'block';
}

function hideStatusUpdateModal() {
    document.getElementById('statusUpdateModal').style.display = 'none';
    currentStatusOperation = null;
    currentVideoId = null;
}

function confirmStatusUpdate() {
    const selectedRadio = document.querySelector('input[name="statusOption"]:checked');
    if (!selectedRadio) {
        showWarning('Please select a status');
        return;
    }
    
    const selectedStatus = selectedRadio.value;
    
    if (currentStatusOperation === 'single' && currentVideoId) {
        // Single video status update
        fetch(`/api/videos/${currentVideoId}/status`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ status: selectedStatus })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showSuccess(data.message);
                loadArtistDetails();
            } else {
                showError('Error: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error updating video status:', error);
            showError('Error updating video status');
        })
        .finally(() => {
            hideStatusUpdateModal();
        });
        
    } else if (currentStatusOperation === 'bulk') {
        // Bulk video status update
        const bulkBtn = document.getElementById('bulkStatusBtn');
        bulkBtn.disabled = true;
        bulkBtn.textContent = 'Updating...';
        
        fetch('/api/videos/bulk/status', {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                video_ids: Array.from(selectedVideos),
                status: selectedStatus 
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showSuccess(data.message);
                deselectAllVideos();
                loadArtistDetails();
            } else {
                showError('Error: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error bulk updating video status:', error);
            showError('Error bulk updating video status');
        })
        .finally(() => {
            bulkBtn.disabled = false;
            bulkBtn.textContent = `Update Status (${selectedVideos.size})`;
            hideStatusUpdateModal();
        });
    }
}

function calculateDownloadStats(downloads) {
    if (!downloads || downloads.length === 0) {
        return { total: 0, active: 0, completed: 0, failed: 0, totalSize: 0 };
    }
    
    const stats = {
        total: downloads.length,
        active: 0,
        completed: 0,
        failed: 0,
        totalSize: 0
    };
    
    downloads.forEach(download => {
        switch (download.status) {
            case 'downloading':
            case 'pending':
                stats.active++;
                break;
            case 'completed':
                stats.completed++;
                break;
            case 'failed':
                stats.failed++;
                break;
        }
        
        if (download.file_size) {
            stats.totalSize += download.file_size;
        }
    });
    
    return stats;
}

function updateDownloadPriority(downloadId, priority) {
    fetch('/api/metube/queue/priority', {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            download_id: downloadId,
            priority: priority
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            loadArtistDetails(); // Refresh to show updated priority
        } else {
            showError('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error updating download priority:', error);
        showError('Error updating download priority');
    });
}

function cancelDownload(downloadId) {
    toastConfirm('Cancel this download?', () => {
        proceedCancelDownload(downloadId);
    });
}

function proceedCancelDownload(downloadId) {
    
    fetch(`/api/metube/cancel/${downloadId}`, {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            loadArtistDetails(); // Refresh downloads
        } else {
            showError('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error cancelling download:', error);
        showError('Error cancelling download');
    });
}

function removeDownload(downloadId) {
    toastConfirm('Remove this download from the list?', () => {
        // This would need an endpoint to remove a download record
        showInfo('Remove download functionality needs additional API endpoint');
    });
}

function retryDownload(downloadId) {
    toastConfirm('Retry this download?', () => {
        // This would trigger a retry of the download
        showInfo('Retry download functionality needs additional API endpoint');
    });
}

function clearCompletedDownloads() {
    toastConfirm('Clear all completed downloads?', () => {
        proceedClearCompleted();
    });
}

function proceedClearCompleted() {
    
    fetch('/api/metube/queue/clear-completed', {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            loadArtistDetails(); // Refresh downloads
        } else {
            showError('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error clearing completed downloads:', error);
        showError('Error clearing completed downloads');
    });
}

function showGlobalQueue() {
    document.getElementById('globalQueueModal').style.display = 'block';
    loadGlobalQueue();
}

function hideGlobalQueueModal() {
    document.getElementById('globalQueueModal').style.display = 'none';
}

function loadGlobalQueue() {
    fetch('/api/metube/queue')
        .then(response => response.json())
        .then(data => {
            if (data.queue) {
                renderGlobalQueue(data.queue);
                renderGlobalQueueStats(data.queue);
            } else {
                document.getElementById('globalQueueList').innerHTML = '<div class="no-results">No downloads in global queue</div>';
            }
        })
        .catch(error => {
            console.error('Error loading global queue:', error);
            document.getElementById('globalQueueList').innerHTML = '<div class="error-message">Error loading global queue</div>';
        });
}

function renderGlobalQueue(queue) {
    if (!queue || queue.length === 0) {
        document.getElementById('globalQueueList').innerHTML = '<div class="no-results">Global queue is empty</div>';
        return;
    }
    
    const queueHtml = queue.map(item => `
        <div class="global-queue-item">
            <div class="queue-item-info">
                <h5>${item.title || item.url}</h5>
                <div class="queue-item-metadata">
                    <span class="queue-status status-${item.status}">${item.status}</span>
                    ${item.progress !== undefined ? `<span class="queue-progress">${item.progress}%</span>` : ''}
                    ${item.size ? `<span class="queue-size">${formatFileSize(item.size)}</span>` : ''}
                </div>
            </div>
            <div class="queue-item-actions">
                ${item.status === 'downloading' ? `<button onclick="cancelDownload('${item.id}')" class="btn btn-small btn-warning">Cancel</button>` : ''}
            </div>
        </div>
    `).join('');
    
    document.getElementById('globalQueueList').innerHTML = queueHtml;
}

function renderGlobalQueueStats(queue) {
    const stats = calculateDownloadStats(queue);
    const statsHtml = `
        <div class="global-queue-stats">
            <span class="queue-stat">Total: ${stats.total}</span>
            <span class="queue-stat">Active: ${stats.active}</span>
            <span class="queue-stat">Completed: ${stats.completed}</span>
            <span class="queue-stat">Failed: ${stats.failed}</span>
        </div>
    `;
    document.getElementById('globalQueueStats').innerHTML = statsHtml;
}

function refreshGlobalQueue() {
    loadGlobalQueue();
}

function clearCompletedGlobal() {
    toastConfirm('Clear all completed downloads from the global queue?', () => {
        proceedClearCompletedGlobal();
    });
}

function proceedClearCompletedGlobal() {
    
    fetch('/api/metube/queue/clear-completed', {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            loadGlobalQueue(); // Refresh global queue
        } else {
            showError('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error clearing completed downloads:', error);
        showError('Error clearing completed downloads');
    });
}

function openFile(filePath) {
    // This would open the file using the system's default application
    showInfo(`Opening file: ${filePath} - File opening functionality needs to be implemented based on the platform.`);
}

// Advanced Video Filtering Functions
function toggleAdvancedVideoFilters() {
    const filtersDiv = document.getElementById('advancedVideoFilters');
    const toggleBtn = document.getElementById('advancedFiltersBtn');
    
    if (filtersDiv.style.display === 'none') {
        filtersDiv.style.display = 'block';
        toggleBtn.classList.add('active');
    } else {
        filtersDiv.style.display = 'none';
        toggleBtn.classList.remove('active');
    }
}

function clearVideoFilters() {
    // Clear all filter inputs
    document.getElementById('videoStatusFilter').value = '';
    document.getElementById('videoYearFilter').value = '';
    document.getElementById('videoQualityFilter').value = '';
    document.getElementById('videoDurationFilter').value = '';
    document.getElementById('videoDirectorFilter').value = '';
    document.getElementById('videoProducerFilter').value = '';
    document.getElementById('videoAlbumFilter').value = '';
    document.getElementById('videoDateFromFilter').value = '';
    document.getElementById('videoDateToFilter').value = '';
    document.getElementById('videoSearchInput').value = '';
    
    // Apply filters to show all videos
    filterVideos();
}

function exportFilteredVideos() {
    const visibleVideos = Array.from(document.querySelectorAll('.video-card')).filter(card => 
        card.style.display !== 'none'
    );
    
    if (visibleVideos.length === 0) {
        showWarning('No videos to export. Please adjust your filters.');
        return;
    }
    
    const exportData = visibleVideos.map(card => {
        const title = card.querySelector('.video-info h4').textContent;
        const status = card.dataset.status;
        const year = (card.querySelector('.video-year') && card.querySelector('.video-year').textContent) || '';
        const directors = (card.querySelector('.video-directors') && card.querySelector('.video-directors').textContent) || '';
        const duration = (card.querySelector('.video-duration') && card.querySelector('.video-duration').textContent) || '';
        
        return {
            title,
            status,
            year,
            directors,
            duration
        };
    });
    
    const csvContent = "data:text/csv;charset=utf-8," + 
        "Title,Status,Year,Directors,Duration\n" +
        exportData.map(video => 
            `"${video.title}","${video.status}","${video.year}","${video.directors}","${video.duration}"`
        ).join("\n");
    
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", `videos_export_${new Date().toISOString().split('T')[0]}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showSuccess(`Exported ${exportData.length} videos to CSV file.`);
}

function parseDuration(durationText) {
    // Parse duration from format "MM:SS" or "H:MM:SS" to seconds
    if (!durationText) return 0;
    
    const parts = durationText.split(':').map(part => parseInt(part) || 0);
    if (parts.length === 2) {
        return parts[0] * 60 + parts[1]; // MM:SS
    } else if (parts.length === 3) {
        return parts[0] * 3600 + parts[1] * 60 + parts[2]; // H:MM:SS
    }
    return 0;
}


function hideVideoPreviewModal() {
    document.getElementById('videoPreviewModal').style.display = 'none';
}

function loadVideoPreview() {
    const videoIds = Array.from(selectedVideos);
    
    // Get selected video data from the current artist data
    const selectedVideoData = currentArtistData.videos.filter(video => 
        videoIds.includes(video.id)
    );
    
    if (selectedVideoData.length === 0) {
        document.getElementById('videoPreviewContainer').innerHTML = '<div class="no-results">No video data available for preview</div>';
        return;
    }
    
    const previewHtml = selectedVideoData.map(video => `
        <div class="video-preview-item">
            <div class="preview-thumbnail">
                <img src="${video.thumbnail_url || '/static/placeholder-video.png'}" alt="${video.title}" onerror="this.src='/static/placeholder-video.png'">
            </div>
            <div class="preview-metadata">
                <h4>${video.title}</h4>
                <div class="metadata-grid">
                    <div class="metadata-item">
                        <span class="metadata-label">Status:</span>
                        <span class="metadata-value status-${video.status ? video.status.toLowerCase() : 'unknown'}">${video.status || 'Unknown'}</span>
                    </div>
                    ${video.year ? `
                        <div class="metadata-item">
                            <span class="metadata-label">Year:</span>
                            <span class="metadata-value">${video.year}</span>
                        </div>
                    ` : ''}
                    ${video.duration ? `
                        <div class="metadata-item">
                            <span class="metadata-label">Duration:</span>
                            <span class="metadata-value">${formatDuration(video.duration)}</span>
                        </div>
                    ` : ''}
                    ${video.directors && video.directors.length > 0 ? `
                        <div class="metadata-item">
                            <span class="metadata-label">Directors:</span>
                            <span class="metadata-value">${video.directors.join(', ')}</span>
                        </div>
                    ` : ''}
                    ${video.producers && video.producers.length > 0 ? `
                        <div class="metadata-item">
                            <span class="metadata-label">Producers:</span>
                            <span class="metadata-value">${video.producers.join(', ')}</span>
                        </div>
                    ` : ''}
                    ${video.quality ? `
                        <div class="metadata-item">
                            <span class="metadata-label">Quality:</span>
                            <span class="metadata-value">${video.quality}</span>
                        </div>
                    ` : ''}
                    ${video.local_path ? `
                        <div class="metadata-item">
                            <span class="metadata-label">File Path:</span>
                            <span class="metadata-value">${video.local_path}</span>
                        </div>
                    ` : ''}
                    ${video.created_at ? `
                        <div class="metadata-item">
                            <span class="metadata-label">Added:</span>
                            <span class="metadata-value">${new Date(video.created_at).toLocaleDateString()}</span>
                        </div>
                    ` : ''}
                    ${video.description ? `
                        <div class="metadata-item full-width">
                            <span class="metadata-label">Description:</span>
                            <span class="metadata-value">${video.description.substring(0, 200)}${video.description.length > 200 ? '...' : ''}</span>
                        </div>
                    ` : ''}
                </div>
            </div>
        </div>
    `).join('');
    
    document.getElementById('videoPreviewContainer').innerHTML = `
        <div class="preview-summary">
            <h3>Previewing ${selectedVideoData.length} Selected Videos</h3>
        </div>
        <div class="video-preview-grid">
            ${previewHtml}
        </div>
    `;
}

function downloadPreviewedVideos() {
    if (selectedVideos.size === 0) {
        showWarning('No videos selected');
        return;
    }
    
    toastConfirm(`Download all ${selectedVideos.size} previewed videos?`, () => {
        bulkDownloadSelected();
        hideVideoPreviewModal();
    });
}

// New Artist Management Functions

function searchThumbnail() {
    if (!currentArtistData || !currentArtistData.name) {
        showError('Artist data not loaded');
        return;
    }
    
    const searchBtn = document.querySelector('button[onclick="searchThumbnail()"]');
    searchBtn.disabled = true;
    searchBtn.textContent = 'Searching...';
    
    // Use the Wikipedia service to search for thumbnails
    fetch(`/api/artists/${currentArtistId}/thumbnail/search`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.thumbnail_url) {
            // Auto-fill the thumbnail URL input
            document.getElementById('newThumbnailUrl').value = data.thumbnail_url;
            showSuccess(`Found thumbnail from ${data.source}: ${data.thumbnail_url}`);
        } else if (data.error) {
            showError('Error: ' + data.error);
        } else {
            showInfo('No thumbnail found for this artist');
        }
    })
    .catch(error => {
        console.error('Error searching thumbnail:', error);
        showError('Error searching for thumbnail');
    })
    .finally(() => {
        searchBtn.disabled = false;
        searchBtn.textContent = 'Search Thumbnail';
    });
}

function updateThumbnail() {
    const thumbnailUrl = document.getElementById('newThumbnailUrl').value.trim();
    
    if (!thumbnailUrl) {
        showWarning('Please enter a thumbnail URL');
        return;
    }
    
    if (!thumbnailUrl.match(/^https?:\/\/.+/)) {
        showError('Please enter a valid URL starting with http:// or https://');
        return;
    }
    
    const updateBtn = document.querySelector('button[onclick="updateThumbnail()"]');
    updateBtn.disabled = true;
    updateBtn.textContent = 'Updating...';
    
    fetch(`/api/artists/${currentArtistId}/thumbnail`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            thumbnail_url: thumbnailUrl
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            // Update the thumbnail preview
            updateThumbnailPreview(data.artist.thumbnail_url);
            // Clear the input
            document.getElementById('newThumbnailUrl').value = '';
            // Refresh artist details
            loadArtistDetails();
        } else {
            showError('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error updating thumbnail:', error);
        showError('Error updating thumbnail');
    })
    .finally(() => {
        updateBtn.disabled = false;
        updateBtn.textContent = 'Update Thumbnail';
    });
}

function removeThumbnail() {
    toastConfirm('Remove the current thumbnail? This cannot be undone.', () => {
        proceedRemoveThumbnail();
    });
}

function proceedRemoveThumbnail() {
    
    const removeBtn = document.querySelector('button[onclick="removeThumbnail()"]');
    removeBtn.disabled = true;
    removeBtn.textContent = 'Removing...';
    
    fetch(`/api/artists/${currentArtistId}/thumbnail`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            remove_thumbnail: true
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            // Update the thumbnail preview to show placeholder
            updateThumbnailPreview(null);
            // Refresh artist details
            loadArtistDetails();
        } else {
            showError('Error: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error removing thumbnail:', error);
        showError('Error removing thumbnail');
    })
    .finally(() => {
        removeBtn.disabled = false;
        removeBtn.textContent = 'Remove Thumbnail';
    });
}

function updateThumbnailPreview(thumbnailUrl) {
    const img = document.getElementById('currentThumbnailImg');
    const placeholder = document.getElementById('noThumbnailPlaceholder');
    
    if (thumbnailUrl) {
        img.src = `/api/artists/${currentArtistId}/thumbnail?t=${Date.now()}`;
        img.style.display = 'block';
        placeholder.style.display = 'none';
    } else {
        img.style.display = 'none';
        placeholder.style.display = 'block';
    }
}

function updateMetadataFromImvdb() {
    toastConfirm('Search for IMVDb matches? This will show you potential matches to choose from.', () => {
        searchImvdbMatches();
    });
}

function searchImvdbMatches() {
    const updateBtn = document.querySelector('button[onclick="updateMetadataFromImvdb()"]');
    const statusDiv = document.getElementById('metadataStatus');
    
    if (updateBtn) {
        updateBtn.disabled = true;
        updateBtn.textContent = 'Searching...';
    }
    
    if (statusDiv) {
        statusDiv.innerHTML = '<div class="loading-placeholder">Searching for matches...</div>';
    }
    
    fetch(`/api/artists/${currentArtistId}/metadata/search`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => {
        console.log('API Response status:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.text().then(text => {
            console.log('Raw API response:', text);
            try {
                return JSON.parse(text);
            } catch (e) {
                console.error('JSON parse error:', e);
                console.error('Response text:', text);
                throw new Error('Invalid JSON response from server');
            }
        });
    })
    .then(data => {
        if (data.error) {
            showError(data.message || data.error);
            if (statusDiv) {
                statusDiv.innerHTML = `<div class="error-message">${data.message || data.error}</div>`;
            }
        } else if (data.matches && data.matches.length > 0) {
            showImvdbMatchModal(data.matches);
            if (statusDiv) {
                statusDiv.innerHTML = `<div class="info-message">Found ${data.matches.length} potential matches</div>`;
            }
        } else {
            showWarning('No matches found on IMVDb');
            if (statusDiv) {
                statusDiv.innerHTML = '<div class="error-message">No matches found</div>';
            }
        }
    })
    .catch(error => {
        console.error('Error searching IMVDb matches:', error);
        
        // Provide user-friendly error messages
        let userMessage = 'Artist not found on IMVDb';
        let statusMessage = 'Artist not found on IMVDb';
        
        // Check for specific error types
        if (error.message && error.message.includes('404')) {
            userMessage = 'Artist not found on IMVDb';
            statusMessage = 'Artist not found on IMVDb';
        } else if (error.message && error.message.includes('400')) {
            userMessage = 'Artist not found on IMVDb';
            statusMessage = 'Artist not found on IMVDb';
        } else if (error.message && error.message.includes('401')) {
            userMessage = 'IMVDb API key not configured. Please check Settings > External Services';
            statusMessage = 'API key required';
        } else if (error.message && error.message.includes('403')) {
            userMessage = 'IMVDb API access denied. Please check your API key';
            statusMessage = 'API access denied';
        } else if (error.message && error.message.includes('429')) {
            userMessage = 'IMVDb rate limit exceeded. Please try again later';
            statusMessage = 'Rate limit exceeded';
        } else if (error.message && (error.message.includes('network') || error.message.includes('Connection'))) {
            userMessage = 'Network error. Please check your internet connection';
            statusMessage = 'Network error';
        } else if (error.message && error.message.includes('timeout')) {
            userMessage = 'Request timed out. Please try again';
            statusMessage = 'Request timed out';
        }
        
        showWarning(userMessage);
        if (statusDiv) {
            statusDiv.innerHTML = `<div class="warning-message">${statusMessage}</div>`;
        }
    })
    .finally(() => {
        if (updateBtn) {
            updateBtn.disabled = false;
            updateBtn.textContent = 'Update from IMVDb';
        }
    });
}

function showImvdbMatchModal(matches) {
    // Remove any existing IMVDb modal first
    const existingModal = document.getElementById('imvdbSearchModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    console.log(`Creating modal with ${matches.length} matches`);
    
    // Create a modal with proper background styling
    const modal = document.createElement('div');
    modal.id = 'imvdbSearchModal';
    
    // Use solid colors with CSS variable fallbacks for proper background
    modal.setAttribute('style', `
        position: fixed !important;
        top: 50px !important;
        left: 50px !important;
        right: 50px !important;
        bottom: 50px !important;
        background: #2a2a2a !important;
        border: 3px solid #444 !important;
        border-radius: 10px !important;
        z-index: 999999 !important;
        padding: 20px !important;
        overflow: auto !important;
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.8) !important;
        display: block !important;
        color: #fff !important;
    `);
    
    // Create HTML content with solid background colors
    modal.innerHTML = `
        <div style="margin-bottom: 20px; border-bottom: 2px solid #444; padding-bottom: 10px;">
            <h2 style="margin: 0; color: #fff;">ðŸŽµ Select IMVDb Match</h2>
            <button onclick="closeImvdbMatchModal()" style="position: absolute; top: 15px; right: 20px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 18px;" onmouseover="this.style.background='#c82333'" onmouseout="this.style.background='#dc3545'">&times;</button>
        </div>
        <div style="margin-bottom: 20px;">
            <p style="color: #fff;"><strong>Select the correct match for "${(currentArtistData && currentArtistData.name) || 'this artist'}" (${matches.length} results found):</strong></p>
        </div>
        <div style="max-height: 400px; overflow-y: auto; border: 1px solid #444; border-radius: 5px; background: #333;">
            ${matches.map(match => `
                <div onclick="selectImvdbMatch(${match.id})" style="padding: 15px; border-bottom: 1px solid #444; cursor: pointer; background: #3a3a3a; margin: 2px; border-radius: 3px; color: #fff;" onmouseover="this.style.background='#4a4a4a'" onmouseout="this.style.background='#3a3a3a'">
                    <div style="font-weight: bold; font-size: 16px; color: #00d4ff; margin-bottom: 5px;">
                        ${match.name || 'Unknown Artist'}
                        <span style="background: ${match.confidence === 'high' ? '#28a745' : '#ffc107'}; color: ${match.confidence === 'high' ? 'white' : 'black'}; padding: 2px 8px; border-radius: 12px; font-size: 12px; margin-left: 10px;">
                            ${match.confidence}
                        </span>
                    </div>
                    <div style="font-size: 14px; color: #ccc;">
                        ${match.origin ? `ðŸ“ ${match.origin}` : ''} 
                        ${match.genres && match.genres.length ? `ðŸŽµ ${match.genres.join(', ')}` : ''}
                        ${match.birth_date ? `ðŸ“… ${match.birth_date}` : ''}
                    </div>
                    ${match.bio ? `<div style="font-size: 12px; color: #999; margin-top: 5px;">${match.bio.substring(0, 100)}...</div>` : ''}
                </div>
            `).join('')}
        </div>
        <div style="margin-top: 20px; text-align: right;">
            <button onclick="closeImvdbMatchModal()" style="background: #6c757d; color: #fff; border: 1px solid #5a6268; padding: 10px 20px; border-radius: 5px; cursor: pointer;" onmouseover="this.style.background='#5a6268'" onmouseout="this.style.background='#6c757d'">Cancel</button>
        </div>
    `;
    
    // Add modal to DOM
    document.body.appendChild(modal);
    
    console.log('IMVDb modal created and displayed with proper background');
}

function closeImvdbMatchModal() {
    const modal = document.getElementById('imvdbSearchModal');
    if (modal) {
        console.log('Closing modal:', modal);
        modal.remove();
    } else {
        console.log('Modal not found for closing');
    }
}

function selectImvdbMatch(imvdbId) {
    const modal = document.querySelector('.modal-overlay');
    if (modal) {
        modal.remove();
    }
    
    // Update metadata using the selected match
    updateMetadataFromMatch(imvdbId);
}

function updateMetadataFromMatch(imvdbId) {
    const updateBtn = document.querySelector('button[onclick="updateMetadataFromImvdb()"]');
    const statusDiv = document.getElementById('metadataStatus');
    
    if (updateBtn) {
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';
    }
    
    if (statusDiv) {
        statusDiv.innerHTML = '<div class="loading-placeholder">Updating metadata...</div>';
    }
    
    fetch(`/api/artists/${currentArtistId}/metadata/update-from-match`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            imvdb_id: imvdbId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            
            // Show updated fields
            if (data.updated_fields && data.updated_fields.length > 0) {
                const fieldsText = data.updated_fields.join(', ');
                statusDiv.innerHTML = `<div class="success-message">Successfully updated: ${fieldsText}</div>`;
            } else {
                statusDiv.innerHTML = '<div class="info-message">No updates needed - metadata is already current</div>';
            }
            
            // Update artist data and refresh UI
            if (data.artist_data) {
                currentArtistData = { ...currentArtistData, ...data.artist_data };
                populateSettings(currentArtistData);
                
                // Update thumbnail if it was changed
                if (data.updated_fields.includes('thumbnail')) {
                    updateThumbnailPreview(data.artist_data.thumbnail_url);
                }
            }
        } else {
            showError('Error: ' + data.error);
            if (statusDiv) {
                statusDiv.innerHTML = `<div class="error-message">Update failed: ${data.error}</div>`;
            }
        }
    })
    .catch(error => {
        console.error('Error updating metadata:', error);
        let errorMessage = 'Error updating metadata from IMVDb';
        if (error.message) {
            errorMessage += ': ' + error.message;
        }
        showError(errorMessage);
        if (statusDiv) {
            statusDiv.innerHTML = `<div class="error-message">Update failed: ${error.message || 'Unknown error'}</div>`;
        }
    })
    .finally(() => {
        if (updateBtn) {
            updateBtn.disabled = false;
            updateBtn.textContent = 'Update from IMVDb';
        }
    });
}

function proceedUpdateMetadata() {
    console.log('proceedUpdateMetadata called'); // Debug log
    
    const updateBtn = document.querySelector('button[onclick="updateMetadataFromImvdb()"]');
    const statusDiv = document.getElementById('metadataStatus');
    let loadingDiv = null; // Declare at function scope for .finally() access
    
    
    if (statusDiv) {
        loadingDiv = statusDiv.querySelector('.loading-placeholder');
        
        // Fallback: create loading indicator if it doesn't exist
        if (!loadingDiv) {
            loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading-placeholder';
            loadingDiv.textContent = 'Updating metadata...';
            loadingDiv.style.display = 'none';
            statusDiv.appendChild(loadingDiv);
        }
    }
    
    if (updateBtn) {
        updateBtn.disabled = true;
        updateBtn.textContent = 'Updating...';
    }
    
    if (loadingDiv) {
        loadingDiv.style.display = 'block';
    }
    
    fetch(`/api/artists/${currentArtistId}/metadata/update`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(data.message);
            
            // Show updated fields
            if (data.updated_fields && data.updated_fields.length > 0) {
                const fieldsText = data.updated_fields.join(', ');
                statusDiv.innerHTML = `<div class="success-message">Successfully updated: ${fieldsText}</div>`;
            } else {
                statusDiv.innerHTML = '<div class="info-message">No updates needed - metadata is already current</div>';
            }
            
            // Update thumbnail preview if thumbnail was updated
            if (data.updated_fields.includes('thumbnail')) {
                updateThumbnailPreview(data.artist.thumbnail_url);
            }
            
            // Refresh artist details to show updated metadata
            loadArtistDetails();
        } else {
            // Handle duplicate IMVDb ID error specially
            if (data.error === 'duplicate_imvdb_id') {
                showMergePrompt(data);
            } else {
                showError('Error: ' + data.error);
                statusDiv.innerHTML = `<div class="error-message">Update failed: ${data.error}</div>`;
            }
        }
    })
    .catch(error => {
        console.error('Error updating metadata:', error);
        let errorMessage = 'Error updating metadata from IMVDb';
        if (error.message) {
            errorMessage += ': ' + error.message;
        }
        showError(errorMessage);
        statusDiv.innerHTML = `<div class="error-message">Update failed: ${error.message || 'Unknown error'}</div>`;
    })
    .finally(() => {
        if (updateBtn) {
            updateBtn.disabled = false;
            updateBtn.textContent = 'Update from IMVDb';
        }
        if (loadingDiv) {
            loadingDiv.style.display = 'none';
        }
    });
}

// Simple Artist Deletion
function confirmDeleteArtist() {
    if (!currentArtistId || !currentArtistData) {
        showError('No artist selected');
        return;
    }
    
    // Show analysis loading
    const analysisDiv = document.getElementById('analysisResults');
    const summaryDiv = document.getElementById('dependencySummary');
    const detailsDiv = document.getElementById('dependencyDetails');
    
    summaryDiv.innerHTML = '<div class="loading">Analyzing dependencies...</div>';
    detailsDiv.innerHTML = '';
    analysisDiv.style.display = 'block';
    
    // For now, show a basic confirmation since API endpoint doesn't exist yet
    setTimeout(() => {
        summaryDiv.innerHTML = `
            <div class="dependency-summary-grid">
                <div class="dependency-stat">
                    <span class="stat-number">âš ï¸</span>
                    <span class="stat-label">Deletion Impact</span>
                </div>
                <div class="dependency-stat">
                    <span class="stat-number">ðŸ“</span>
                    <span class="stat-label">All Artist Data</span>
                </div>
            </div>
        `;
        detailsDiv.innerHTML = `
            <div class="breakdown-section">
                <h5>âš ï¸ This will permanently delete:</h5>
                <ul>
                    <li>Artist record and metadata</li>
                    <li>All associated videos</li>
                    <li>Download history</li>
                    <li>Thumbnail images</li>
                </ul>
                <p><strong>This action cannot be undone.</strong></p>
            </div>
        `;
        document.getElementById('deletionOptions').style.display = 'block';
    }, 500);
}

function renderDependencyAnalysis(analysis) {
    const summaryDiv = document.getElementById('dependencySummary');
    const detailsDiv = document.getElementById('dependencyDetails');
    
    // Render summary
    summaryDiv.innerHTML = `
        <div class="dependency-summary-grid">
            <div class="dependency-stat">
                <span class="stat-number">${analysis.videos.total}</span>
                <span class="stat-label">Total Videos</span>
            </div>
            <div class="dependency-stat">
                <span class="stat-number">${analysis.videos.downloaded}</span>
                <span class="stat-label">Downloaded</span>
            </div>
            <div class="dependency-stat">
                <span class="stat-number">${analysis.downloads.active}</span>
                <span class="stat-label">Active Downloads</span>
            </div>
            <div class="dependency-stat">
                <span class="stat-number">${formatFileSize(analysis.storage.total_size)}</span>
                <span class="stat-label">Storage Used</span>
            </div>
        </div>
    `;
    
    // Render detailed breakdown
    let detailsHtml = '<div class="dependency-breakdown">';
    
    if (analysis.videos.total > 0) {
        detailsHtml += `
            <div class="breakdown-section">
                <h5>ðŸ“¹ Videos Impact</h5>
                <ul>
                    <li>${analysis.videos.downloaded} downloaded videos will be affected</li>
                    <li>${analysis.videos.wanted} wanted videos will be removed from queue</li>
                    <li>${analysis.videos.downloading} videos currently downloading</li>
                </ul>
            </div>
        `;
    }
    
    if (analysis.downloads.active > 0) {
        detailsHtml += `
            <div class="breakdown-section">
                <h5>ðŸ“¥ Download Impact</h5>
                <ul>
                    <li>${analysis.downloads.active} active downloads will be stopped</li>
                    <li>${analysis.downloads.queued} queued downloads will be removed</li>
                    <li>Download history (${analysis.downloads.completed} items) will be preserved</li>
                </ul>
            </div>
        `;
    }
    
    if (analysis.storage.files > 0) {
        detailsHtml += `
            <div class="breakdown-section">
                <h5>ðŸ’¾ Storage Impact</h5>
                <ul>
                    <li>${analysis.storage.files} files using ${formatFileSize(analysis.storage.total_size)}</li>
                    <li>Thumbnails: ${analysis.storage.thumbnails} files</li>
                    <li>Metadata: ${formatFileSize(analysis.storage.metadata_size)}</li>
                </ul>
            </div>
        `;
    }
    
    if (analysis.references && analysis.references.length > 0) {
        detailsHtml += `
            <div class="breakdown-section">
                <h5>ðŸ”— External References</h5>
                <ul>
                    ${analysis.references.map(ref => `<li>${ref.type}: ${ref.description}</li>`).join('')}
                </ul>
            </div>
        `;
    }
    
    detailsHtml += '</div>';
    detailsDiv.innerHTML = detailsHtml;
    
    document.getElementById('analysisResults').style.display = 'block';
}

function setupDeletionListeners() {
    // Listen for deletion method changes
    document.querySelectorAll('input[name="deletionMethod"]').forEach(radio => {
        radio.addEventListener('change', function() {
            updateFileOptions(this.value);
        });
    });
    
    // Listen for confirmation text changes
    const confirmationInput = document.getElementById('confirmationText');
    const confirmBtn = document.getElementById('confirmDeleteBtn');
    
    if (confirmationInput && confirmBtn) {
        confirmationInput.addEventListener('input', function() {
            confirmBtn.disabled = this.value.trim().toUpperCase() !== 'DELETE';
        });
    }
}

function updateFileOptions(deletionMethod) {
    const fileOptions = document.getElementById('fileOptions');
    const deleteFiles = document.getElementById('deleteFilesOption');
    const deleteThumbnails = document.getElementById('deleteThumbnailsOption');
    
    if (deletionMethod === 'soft') {
        fileOptions.style.display = 'none';
        deleteFiles.checked = false;
        deleteThumbnails.checked = false;
    } else if (deletionMethod === 'cascade') {
        fileOptions.style.display = 'block';
        deleteFiles.checked = false;
        deleteThumbnails.checked = true;
    } else if (deletionMethod === 'complete') {
        fileOptions.style.display = 'block';
        deleteFiles.checked = true;
        deleteThumbnails.checked = true;
    }
}

function deleteArtist() {
    if (!currentArtistId || !currentArtistData) {
        showError('No artist selected');
        return;
    }
    
    showInfo('Deleting artist... This may take a moment.');
    
    fetch(`/api/artists/${currentArtistId}?force=true`, {
        method: 'DELETE'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(`Artist "${currentArtistData.name}" deleted successfully`);
            
            // Redirect to artists list after delay
            setTimeout(() => {
                window.location.href = '/artists';
            }, 2000);
        } else {
            showError('Deletion failed: ' + (data.error || 'Unknown error'));
        }
    })
    .catch(error => {
        console.error('Deletion error:', error);
        showError('Deletion failed: ' + error.message);
    });
}

function cancelDeletion() {
    document.getElementById('deletionOptions').style.display = 'none';
    document.getElementById('analysisResults').style.display = 'none';
    document.getElementById('confirmationText').value = '';
    document.getElementById('confirmDeleteBtn').disabled = true;
}


// Merge Artists Functions
let mergeConflictData = null;

function showMergePrompt(conflictData) {
    mergeConflictData = conflictData;
    
    // Populate the conflict info
    document.getElementById('conflictImvdbId').textContent = conflictData.imvdb_id;
    
    // Show artist information
    const mergeInfoHtml = `
        <div class="merge-artists-comparison">
            <div class="merge-artist-card current">
                <h4>Current Artist (Will be kept)</h4>
                <div class="artist-info">
                    <p><strong>Name:</strong> ${conflictData.current_artist.name}</p>
                    <p><strong>ID:</strong> ${conflictData.current_artist.id}</p>
                    <p><strong>Status:</strong> This artist's metadata update was blocked</p>
                </div>
            </div>
            
            <div class="merge-arrow">â†’</div>
            
            <div class="merge-artist-card conflicting">
                <h4>Conflicting Artist (Will be merged into current)</h4>
                <div class="artist-info">
                    <p><strong>Name:</strong> ${conflictData.conflicting_artist.name}</p>
                    <p><strong>ID:</strong> ${conflictData.conflicting_artist.id}</p>
                    <p><strong>IMVDb ID:</strong> ${conflictData.imvdb_id}</p>
                </div>
            </div>
        </div>
        
        <div class="merge-explanation-details">
            <h4>What will happen:</h4>
            <ul>
                <li>All videos from "${conflictData.conflicting_artist.name}" will be transferred to "${conflictData.current_artist.name}"</li>
                <li>All downloads will be transferred</li>
                <li>Settings and metadata will be merged (best values kept)</li>
                <li>"${conflictData.conflicting_artist.name}" will be deleted</li>
                <li>The metadata update for "${conflictData.current_artist.name}" will complete</li>
            </ul>
            <p class="merge-warning"><strong>âš ï¸ This action cannot be undone!</strong></p>
        </div>
    `;
    
    document.getElementById('mergeArtistsInfo').innerHTML = mergeInfoHtml;
    document.getElementById('mergeArtistModal').style.display = 'block';
}

function hideMergePrompt() {
    document.getElementById('mergeArtistModal').style.display = 'none';
    mergeConflictData = null;
}

function proceedWithMerge() {
    if (!mergeConflictData) {
        showError('No merge data available');
        return;
    }
    
    const mergeBtn = document.getElementById('mergeBtn');
    mergeBtn.disabled = true;
    mergeBtn.textContent = 'Merging...';
    
    // Perform the merge: merge conflicting artist into current artist
    fetch('/api/artists/merge', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            primary_artist_id: mergeConflictData.current_artist.id,
            secondary_artist_ids: [mergeConflictData.conflicting_artist.id]
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(`Artists merged successfully! Merged "${mergeConflictData.conflicting_artist.name}" into "${mergeConflictData.current_artist.name}"`);
            hideMergePrompt();
            
            // Now retry the metadata update
            updateMetadataFromImvdb();
        } else {
            showError('Merge failed: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error merging artists:', error);
        showError('Error merging artists: ' + error.message);
    })
    .finally(() => {
        mergeBtn.disabled = false;
        mergeBtn.textContent = 'Merge Artists';
    });
}

// Artist Navigation Functions
function loadArtistNavigation() {
    // Get sort parameters from URL or localStorage (if user was browsing with specific sort)
    const sortBy = getStoredSortPreference() || 'name';
    const sortOrder = getStoredSortOrder() || 'asc';
    
    fetch(`/api/artists/${currentArtistId}/navigation?sort=${sortBy}&order=${sortOrder}`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                console.error('Error loading artist navigation:', data.error);
                return;
            }
            
            navigationData = data;
            updateNavigationUI();
        })
        .catch(error => {
            console.error('Error loading artist navigation:', error);
        });
}

function updateNavigationUI() {
    if (!navigationData) return;
    
    const navigationControls = document.getElementById('artistNavigationControls');
    const positionInfo = document.getElementById('artistPositionInfo');
    const prevBtn = document.getElementById('prevArtistBtn');
    const nextBtn = document.getElementById('nextArtistBtn');
    
    // Show navigation controls
    navigationControls.style.display = 'flex';
    
    // Update position info
    positionInfo.textContent = `Artist ${navigationData.current_artist.position} of ${navigationData.current_artist.total_artists}`;
    
    // Update previous button (left arrow - should go to the artist before in list)
    if (navigationData.next_artist) {
        prevBtn.disabled = false;
        prevBtn.title = `Previous: ${navigationData.next_artist.name}`;
        prevBtn.innerHTML = `<span>â†</span> ${navigationData.next_artist.name}`;
    } else {
        prevBtn.disabled = true;
        prevBtn.title = 'No previous artist';
        prevBtn.innerHTML = '<span>â†</span> Previous Artist';
    }
    
    // Update next button (right arrow - should go to the artist after in list)
    if (navigationData.prev_artist) {
        nextBtn.disabled = false;
        nextBtn.title = `Next: ${navigationData.prev_artist.name}`;
        nextBtn.innerHTML = `${navigationData.prev_artist.name} <span>â†’</span>`;
    } else {
        nextBtn.disabled = true;
        nextBtn.title = 'No next artist';
        nextBtn.innerHTML = 'Next Artist <span>â†’</span>';
    }
}

function navigateToPrevArtist() {
    if (!navigationData || !navigationData.next_artist) return;
    
    const prevArtistId = navigationData.next_artist.id;
    window.location.href = `/artist/${prevArtistId}`;
}

function navigateToNextArtist() {
    if (!navigationData || !navigationData.prev_artist) return;
    
    const nextArtistId = navigationData.prev_artist.id;
    window.location.href = `/artist/${nextArtistId}`;
}

function getStoredSortPreference() {
    try {
        return localStorage.getItem('artistSortBy');
    } catch (e) {
        return null;
    }
}

function getStoredSortOrder() {
    try {
        return localStorage.getItem('artistSortOrder');
    } catch (e) {
        return null;
    }
}

// Update sort preferences when user changes them on artists list page
function updateSortPreferences(sortBy, sortOrder) {
    try {
        localStorage.setItem('artistSortBy', sortBy);
        localStorage.setItem('artistSortOrder', sortOrder);
    } catch (e) {
        console.warn('Could not store sort preferences:', e);
    }
}

// Enhanced Download Management Functions

// Queue visualization variables
let queueAutoRefresh = false;
let queueRefreshInterval = null;
let currentDownloadView = 'list';

// Enhanced download statistics calculation
function calculateEnhancedDownloadStats(downloads) {
    const stats = {
        total: downloads.length,
        active: 0,
        queued: 0,
        downloading: 0,
        completed: 0,
        failed: 0,
        retryable: 0,
        totalSize: 0,
        downloadedSize: 0,
        avgSpeed: 0,
        eta: 'Unknown',
        highPriority: 0,
        avgQueuePosition: 0,
        queueHealth: 'good',
        totalTrend: 0,
        activeProgress: 0,
        avgWaitTime: 'Unknown'
    };
    
    let totalSpeed = 0;
    let speedCount = 0;
    let prioritySum = 0;
    
    downloads.forEach((download, index) => {
        switch (download.status) {
            case 'downloading':
                stats.downloading++;
                stats.active++;
                if (download.download_speed) {
                    totalSpeed += download.download_speed;
                    speedCount++;
                }
                break;
            case 'pending':
            case 'queued':
                stats.queued++;
                stats.active++;
                break;
            case 'completed':
                stats.completed++;
                if (download.file_size) {
                    stats.downloadedSize += download.file_size;
                }
                break;
            case 'failed':
                stats.failed++;
                if (!download.retry_count || download.retry_count < 3) {
                    stats.retryable++;
                }
                break;
        }
        
        if (download.file_size) {
            stats.totalSize += download.file_size;
        }
        
        const priority = download.priority || 5;
        if (priority <= 2) {
            stats.highPriority++;
        }
        prioritySum += priority;
    });
    
    if (speedCount > 0) {
        stats.avgSpeed = totalSpeed / speedCount;
    }
    
    if (downloads.length > 0) {
        stats.avgQueuePosition = Math.round(prioritySum / downloads.length);
        stats.activeProgress = Math.round((stats.active / downloads.length) * 100);
    }
    
    // Determine queue health
    const failureRate = stats.total > 0 ? (stats.failed / stats.total) * 100 : 0;
    if (failureRate > 20) {
        stats.queueHealth = 'poor';
    } else if (failureRate > 10) {
        stats.queueHealth = 'fair';
    }
    
    return stats;
}

// Priority and status helper functions
function getPriorityLevel(priority) {
    if (priority <= 2) return 'high';
    if (priority <= 4) return 'medium-high';
    if (priority <= 6) return 'normal';
    if (priority <= 8) return 'medium-low';
    return 'low';
}

function getPriorityLabel(priority) {
    if (priority === 1) return 'Highest';
    if (priority === 5) return 'Normal';
    if (priority === 10) return 'Lowest';
    return '';
}

function getStatusIcon(status) {
    const icons = {
        'pending': 'â³',
        'queued': 'ðŸ•°ï¸',
        'downloading': 'â¬‡ï¸',
        'completed': 'âœ…',
        'failed': 'âŒ',
        'paused': 'â¸ï¸',
        'cancelled': 'â›”'
    };
    return icons[status] || 'â“';
}

function getHealthIcon(health) {
    const icons = {
        'good': 'ðŸŸ¢',
        'fair': 'ðŸŸ¡',
        'poor': 'ðŸ”´'
    };
    return icons[health] || 'â”';
}

function formatSpeed(bytesPerSecond) {
    if (!bytesPerSecond) return 'Unknown';
    const units = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
    let size = bytesPerSecond;
    let unitIndex = 0;
    
    while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
    }
    
    return `${size.toFixed(1)} ${units[unitIndex]}`;
}

// Queue management functions
function toggleDownloadView(view) {
    currentDownloadView = view;
    
    // Update button states
    document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById(view + 'ViewBtn').classList.add('active');
    
    // Show/hide sections
    const queueViz = document.getElementById('queueVisualization');
    const downloadsList = document.getElementById('downloadsListContainer');
    
    if (view === 'queue') {
        queueViz.style.display = 'block';
        downloadsList.style.display = 'none';
        loadQueueVisualization();
    } else {
        queueViz.style.display = 'none';
        downloadsList.style.display = 'block';
    }
}

function loadQueueVisualization() {
    if (!currentArtistId) return;
    
    fetch(`/api/downloads/queue?artist_id=${currentArtistId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                renderQueueVisualization(data.queue);
                renderQueueMetrics(data.metrics);
            }
        })
        .catch(error => {
            console.error('Error loading queue visualization:', error);
            if (typeof showError === 'function') {
                showError('Failed to load queue visualization');
            } else {
                alert('Failed to load queue visualization');
            }
        });
}

function renderQueueVisualization(queue) {
    const timeline = document.getElementById('queueTimeline');
    
    if (!queue || queue.length === 0) {
        timeline.innerHTML = '<div class="no-results">No downloads in queue</div>';
        return;
    }
    
    const timelineHtml = `
        <div class="queue-timeline-container">
            <div class="timeline-header">
                <h4>Download Timeline (Next 24 hours)</h4>
            </div>
            <div class="timeline-track">
                ${queue.map((item, index) => `
                    <div class="timeline-item" 
                         data-id="${item.id}" 
                         data-priority="${item.priority}" 
                         style="left: ${(index * 2)}%; width: ${Math.max(1.5, (100 - index * 2) / queue.length)}%;">
                        <div class="timeline-content priority-${getPriorityLevel(item.priority)}">
                            <div class="timeline-title">${item.title.substring(0, 30)}${item.title.length > 30 ? '...' : ''}</div>
                            <div class="timeline-meta">
                                <span class="priority">P${item.priority}</span>
                                <span class="position">#${index + 1}</span>
                                ${item.eta ? `<span class="eta">${item.eta}</span>` : ''}
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
            <div class="timeline-legend">
                <div class="legend-item"><span class="legend-color priority-high"></span> High Priority (1-2)</div>
                <div class="legend-item"><span class="legend-color priority-normal"></span> Normal Priority (3-6)</div>
                <div class="legend-item"><span class="legend-color priority-low"></span> Low Priority (7-10)</div>
            </div>
        </div>
    `;
    
    timeline.innerHTML = timelineHtml;
    
    // Update timestamp
    document.getElementById('queueUpdateTime').textContent = 
        `Last updated: ${new Date().toLocaleTimeString()}`;
}

function renderQueueMetrics(metrics) {
    const metricsDiv = document.getElementById('queueMetrics');
    
    const metricsHtml = `
        <div class="queue-metrics-grid">
            <div class="metric-card">
                <h4>Queue Efficiency</h4>
                <div class="metric-value">${metrics.efficiency || 85}%</div>
                <div class="metric-trend ${metrics.efficiencyTrend > 0 ? 'up' : 'down'}">
                    ${metrics.efficiencyTrend > 0 ? 'â†—' : 'â†˜'} ${Math.abs(metrics.efficiencyTrend || 2)}%
                </div>
            </div>
            <div class="metric-card">
                <h4>Average Wait Time</h4>
                <div class="metric-value">${metrics.avgWaitTime || '5m'}</div>
                <div class="metric-detail">Before download starts</div>
            </div>
            <div class="metric-card">
                <h4>Throughput</h4>
                <div class="metric-value">${metrics.throughput || 3.2}</div>
                <div class="metric-detail">Downloads per hour</div>
            </div>
            <div class="metric-card">
                <h4>Success Rate</h4>
                <div class="metric-value">${metrics.successRate || 92}%</div>
                <div class="metric-detail">Last 24 hours</div>
            </div>
        </div>
    `;
    
    metricsDiv.innerHTML = metricsHtml;
}

// Enhanced download controls
function toggleQueueAutoRefresh() {
    const btn = document.getElementById('autoRefreshBtn');
    
    if (queueAutoRefresh) {
        queueAutoRefresh = false;
        clearInterval(queueRefreshInterval);
        btn.textContent = 'ðŸ”„ Auto-refresh: OFF';
        btn.classList.remove('active');
    } else {
        queueAutoRefresh = true;
        queueRefreshInterval = setInterval(() => {
            if (currentDownloadView === 'queue') {
                loadQueueVisualization();
            }
        }, 10000); // Refresh every 10 seconds
        btn.textContent = 'ðŸ”„ Auto-refresh: ON';
        btn.classList.add('active');
    }
}

function pauseAllDownloads() {
    fetch('/api/downloads/bulk/pause', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess('All downloads paused');
            refreshDownloads();
        } else {
            showError('Failed to pause downloads: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error pausing downloads:', error);
        showError('Error pausing downloads');
    });
}

function resumeAllDownloads() {
    fetch('/api/downloads/bulk/resume', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess('All downloads resumed');
            refreshDownloads();
        } else {
            showError('Failed to resume downloads: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error resuming downloads:', error);
        showError('Error resuming downloads');
    });
}

function reorderQueue() {
    fetch('/api/downloads/queue/reorder', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(`Queue reordered - ${data.changes || 0} items moved`);
            refreshDownloads();
            if (currentDownloadView === 'queue') {
                loadQueueVisualization();
            }
        } else {
            showError('Failed to reorder queue: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error reordering queue:', error);
        showError('Error reordering queue');
    });
}

function pauseDownload(downloadId) {
    fetch(`/api/downloads/${downloadId}/pause`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess('Download paused');
            refreshDownloads();
        } else {
            showError('Failed to pause download: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error pausing download:', error);
        showError('Error pausing download');
    });
}

function resumeDownload(downloadId) {
    fetch(`/api/downloads/${downloadId}/resume`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess('Download resumed');
            refreshDownloads();
        } else {
            showError('Failed to resume download: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error resuming download:', error);
        showError('Error resuming download');
    });
}

function moveToTop(downloadId) {
    fetch(`/api/downloads/${downloadId}/priority`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ priority: 1 })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess('Download moved to top of queue');
            refreshDownloads();
        } else {
            showError('Failed to move download: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error moving download:', error);
        showError('Error moving download');
    });
}

// Batch Import Workflow Functions

// Batch import state management
let selectedForImport = new Set();
let batchImportInProgress = false;
let batchImportCancelled = false;
let discoveredVideosData = [];

// Quality assessment functions
function getVideoQuality(video) {
    let score = 0;
    
    // Year-based scoring
    if (video.year && video.year >= 2020) score += 3;
    else if (video.year && video.year >= 2015) score += 2;
    else if (video.year && video.year >= 2010) score += 1;
    
    // Thumbnail availability
    if (video.thumbnail_url && !video.thumbnail_url.includes('placeholder')) score += 2;
    
    // Director information
    if (video.directors && video.directors.length > 0) score += 1;
    
    // Album association
    if (video.album) score += 1;
    
    // Description availability
    if (video.description && video.description.length > 50) score += 1;
    
    // Duration information
    if (video.duration && video.duration > 60) score += 1;
    
    // Search score
    if (video.search_score && video.search_score > 0.8) score += 2;
    else if (video.search_score && video.search_score > 0.6) score += 1;
    
    if (score >= 8) return 'Excellent';
    if (score >= 6) return 'High';
    if (score >= 4) return 'Good';
    if (score >= 2) return 'Fair';
    return 'Basic';
}

function calculateQualityStats(videos) {
    const currentYear = new Date().getFullYear();
    const fiveYearsAgo = currentYear - 5;
    
    return {
        highQuality: videos.filter(v => ['Excellent', 'High'].includes(getVideoQuality(v))).length,
        withThumbnails: videos.filter(v => v.thumbnail_url && !v.thumbnail_url.includes('placeholder')).length,
        recentVideos: videos.filter(v => v.year && v.year >= fiveYearsAgo).length,
        withDirectors: videos.filter(v => v.directors && v.directors.length > 0).length
    };
}

// Batch selection functions
function initializeBatchImportSelection(videos) {
    discoveredVideosData = videos || [];
    selectedForImport.clear();
    updateBatchSelection();
}

function updateBatchSelection() {
    const checkboxes = document.querySelectorAll('.video-batch-select');
    selectedForImport.clear();
    
    checkboxes.forEach(checkbox => {
        if (checkbox.checked) {
            // Store both ID and source type for proper routing
            const youtubeId = checkbox.dataset.youtubeId;
            const imvdbId = checkbox.dataset.imvdbId;
            const source = youtubeId && youtubeId !== '' ? 'youtube' : 'imvdb';
            const videoId = youtubeId || imvdbId;
            
            console.log('Checkbox checked:', { youtubeId, imvdbId, videoId, source });
            
            if (videoId && videoId !== '') {
                // Store video data as string that we can parse later (Sets don't work well with objects)
                const videoData = JSON.stringify({
                    id: videoId,
                    source: source
                });
                selectedForImport.add(videoData);
            }
        }
    });
    
    console.log('Selected for import:', Array.from(selectedForImport), 'Count:', selectedForImport.size);
    
    // Update UI
    document.getElementById('selectedForImportCount').textContent = selectedForImport.size;
    document.getElementById('batchImportText').textContent = `ðŸš€ Import Selected Videos (${selectedForImport.size})`;
    document.getElementById('batchImportBtn').disabled = selectedForImport.size === 0;
}

function selectAllForImport() {
    const checkboxes = document.querySelectorAll('.video-batch-select');
    checkboxes.forEach(checkbox => {
        const videoCard = checkbox.closest('.discovered-video-card');
        if (videoCard.dataset.selectable === 'true') {
            checkbox.checked = true;
        }
    });
    updateBatchSelection();
    showInfo(`Selected ${selectedForImport.size} videos for import`);
}

function selectNoneForImport() {
    const checkboxes = document.querySelectorAll('.video-batch-select');
    checkboxes.forEach(checkbox => {
        checkbox.checked = false;
    });
    updateBatchSelection();
    showInfo('Cleared all selections');
}

function selectByYear() {
    const yearThreshold = prompt('Select videos from which year onwards?', '2020');
    if (!yearThreshold) return;
    
    const year = parseInt(yearThreshold);
    const checkboxes = document.querySelectorAll('.video-batch-select');
    let selectedCount = 0;
    
    checkboxes.forEach(checkbox => {
        const videoCard = checkbox.closest('.discovered-video-card');
        const videoYear = parseInt(videoCard.dataset.year) || 0;
        
        if (videoCard.dataset.selectable === 'true' && videoYear >= year) {
            checkbox.checked = true;
            selectedCount++;
        } else {
            checkbox.checked = false;
        }
    });
    
    updateBatchSelection();
    showInfo(`Selected ${selectedCount} videos from ${year} onwards`);
}

function selectByQuality() {
    const checkboxes = document.querySelectorAll('.video-batch-select');
    let selectedCount = 0;
    
    checkboxes.forEach(checkbox => {
        const videoCard = checkbox.closest('.discovered-video-card');
        const quality = videoCard.dataset.quality;
        
        if (videoCard.dataset.selectable === 'true' && ['Excellent', 'High', 'Good'].includes(quality)) {
            checkbox.checked = true;
            selectedCount++;
        } else {
            checkbox.checked = false;
        }
    });
    
    updateBatchSelection();
    showInfo(`Selected ${selectedCount} high-quality videos`);
}

// Batch import execution
function executeBatchImport() {
    if (selectedForImport.size === 0) {
        showWarning('Please select videos to import');
        return;
    }
    
    if (batchImportInProgress) {
        showWarning('Batch import already in progress');
        return;
    }
    
    const autoDownload = document.getElementById('batchAutoDownload').checked;
    const skipExisting = document.getElementById('batchSkipExisting').checked;
    const highPriority = document.getElementById('batchHighPriority').checked;
    
    // Show progress UI
    document.getElementById('batchProgress').style.display = 'block';
    document.getElementById('batchImportBtn').disabled = true;
    
    // Reset progress
    batchImportInProgress = true;
    batchImportCancelled = false;
    
    // Reset counters
    document.getElementById('successCount').textContent = '0';
    document.getElementById('errorCount').textContent = '0';
    document.getElementById('skipCount').textContent = '0';
    document.getElementById('resultDetails').innerHTML = '';
    
    const videosToImport = Array.from(selectedForImport).map(videoDataString => JSON.parse(videoDataString));
    console.log('Videos to import:', videosToImport);
    processBatchImport(videosToImport, {
        auto_download: autoDownload,
        skip_existing: skipExisting,
        high_priority: highPriority
    });
}

async function processBatchImport(videoData, options) {
    const total = videoData.length;
    let completed = 0;
    let successCount = 0;
    let errorCount = 0;
    let skipCount = 0;
    
    const results = [];
    
    for (const videoItem of videoData) {
        if (batchImportCancelled) {
            showWarning('Batch import cancelled');
            break;
        }
        
        // Update progress
        const progress = Math.round((completed / total) * 100);
        document.getElementById('batchProgressFill').style.width = progress + '%';
        document.getElementById('batchProgressText').textContent = progress + '%';
        document.getElementById('batchProgressDetails').textContent = 
            `Processing video ${completed + 1} of ${total}... (${videoItem.source})`;
        
        try {
            const result = await importVideoWithOptions(videoItem.id, videoItem.source, options);
            
            if (result.success) {
                if (result.skipped) {
                    skipCount++;
                    results.push({ videoId: videoItem.id, source: videoItem.source, status: 'skipped', message: result.message });
                } else {
                    successCount++;
                    results.push({ videoId: videoItem.id, source: videoItem.source, status: 'success', message: result.message, video: result.video });
                }
            } else {
                errorCount++;
                results.push({ videoId: videoItem.id, source: videoItem.source, status: 'error', message: result.error });
            }
            
        } catch (error) {
            errorCount++;
            results.push({ videoId: videoItem.id, source: videoItem.source, status: 'error', message: error.message });
        }
        
        completed++;
        
        // Update counters
        document.getElementById('successCount').textContent = successCount;
        document.getElementById('errorCount').textContent = errorCount;
        document.getElementById('skipCount').textContent = skipCount;
        
        // Add small delay to prevent overwhelming the server
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Final progress update
    const finalProgress = batchImportCancelled ? 
        Math.round((completed / total) * 100) : 100;
    document.getElementById('batchProgressFill').style.width = finalProgress + '%';
    document.getElementById('batchProgressText').textContent = finalProgress + '%';
    
    if (batchImportCancelled) {
        document.getElementById('batchProgressDetails').textContent = 
            `Import cancelled after ${completed} of ${total} videos`;
    } else {
        document.getElementById('batchProgressDetails').textContent = 
            `Import completed: ${successCount} imported, ${errorCount} failed, ${skipCount} skipped`;
    }
    
    // Show detailed results
    displayBatchImportResults(results);
    
    // Clean up
    batchImportInProgress = false;
    document.getElementById('batchImportBtn').disabled = false;
    
    // Show summary notification
    if (successCount > 0) {
        showSuccess(`Batch import completed: ${successCount} videos imported successfully`);
        // Refresh the videos tab to show new videos
        loadArtistDetails();
    }
    
    if (errorCount > 0) {
        showError(`${errorCount} videos failed to import. Check details below.`);
    }
}

async function importVideoWithOptions(videoId, source, options) {
    // Choose the correct endpoint and body key based on source
    const endpoint = source === 'youtube' ? '/api/videos/import-from-youtube' : '/api/videos/import-from-imvdb';
    const bodyKey = source === 'youtube' ? 'youtube_id' : 'imvdb_id';
    
    console.log(`Importing ${source} video:`, videoId, 'via', endpoint);
    
    const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            [bodyKey]: videoId,
            artist_id: currentArtistId,
            auto_download: options.auto_download,
            skip_existing: options.skip_existing,
            priority: options.high_priority ? 1 : 5
        })
    });
    
    return await response.json();
}

function displayBatchImportResults(results) {
    const resultDetails = document.getElementById('resultDetails');
    
    const resultsHtml = results.map(result => {
        const video = discoveredVideosData.find(v => v.imvdb_id === result.imvdbId);
        const videoTitle = video ? video.title : `Video ${result.imvdbId}`;
        
        let statusIcon, statusClass;
        switch (result.status) {
            case 'success':
                statusIcon = 'âœ…';
                statusClass = 'success';
                break;
            case 'skipped':
                statusIcon = 'â­ï¸';
                statusClass = 'skipped';
                break;
            case 'error':
                statusIcon = 'âŒ';
                statusClass = 'error';
                break;
        }
        
        return `
            <div class="result-item ${statusClass}">
                <span class="result-icon">${statusIcon}</span>
                <span class="result-title">${videoTitle}</span>
                <span class="result-message">${result.message}</span>
            </div>
        `;
    }).join('');
    
    resultDetails.innerHTML = resultsHtml;
}

function cancelBatchImport() {
    if (!batchImportInProgress) {
        showWarning('No batch import in progress');
        return;
    }
    
    batchImportCancelled = true;
    showInfo('Cancelling batch import...');
}

// Enhanced Thumbnail Management Functions

// Thumbnail management state
let currentImageData = null;
let cropArea = null;
let isDragging = false;
let startX, startY;

// Initialize thumbnail management
function initializeThumbnailManagement() {
    const dragDropArea = document.getElementById('dragDropArea');
    const fileInput = document.getElementById('thumbnailFileInput');
    
    if (!dragDropArea || !fileInput) return;
    
    // Drag and drop events
    dragDropArea.addEventListener('click', () => fileInput.click());
    
    dragDropArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        dragDropArea.classList.add('drag-over');
    });
    
    dragDropArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dragDropArea.classList.remove('drag-over');
    });
    
    dragDropArea.addEventListener('drop', (e) => {
        e.preventDefault();
        dragDropArea.classList.remove('drag-over');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleFileSelection(files[0]);
        }
    });
    
    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
            handleFileSelection(e.target.files[0]);
        }
    });
    
    // Initialize canvas for cropping
    initializeCropCanvas();
    
    // Load current thumbnail info
    loadThumbnailInfo();
}

function handleFileSelection(file) {
    // Validate file type
    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'];
    if (!allowedTypes.includes(file.type)) {
        showError('Invalid file type. Please select a JPEG, PNG, WebP, or GIF image.');
        return;
    }
    
    // Validate file size (10MB max)
    if (file.size > 10 * 1024 * 1024) {
        showError('File too large. Maximum size is 10MB.');
        return;
    }
    
    // Read and preview the file
    const reader = new FileReader();
    reader.onload = (e) => {
        currentImageData = {
            file: file,
            dataUrl: e.target.result,
            name: file.name,
            size: file.size
        };
        
        showImagePreview(e.target.result);
    };
    
    reader.readAsDataURL(file);
}

function showImagePreview(dataUrl) {
    const previewPanel = document.getElementById('imagePreview');
    const canvas = document.getElementById('cropCanvas');
    const ctx = canvas.getContext('2d');
    
    previewPanel.style.display = 'block';
    
    const img = new Image();
    img.onload = () => {
        // Calculate canvas dimensions
        const maxWidth = 400;
        const maxHeight = 300;
        let { width, height } = img;
        
        if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
        }
        
        if (height > maxHeight) {
            width = (width * maxHeight) / height;
            height = maxHeight;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        // Draw image
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, width, height);
        
        // Initialize crop area to full image
        cropArea = {
            x: 0,
            y: 0,
            width: width,
            height: height,
            originalWidth: img.width,
            originalHeight: img.height,
            scaleX: img.width / width,
            scaleY: img.height / height
        };
        
        drawCropOverlay();
        updateCropInfo();
    };
    
    img.src = dataUrl;
}

function initializeCropCanvas() {
    const canvas = document.getElementById('cropCanvas');
    if (!canvas) return;
    
    canvas.addEventListener('mousedown', startCrop);
    canvas.addEventListener('mousemove', updateCrop);
    canvas.addEventListener('mouseup', endCrop);
    canvas.addEventListener('mouseleave', endCrop);
}

function startCrop(e) {
    const rect = e.target.getBoundingClientRect();
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;
    isDragging = true;
    
    cropArea.x = startX;
    cropArea.y = startY;
    cropArea.width = 0;
    cropArea.height = 0;
}

function updateCrop(e) {
    if (!isDragging) return;
    
    const rect = e.target.getBoundingClientRect();
    const currentX = e.clientX - rect.left;
    const currentY = e.clientY - rect.top;
    
    cropArea.width = currentX - startX;
    cropArea.height = currentY - startY;
    
    // Ensure positive dimensions
    if (cropArea.width < 0) {
        cropArea.x = currentX;
        cropArea.width = Math.abs(cropArea.width);
    }
    
    if (cropArea.height < 0) {
        cropArea.y = currentY;
        cropArea.height = Math.abs(cropArea.height);
    }
    
    drawCropOverlay();
    updateCropInfo();
}

function endCrop() {
    isDragging = false;
}

function drawCropOverlay() {
    const canvas = document.getElementById('cropCanvas');
    const ctx = canvas.getContext('2d');
    
    // Redraw the image
    if (currentImageData) {
        const img = new Image();
        img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Draw crop overlay
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(cropArea.x, cropArea.y, cropArea.width, cropArea.height);
            
            // Draw semi-transparent overlay outside crop area
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.setLineDash([]);
            
            // Top
            ctx.fillRect(0, 0, canvas.width, cropArea.y);
            // Bottom
            ctx.fillRect(0, cropArea.y + cropArea.height, canvas.width, canvas.height - cropArea.y - cropArea.height);
            // Left
            ctx.fillRect(0, cropArea.y, cropArea.x, cropArea.height);
            // Right
            ctx.fillRect(cropArea.x + cropArea.width, cropArea.y, canvas.width - cropArea.x - cropArea.width, cropArea.height);
        };
        img.src = currentImageData.dataUrl;
    }
}

function updateCropInfo() {
    const cropInfo = document.getElementById('cropInfo');
    if (cropInfo && cropArea) {
        const actualWidth = Math.round(cropArea.width * cropArea.scaleX);
        const actualHeight = Math.round(cropArea.height * cropArea.scaleY);
        cropInfo.textContent = `Selection: ${actualWidth}x${actualHeight}px`;
    }
}

function resetCrop() {
    if (cropArea) {
        const canvas = document.getElementById('cropCanvas');
        cropArea.x = 0;
        cropArea.y = 0;
        cropArea.width = canvas.width;
        cropArea.height = canvas.height;
        drawCropOverlay();
        updateCropInfo();
    }
}

function cropToSquare() {
    if (cropArea) {
        const canvas = document.getElementById('cropCanvas');
        const size = Math.min(canvas.width, canvas.height);
        cropArea.x = (canvas.width - size) / 2;
        cropArea.y = (canvas.height - size) / 2;
        cropArea.width = size;
        cropArea.height = size;
        drawCropOverlay();
        updateCropInfo();
    }
}

function cancelImagePreview() {
    document.getElementById('imagePreview').style.display = 'none';
    currentImageData = null;
    cropArea = null;
    
    // Reset file input
    const fileInput = document.getElementById('thumbnailFileInput');
    if (fileInput) fileInput.value = '';
}

function uploadSelectedImage() {
    if (!currentImageData || !currentArtistId) {
        showError('No image selected or artist not loaded');
        return;
    }
    
    // Show upload progress
    const progressDiv = document.getElementById('uploadProgress');
    const progressFill = document.getElementById('uploadProgressFill');
    const progressText = document.getElementById('uploadProgressText');
    
    progressDiv.style.display = 'block';
    progressFill.style.width = '0%';
    progressText.textContent = 'Uploading...';
    
    // Create FormData for upload
    const formData = new FormData();
    formData.append('thumbnail', currentImageData.file);
    
    fetch(`/api/artists/${currentArtistId}/thumbnail/upload`, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        progressFill.style.width = '50%';
        return response.json();
    })
    .then(data => {
        progressFill.style.width = '100%';
        
        if (data.success) {
            // Check if cropping is needed
            if (cropArea && (cropArea.x > 0 || cropArea.y > 0 || 
                cropArea.width < document.getElementById('cropCanvas').width || 
                cropArea.height < document.getElementById('cropCanvas').height)) {
                
                progressText.textContent = 'Applying crop...';
                
                // Calculate actual crop coordinates
                const actualCropBox = [
                    Math.round(cropArea.x * cropArea.scaleX),
                    Math.round(cropArea.y * cropArea.scaleY),
                    Math.round((cropArea.x + cropArea.width) * cropArea.scaleX),
                    Math.round((cropArea.y + cropArea.height) * cropArea.scaleY)
                ];
                
                // Apply crop
                return fetch(`/api/artists/${currentArtistId}/thumbnail/crop`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ crop_box: actualCropBox })
                })
                .then(response => response.json());
            } else {
                return data;
            }
        } else {
            throw new Error(data.error || 'Upload failed');
        }
    })
    .then(data => {
        if (data.success) {
            showSuccess(`Thumbnail uploaded successfully!`);
            cancelImagePreview();
            progressDiv.style.display = 'none';
            loadThumbnailInfo();
            
            // Refresh the main thumbnail display
            loadArtistDetails();
        } else {
            throw new Error(data.error || 'Processing failed');
        }
    })
    .catch(error => {
        console.error('Upload error:', error);
        showError(`Upload failed: ${error.message}`);
        progressDiv.style.display = 'none';
    });
}

// Upload tab switching
function switchUploadTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.upload-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.getElementById(tabName + 'UploadTab').classList.add('active');
    
    // Update panels
    document.querySelectorAll('.upload-panel').forEach(panel => {
        panel.classList.remove('active');
        panel.style.display = 'none';
    });
    document.getElementById(tabName + 'UploadPanel').classList.add('active');
    document.getElementById(tabName + 'UploadPanel').style.display = 'block';
}

// URL upload functions
function previewUrlImage() {
    const url = document.getElementById('thumbnailUrlInput').value.trim();
    if (!url) {
        showWarning('Please enter an image URL');
        return;
    }
    
    const preview = document.getElementById('urlPreview');
    const img = document.getElementById('urlPreviewImg');
    
    img.onload = () => {
        preview.style.display = 'block';
        showSuccess('Image loaded successfully');
    };
    
    img.onerror = () => {
        showError('Failed to load image from URL');
        preview.style.display = 'none';
    };
    
    img.src = url;
}

function uploadFromUrl() {
    const url = document.getElementById('thumbnailUrlInput').value.trim();
    if (!url) {
        showWarning('Please enter an image URL');
        return;
    }
    
    if (!currentArtistId) {
        showError('Artist not loaded');
        return;
    }
    
    // Use the existing thumbnail update endpoint
    fetch(`/api/artists/${currentArtistId}/thumbnail`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ thumbnail_url: url })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess('Thumbnail updated from URL!');
            document.getElementById('thumbnailUrlInput').value = '';
            document.getElementById('urlPreview').style.display = 'none';
            loadThumbnailInfo();
            loadArtistDetails();
        } else {
            showError(data.error || 'Failed to update thumbnail');
        }
    })
    .catch(error => {
        console.error('URL upload error:', error);
        showError('Failed to upload from URL');
    });
}

// Search functions
// Consolidated search function for all providers
function searchAllProviders() {
    if (!currentArtistId || !currentArtistData) {
        showError('Artist not loaded');
        return;
    }
    
    const resultsDiv = document.getElementById('searchResults');
    const gridDiv = document.getElementById('searchGrid');
    
    resultsDiv.style.display = 'block';
    gridDiv.innerHTML = '<div class="loading-placeholder">Searching IMVDb, Wikipedia, and Google Images...</div>';
    
    // Search all providers simultaneously
    const searchPromises = [
        // IMVDb and Wikipedia search
        fetch(`/api/artists/${currentArtistId}/thumbnail/search`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        }).then(response => response.json()),
        
        // Google Images search (simulated for now - would need proper API integration)
        searchGoogleImages(currentArtistData.name)
    ];
    
    Promise.allSettled(searchPromises)
    .then(results => {
        console.log('Search results:', results); // Debug logging
        const allResults = [];
        
        // Process IMVDb/Wikipedia/YouTube results
        if (results[0].status === 'fulfilled' && results[0].value.success && results[0].value.results) {
            // New API format returns multiple results
            allResults.push(...results[0].value.results);
            console.log('Added multi-source results:', results[0].value.results);
        } else if (results[0].status === 'fulfilled' && results[0].value.success && results[0].value.thumbnail_url) {
            // Backward compatibility: old API format with single result
            allResults.push({
                url: results[0].value.thumbnail_url,
                source: results[0].value.source || 'IMVDb/Wikipedia',
                quality: 'high'
            });
            console.log('Added single result:', results[0].value);
        } else if (results[0].status === 'fulfilled') {
            console.log('Multi-source search unsuccessful:', results[0].value);
        } else {
            console.log('Multi-source search failed:', results[0].reason);
        }
        
        // Process Google Images results
        if (results[1].status === 'fulfilled' && results[1].value.length > 0) {
            allResults.push(...results[1].value.slice(0, 10).map(img => ({
                url: img.url,
                source: 'Google Images',
                quality: img.quality || 'medium'
            })));
            console.log('Added Google Images results:', results[1].value.length);
        }
        
        if (allResults.length > 0) {
            gridDiv.innerHTML = allResults.map((result, index) => `
                <div class="search-result-item" onclick="selectSearchResult('${result.url}')">
                    <img src="${result.url}" alt="${result.source} result" 
                         onerror="this.parentElement.style.display='none'"
                         loading="lazy">
                    <div class="search-result-info">
                        <span class="source">${result.source}</span>
                        <span class="quality quality-${result.quality}">${result.quality.toUpperCase()}</span>
                        <button onclick="selectSearchResult('${result.url}')" class="btn btn-small btn-primary">Use This</button>
                    </div>
                </div>
            `).join('');
        } else {
            gridDiv.innerHTML = '<div class="no-results">No thumbnails found from any source</div>';
        }
    })
    .catch(error => {
        console.error('Search error:', error);
        gridDiv.innerHTML = '<div class="error-message">Search failed</div>';
        showError('Search failed: ' + error.message);
    });
}

// Simulated Google Images search (placeholder implementation)
function searchGoogleImages(artistName) {
    // This is a placeholder implementation since we can't directly access Google Images API
    // In a real implementation, this would use Google Custom Search API or similar service
    return new Promise((resolve) => {
        // Simulate search delay
        setTimeout(() => {
            // Generate some placeholder Google Images results
            const placeholderResults = [
                {
                    url: `https://via.placeholder.com/300x300/0066cc/ffffff?text=${encodeURIComponent(artistName)}+1`,
                    quality: 'high'
                },
                {
                    url: `https://via.placeholder.com/400x400/cc6600/ffffff?text=${encodeURIComponent(artistName)}+2`, 
                    quality: 'medium'
                },
                {
                    url: `https://via.placeholder.com/350x350/009966/ffffff?text=${encodeURIComponent(artistName)}+3`,
                    quality: 'high'
                }
            ];
            resolve(placeholderResults);
        }, 500);
    });
}

// Legacy function for backward compatibility
function searchThumbnailProvider(provider) {
    // Redirect to consolidated search
    searchAllProviders();
}

// Search for artist thumbnail during enrichment (no IMVDb per user requirements)
async function searchArtistThumbnail() {
    if (!currentArtistId || !currentArtistData) {
        throw new Error('Artist not loaded');
    }
    
    console.log('ðŸ” Searching for artist thumbnail using priority sources (Wikipedia, YouTube)...');
    
    try {
        // Call the artist thumbnail search endpoint (which now excludes IMVDb)
        const response = await fetch(`/api/artists/${currentArtistId}/thumbnail/search`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include'
        });
        
        if (!response.ok) {
            throw new Error(`Thumbnail search failed: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.success && data.results && data.results.length > 0) {
            // Use the first result (highest priority)
            const bestResult = data.results[0];
            console.log(`ðŸ” Found thumbnail from ${bestResult.source}: ${bestResult.url}`);
            
            // Upload the thumbnail from URL using the upload endpoint
            const uploadResponse = await fetch(`/api/artists/${currentArtistId}/thumbnail/upload`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    url: bestResult.url,
                    source: bestResult.source.toLowerCase(),
                    upload_type: 'url'
                }),
                credentials: 'include'
            });
            
            if (uploadResponse.ok) {
                const uploadData = await uploadResponse.json();
                if (uploadData.success) {
                    console.log(`âœ… Successfully uploaded thumbnail from ${bestResult.source}`);
                    // Update current artist data with new thumbnail
                    currentArtistData.thumbnail_url = uploadData.thumbnail_url;
                    return true;
                } else {
                    throw new Error(uploadData.error || 'Failed to upload thumbnail');
                }
            } else {
                throw new Error(`Thumbnail upload failed: ${uploadResponse.status}`);
            }
        } else {
            console.log('ðŸ” No thumbnails found from priority sources');
            return false;
        }
    } catch (error) {
        console.log(`ðŸ” Thumbnail search error: ${error.message}`);
        throw error;
    }
}

function selectSearchResult(url) {
    document.getElementById('thumbnailUrlInput').value = url;
    switchUploadTab('url');
    previewUrlImage();
}

// Thumbnail info and management
function loadThumbnailInfo() {
    if (!currentArtistId) return;
    
    fetch(`/api/artists/${currentArtistId}/thumbnail/info`)
    .then(response => response.json())
    .then(data => {
        updateThumbnailDisplay(data);
    })
    .catch(error => {
        console.error('Failed to load thumbnail info:', error);
    });
}

function updateThumbnailDisplay(info) {
    const thumbnailImg = document.getElementById('currentThumbnailImg');
    const placeholder = document.getElementById('noThumbnailPlaceholder');
    const overlay = document.getElementById('thumbnailOverlay');
    const metadata = document.getElementById('thumbnailMetadata');
    const sizesDiv = document.getElementById('thumbnailSizes');
    
    if (info.has_thumbnail && info.thumbnail_path) {
        // Show main thumbnail
        thumbnailImg.src = `/api/artists/${currentArtistId}/thumbnail/medium`;
        thumbnailImg.style.display = 'block';
        placeholder.style.display = 'none';
        overlay.style.display = 'block';
        
        // Update thumbnail info
        if (info.metadata) {
            document.getElementById('thumbnailSource').textContent = info.thumbnail_source || 'Unknown';
            document.getElementById('thumbnailUploaded').textContent = info.thumbnail_uploaded_at ? 
                new Date(info.thumbnail_uploaded_at).toLocaleString() : 'Unknown';
            document.getElementById('thumbnailSize').textContent = info.file_info ? 
                `${info.file_info.size[0]}x${info.file_info.size[1]}` : 'Unknown';
            document.getElementById('thumbnailFormat').textContent = info.file_info ? 
                info.file_info.format : 'Unknown';
            
            metadata.style.display = 'block';
            
            // Show size variants if available
            if (info.metadata.sizes) {
                Object.keys(info.metadata.sizes).forEach(size => {
                    const sizeImg = document.getElementById(`thumbnail${size.charAt(0).toUpperCase() + size.slice(1)}`);
                    if (sizeImg) {
                        sizeImg.src = `/api/artists/${currentArtistId}/thumbnail/${size}`;
                    }
                });
                sizesDiv.style.display = 'block';
            }
        }
    } else {
        // No thumbnail
        thumbnailImg.style.display = 'none';
        placeholder.style.display = 'block';
        overlay.style.display = 'none';
        metadata.style.display = 'none';
        sizesDiv.style.display = 'none';
    }
}

// Thumbnail actions
function cropThumbnail() {
    showInfo('Crop functionality: Upload a new image to crop it');
}

function replaceThumbnail() {
    switchUploadTab('manual');
    showInfo('Select a new image to replace the current thumbnail');
}

function deleteThumbnail() {
    if (!currentArtistId) return;
    
    toastConfirm('Are you sure you want to delete the current thumbnail?', () => {
        proceedDeleteThumbnail();
    });
}

function proceedDeleteThumbnail() {
    
    fetch(`/api/artists/${currentArtistId}/thumbnail`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ remove_thumbnail: true })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess('Thumbnail deleted successfully');
            loadThumbnailInfo();
            loadArtistDetails();
        } else {
            showError(data.error || 'Failed to delete thumbnail');
        }
    })
    .catch(error => {
        console.error('Delete error:', error);
        showError('Failed to delete thumbnail');
    });
}

function refreshThumbnailInfo() {
    loadThumbnailInfo();
    showInfo('Thumbnail information refreshed');
}

function showThumbnailStatistics() {
    fetch('/api/artists/thumbnail-stats')
    .then(response => response.json())
    .then(data => {
        const stats = data.storage;
        const dbStats = data.database;
        
        showInfo(`Storage: ${stats.total_files} files, ${stats.total_size_mb}MB. Coverage: ${dbStats.artists.coverage_percentage}% artists`);
    })
    .catch(error => {
        console.error('Stats error:', error);
        showError('Failed to load statistics');
    });
}

function exportThumbnail() {
    if (!currentArtistId) return;
    
    // Download the large version of the thumbnail
    const link = document.createElement('a');
    link.href = `/api/artists/${currentArtistId}/thumbnail/large`;
    link.download = `${(artistData && artistData.name) || 'artist'}_thumbnail.jpg`;
    link.click();
}

// Initialize when tab is shown
function showTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    document.getElementById(tabName + 'Tab').classList.add('active');
    
    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
    document.getElementById(tabName + 'Content').classList.add('active');
    
    activeTab = tabName;
    
    // Initialize thumbnail management when settings tab is shown
    if (tabName === 'settings') {
        setTimeout(initializeThumbnailManagement, 100);
    }
}

// Keyboard navigation support
document.addEventListener('keydown', function(event) {
    // Only handle navigation keys if not in an input field
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        return;
    }
    
    if (event.key === 'ArrowLeft' && navigationData && navigationData.next_artist) {
        event.preventDefault();
        navigateToPrevArtist();
    } else if (event.key === 'ArrowRight' && navigationData && navigationData.prev_artist) {
        event.preventDefault();
        navigateToNextArtist();
    }
    
    // Add event listeners for IMVDb ID controls
    const clearImvdbBtn = document.getElementById('clearImvdbId');
    const searchImvdbBtn = document.getElementById('searchImvdbId');
    
    if (clearImvdbBtn) {
        clearImvdbBtn.addEventListener('click', clearImvdbId);
    }
    
    if (searchImvdbBtn) {
        searchImvdbBtn.addEventListener('click', searchImvdbId);
    }
});

// Artist merge dialog function
function showMergeDialog(conflictData) {
    const existingArtist = conflictData.existing_artist;
    const currentArtist = conflictData.current_artist;
    
    // Create modal for merge confirmation
    const modal = document.createElement('div');
    modal.className = 'modal active';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3>IMVDb ID Conflict - Merge Artists?</h3>
                <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="conflict-warning">
                    <p><strong>âš ï¸ IMVDb ID ${existingArtist.imvdb_id} is already assigned to another artist.</strong></p>
                    <p>You can merge these artists or cancel the operation:</p>
                </div>
                
                <div class="artist-comparison">
                    <div class="artist-column">
                        <h4>Current Artist (Will be kept)</h4>
                        <div class="artist-info">
                            <strong>Name:</strong> ${currentArtist.name}<br>
                            <strong>ID:</strong> ${currentArtist.id}<br>
                            <strong>Videos:</strong> ${currentArtist.video_count || 0}<br>
                            <strong>Downloads:</strong> ${currentArtist.download_count || 0}
                        </div>
                    </div>
                    
                    <div class="merge-arrow">â†’</div>
                    
                    <div class="artist-column existing">
                        <h4>Existing Artist (Will be merged into current)</h4>
                        <div class="artist-info">
                            <strong>Name:</strong> ${existingArtist.name}<br>
                            <strong>ID:</strong> ${existingArtist.id}<br>
                            <strong>IMVDb ID:</strong> ${existingArtist.imvdb_id}<br>
                            <strong>Videos:</strong> ${existingArtist.video_count || 0}<br>
                            <strong>Downloads:</strong> ${existingArtist.download_count || 0}
                        </div>
                    </div>
                </div>
                
                <div class="merge-details">
                    <h4>What will happen during the merge:</h4>
                    <ul>
                        <li>All videos from "${existingArtist.name}" will be transferred to "${currentArtist.name}"</li>
                        <li>All downloads will be transferred</li>
                        <li>The IMVDb ID ${existingArtist.imvdb_id} will be assigned to "${currentArtist.name}"</li>
                        <li>Artist "${existingArtist.name}" will be deleted</li>
                        <li>Duplicate video titles will be handled intelligently</li>
                    </ul>
                </div>
                
                <div class="conflict-options">
                    <label>
                        <input type="radio" name="mergeOption" value="merge" checked>
                        <strong>Merge artists</strong> - Transfer all content and delete duplicate artist
                    </label>
                    <br><br>
                    <label>
                        <input type="radio" name="mergeOption" value="cancel">
                        <strong>Cancel</strong> - Don't change IMVDb ID, keep artists separate
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Cancel</button>
                <button class="btn btn-danger" onclick="executeMerge(${existingArtist.id}, ${currentArtist.id})">
                    ðŸ”€ Merge Artists
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Add CSS for the merge dialog
    const style = document.createElement('style');
    style.textContent = `
        .artist-comparison {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            align-items: center;
        }
        
        .artist-column {
            flex: 1;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #f9f9f9;
        }
        
        .artist-column.existing {
            border-color: #dc3545;
            background: #fff5f5;
        }
        
        .merge-arrow {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        
        .conflict-warning {
            padding: 15px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .merge-details {
            margin: 20px 0;
            padding: 15px;
            background: #e7f3ff;
            border-radius: 6px;
        }
        
        .conflict-options {
            margin: 20px 0;
        }
        
        .conflict-options label {
            display: block;
            margin: 10px 0;
            cursor: pointer;
        }
        
        .artist-info {
            font-size: 14px;
            line-height: 1.5;
        }
    `;
    document.head.appendChild(style);
}

// Bulk action functions for artist videos
function selectAllVideos() {
    const checkboxes = document.querySelectorAll('.video-checkbox');
    checkboxes.forEach(checkbox => {
        checkbox.checked = true;
        const videoId = checkbox.dataset.videoId;
        if (videoId) {
            selectedVideos.add(parseInt(videoId));
        }
    });
    updateSelectionUI();
}

function deselectAllVideos() {
    const checkboxes = document.querySelectorAll('.video-checkbox');
    checkboxes.forEach(checkbox => {
        checkbox.checked = false;
    });
    selectedVideos.clear();
    updateSelectionUI();
}

function bulkAddToPlaylist() {
    if (selectedVideos.size === 0) {
        showError('Please select videos to add to playlist');
        return;
    }
    
    // Show playlist modal directly on artist page
    showPlaylistModal();
}

function showPlaylistModal() {
    document.getElementById('playlistSelectedCount').textContent = selectedVideos.size;
    loadPlaylistsIntoSelect();
    document.getElementById('playlistModal').style.display = 'block';
}

function hidePlaylistModal() {
    document.getElementById('playlistModal').style.display = 'none';
    document.getElementById('newPlaylistName').value = '';
    document.getElementById('newPlaylistDescription').value = '';
}

async function loadPlaylistsIntoSelect() {
    const playlistSelect = document.getElementById('playlistSelect');
    
    try {
        const response = await fetch('/api/playlists/');
        const data = await response.json();
        
        if (data.playlists && data.playlists.length > 0) {
            playlistSelect.innerHTML = '<option value="">Select a playlist...</option>' +
                data.playlists.map(playlist => 
                    `<option value="${playlist.id}">${playlist.name} (${playlist.video_count || 0} videos)</option>`
                ).join('');
        } else {
            playlistSelect.innerHTML = '<option value="">No playlists available</option>';
        }
    } catch (error) {
        console.error('Error loading playlists:', error);
        playlistSelect.innerHTML = '<option value="">Error loading playlists</option>';
    }
}

async function addVideosToPlaylist() {
    const selectedPlaylist = document.getElementById('playlistSelect').value;
    const newPlaylistName = document.getElementById('newPlaylistName').value.trim();
    const newPlaylistDescription = document.getElementById('newPlaylistDescription').value.trim();
    
    if (!selectedPlaylist && !newPlaylistName) {
        showError('Please select a playlist or enter a new playlist name');
        return;
    }
    
    const videoIds = Array.from(selectedVideos);
    let playlistId = selectedPlaylist;
    
    try {
        // Create new playlist if name provided
        if (newPlaylistName && !selectedPlaylist) {
            const createResponse = await fetch('/api/playlists/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: newPlaylistName,
                    description: newPlaylistDescription
                })
            });
            
            const createData = await createResponse.json();
            if (!createResponse.ok) {
                throw new Error(createData.error || 'Failed to create playlist');
            }
            
            playlistId = createData.playlist.id;
            showSuccess(`Created new playlist: ${newPlaylistName}`);
        }
        
        // Add videos to playlist
        const addResponse = await fetch(`/api/playlists/${playlistId}/videos`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_ids: videoIds
            })
        });
        
        const addData = await addResponse.json();
        if (!addResponse.ok) {
            throw new Error(addData.error || 'Failed to add videos to playlist');
        }
        
        const playlistName = newPlaylistName || (document.getElementById('playlistSelect').selectedOptions[0] && document.getElementById('playlistSelect').selectedOptions[0].text.split(' (')[0]) || 'playlist';
        showSuccess(`Added ${videoIds.length} videos to ${playlistName}`);
        
        // Clear selection and hide modal
        selectedVideos.clear();
        updateSelectionUI();
        hidePlaylistModal();
        
    } catch (error) {
        console.error('Error adding videos to playlist:', error);
        showError(error.message || 'Failed to add videos to playlist');
    }
}

function bulkDownloadSelected() {
    if (selectedVideos.size === 0) {
        showError('Please select videos to download');
        return;
    }
    
    const videoIds = Array.from(selectedVideos);
    // Implement bulk download logic here
    showInfo(`Starting download for ${videoIds.length} selected videos...`);
}



function bulkDeleteSelected() {
    if (selectedVideos.size === 0) {
        showError('Please select videos to delete');
        return;
    }
    
    if (confirm(`Are you sure you want to delete ${selectedVideos.size} selected videos?`)) {
        const videoIds = Array.from(selectedVideos);
        // Implement bulk delete logic here
        showInfo(`Deleting ${videoIds.length} selected videos...`);
    }
}

function updateSelectionUI() {
    const count = selectedVideos.size;
    const bulkButtons = ['bulkDownloadBtn', 'bulkPlaylistBtn', 'bulkStatusBtn', 'bulkDeleteBtn'];
    
    bulkButtons.forEach(buttonId => {
        const button = document.getElementById(buttonId);
        if (button) {
            button.disabled = count === 0;
        }
    });
    
    const selectionInfo = document.getElementById('selectionInfo');
    const selectionCount = document.getElementById('selectionCount');
    
    if (selectionInfo && selectionCount) {
        if (count > 0) {
            selectionInfo.style.display = 'block';
            selectionCount.textContent = count;
        } else {
            selectionInfo.style.display = 'none';
        }
    }
}


function executeMerge(sourceArtistId, targetArtistId) {
    const selectedOption = document.querySelector('input[name="mergeOption"]:checked').value;
    
    if (selectedOption !== 'merge') {
        // User chose to cancel
        document.querySelector('.modal').remove();
        showInfo('IMVDb ID update cancelled');
        return;
    }
    
    // Show loading state
    const mergeBtn = event.target;
    const originalText = mergeBtn.textContent;
    mergeBtn.disabled = true;
    mergeBtn.textContent = 'ðŸ”„ Merging...';
    
    // Perform the merge
    fetch('/api/artists/merge', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            source_artist_id: sourceArtistId,
            target_artist_id: targetArtistId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showSuccess(`Successfully merged artists! ${data.transferred_videos} videos and ${data.transferred_downloads} downloads transferred.`);
            
            // Close modal and refresh page
            document.querySelector('.modal').remove();
            
            // Update current artist data with the merged data
            currentArtistData = { ...currentArtistData, ...data.updated_artist };
            
            // Refresh the entire page to show updated data
            loadArtistDetails();
            populateSettings(currentArtistData);
        } else {
            showError('Merge failed: ' + data.error);
        }
    })
    .catch(error => {
        console.error('Error merging artists:', error);
        showError('Error merging artists: ' + error.message);
    })
    .finally(() => {
        mergeBtn.disabled = false;
        mergeBtn.textContent = originalText;
    });
}

</script>

<!-- Delete Video Confirmation Modal -->
<div id="deleteVideoModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
        <div class="modal-header">
            <h3>ðŸ—‘ï¸ Delete Video</h3>
            <span class="modal-close" onclick="closeDeleteVideoModal()">&times;</span>
        </div>
        <div class="modal-body">
            <div class="delete-video-info">
                <p><strong>Are you sure you want to delete this video?</strong></p>
                <div class="video-details-preview">
                    <div class="detail-row">
                        <strong>Title:</strong> <span id="deleteVideoTitle"></span>
                    </div>
                    <div class="detail-row">
                        <strong>Artist:</strong> <span id="deleteVideoArtist"></span>
                    </div>
                    <div class="detail-row">
                        <strong>URL:</strong> <span id="deleteVideoUrl" class="url-preview"></span>
                    </div>
                </div>
            </div>
            
            <div id="deleteBlacklistGroup" class="blacklist-option-group">
                <div class="checkbox-container">
                    <label class="checkbox-label">
                        <input type="checkbox" id="deleteAddToBlacklist">
                        <span class="checkmark"></span>
                        <div class="checkbox-text">
                            <strong>Add to blacklist</strong>
                            <small>Prevent this URL from being downloaded again in the future</small>
                        </div>
                    </label>
                </div>
            </div>
            
            <div class="warning-section">
                <div class="warning-box">
                    <iconify-icon icon="tabler:alert-triangle"></iconify-icon>
                    <div>
                        <strong>Warning:</strong> This action cannot be undone. The video will be permanently removed from the database and all playlists.
                    </div>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button onclick="confirmDeleteVideo()" class="btn btn-danger" id="confirmDeleteBtn">
                <iconify-icon icon="tabler:trash"></iconify-icon>
                Delete Video
            </button>
            <button onclick="closeDeleteVideoModal()" class="btn btn-secondary">Cancel</button>
        </div>
    </div>
</div>
{% endblock %}