{% extends "base.html" %}

{% block title %}Videos - MVidarr{% endblock %}

{% block content %}
<!-- Performance Enhancement CSS - DISABLED: Causing loading issues
<link rel="stylesheet" href="{{ url_for('frontend.css_files', filename='ui-enhancements.css') }}">
<link rel="stylesheet" href="{{ url_for('frontend.css_files', filename='virtualization.css') }}">
-->
<div class="videos-container">
    
    <!-- Page Header with Improved Visual Hierarchy -->
    <div class="page-header">
        <div class="page-title-section">
            <h1 class="text-h1">Videos</h1>
        </div>
        
        <!-- Primary Actions - Most Important Operations -->
        <div class="action-group" role="group" aria-label="Primary video actions">
            <button onclick="showAddVideoModal()" class="btn btn-primary" aria-label="Add new video to collection">
                <iconify-icon icon="tabler:plus" aria-hidden="true"></iconify-icon>
                Add Video
            </button>
            <button onclick="toggleSearchPanel()" class="btn btn-secondary" aria-label="Toggle search and filter panel" aria-expanded="false" aria-controls="videoSearchPanel">
                <iconify-icon icon="tabler:search" aria-hidden="true"></iconify-icon>
                Search & Filter
            </button>
        </div>
    </div>
    
    <!-- Secondary Actions - Less Frequent Operations -->
    <div class="secondary-actions">
        <div class="action-group action-group-secondary" role="group" aria-label="Secondary video actions">
            <div class="btn-group" role="toolbar" aria-label="Video maintenance actions">
                <button onclick="refreshVideos()" class="btn btn-secondary btn-sm" title="Refresh video list" aria-label="Refresh video list">
                    <iconify-icon icon="tabler:refresh" aria-hidden="true"></iconify-icon>
                    Refresh
                </button>
                <button onclick="refreshThumbnails()" class="btn btn-secondary btn-sm" title="Find missing thumbnails" aria-label="Find and update missing thumbnails">
                    <iconify-icon icon="tabler:photo" aria-hidden="true"></iconify-icon>
                    Thumbnails
                </button>
                <button onclick="refreshAllMetadata()" class="btn btn-secondary btn-sm" title="Update video metadata" aria-label="Update all video metadata">
                    <iconify-icon icon="tabler:database-refresh" aria-hidden="true"></iconify-icon>
                    Metadata
                </button>
            </div>
            
            <!-- Selection Controls -->
            <div class="selection-controls" role="group" aria-label="Video selection controls">
                <label class="checkbox-label">
                    <input type="checkbox" id="selectAllVideos" onchange="toggleSelectAll()" aria-label="Select all videos" aria-describedby="selectedCount">
                    <span class="checkmark"></span>
                    Select All (<span id="selectedCount" aria-live="polite">0</span>)
                </label>
                <button onclick="toggleBulkActionsPanel()" class="btn btn-ghost btn-sm" id="bulkActionsToggle" aria-label="Toggle bulk actions panel" aria-expanded="false" aria-controls="bulkActionsPanel">
                    <iconify-icon icon="tabler:settings" aria-hidden="true"></iconify-icon>
                    Bulk Actions
                </button>
            </div>
        </div>
    </div>
    
    <!-- Advanced Search Panel -->
    <div class="advanced-search-panel" id="videoSearchPanel" style="display: none;" role="search" aria-label="Video search and filters">
        <div class="search-header">
            <div class="search-input-container">
                <input type="text" id="videoSearchInput" placeholder="Search videos, titles, artists, or descriptions..." onkeyup="handleVideoSearchInput(event)" aria-label="Search videos" aria-describedby="videoSearchSuggestions" autocomplete="off">
                <div class="search-suggestions" id="videoSearchSuggestions" role="listbox" aria-label="Search suggestions"></div>
            </div>
            <button onclick="toggleVideoAdvancedFilters()" class="btn btn-secondary" id="videoFiltersToggle" aria-label="Toggle advanced filters" aria-expanded="false" aria-controls="videoAdvancedFilters">
                <span>Filters</span> <span id="videoFilterCount" class="filter-count" aria-live="polite"></span>
            </button>
        </div>
        
        <div class="advanced-filters" id="videoAdvancedFilters" style="display: none;" role="group" aria-label="Advanced search filters">
            <div class="filter-row">
                <div class="filter-group">
                    <label for="videoStatusFilter">Status:</label>
                    <select id="videoStatusFilter" onchange="applyVideoFilters()" aria-label="Filter by video status">
                        <option value="">All Videos</option>
                        <option value="WANTED">Wanted</option>
                        <option value="DOWNLOADED">Downloaded</option>
                        <option value="FAILED">Failed</option>
                        <option value="IGNORED">Ignored</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="videoQualityFilter">Quality:</label>
                    <select id="videoQualityFilter" onchange="applyVideoFilters()" aria-label="Filter by video quality">
                        <option value="">Any Quality</option>
                        <option value="360p">360p</option>
                        <option value="480p">480p</option>
                        <option value="720p">720p (HD)</option>
                        <option value="1080p">1080p (Full HD)</option>
                        <option value="1440p">1440p (2K)</option>
                        <option value="2160p">2160p (4K)</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="videoThumbnailFilter">Thumbnails:</label>
                    <select id="videoThumbnailFilter" onchange="applyVideoFilters()">
                        <option value="">Any</option>
                        <option value="true">Has Thumbnail</option>
                        <option value="false">No Thumbnail</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="videoSourceFilter">Source:</label>
                    <select id="videoSourceFilter" onchange="applyVideoFilters()">
                        <option value="">Any Source</option>
                        <option value="youtube">YouTube</option>
                        <option value="external">External</option>
                        <option value="manual">Manual</option>
                    </select>
                </div>
                
                <div class="filter-group year-range-filter">
                    <label>Year Range:</label>
                    <div class="year-range-inputs">
                        <input type="number" id="videoYearFrom" placeholder="From" min="1950" max="2030" onchange="applyVideoFilters()" aria-label="Year from">
                        <span class="range-separator">to</span>
                        <input type="number" id="videoYearTo" placeholder="To" min="1950" max="2030" onchange="applyVideoFilters()" aria-label="Year to">
                    </div>
                </div>
                
                <div class="filter-group">
                    <label for="videoGenreFilter">Genre:</label>
                    <select id="videoGenreFilter" onchange="applyVideoFilters()">
                        <option value="">All Genres</option>
                        <!-- Genre options will be populated by JavaScript -->
                    </select>
                </div>
            </div>
            
            <div class="filter-row">
                <div class="filter-group">
                    <label for="videoDurationMin">Min Duration (seconds):</label>
                    <input type="number" id="videoDurationMin" min="0" placeholder="0" onchange="applyVideoFilters()">
                </div>
                
                <div class="filter-group">
                    <label for="videoDurationMax">Max Duration (seconds):</label>
                    <input type="number" id="videoDurationMax" min="0" placeholder="‚àû" onchange="applyVideoFilters()">
                </div>
                
                <div class="filter-group">
                    <label for="videoDateFrom">Added After:</label>
                    <input type="date" id="videoDateFrom" onchange="applyVideoFilters()">
                </div>
                
                <div class="filter-group">
                    <label for="videoDateTo">Added Before:</label>
                    <input type="date" id="videoDateTo" onchange="applyVideoFilters()">
                </div>
            </div>
            
            <div class="filter-row">
                <div class="filter-group">
                    <label for="videoArtistFilter">Artist:</label>
                    <input type="text" id="videoArtistFilter" placeholder="Filter by artist name..." oninput="debounceVideoFilters()">
                </div>
                
                <div class="filter-group">
                    <label for="videoKeywordsFilter">Keywords (comma-separated):</label>
                    <input type="text" id="videoKeywordsFilter" placeholder="Enter keywords..." oninput="debounceVideoFilters()">
                </div>
                
                <div class="filter-group">
                    <label for="videoSortBy">Sort By:</label>
                    <select id="videoSortBy" onchange="applyVideoFilters()">
                        <option value="title">Title</option>
                        <option value="artist">Artist</option>
                        <option value="date_added">Date Added</option>
                        <option value="status">Status</option>
                        <option value="quality">Quality</option>
                        <option value="duration">Duration</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="videoSortOrder">Sort Order:</label>
                    <select id="videoSortOrder" onchange="applyVideoFilters()">
                        <option value="asc">Ascending</option>
                        <option value="desc">Descending</option>
                    </select>
                </div>
            </div>
            
            <div class="filter-actions" role="toolbar" aria-label="Filter actions">
                <button onclick="clearAllVideoFilters()" class="btn btn-secondary" aria-label="Clear all active filters">Clear All</button>
                <button onclick="saveVideoSearchPreset()" class="btn btn-secondary" aria-label="Save current search as preset">Save Preset</button>
                <button onclick="exportVideoSearchResults()" class="btn btn-info" aria-label="Export search results to file">Export Results</button>
            </div>
        </div>
        
        <div class="search-results-info" id="videoResultsInfo" role="status" aria-live="polite">
            <span id="videoResultsCount">Select filters to search videos</span>
        </div>
    </div>
    
    <!-- Streamlined Bulk Actions Panel -->
    <div id="bulkActionsPanel" class="bulk-actions-panel streamlined" style="display: none;" role="dialog" aria-labelledby="bulkActionsTitle" aria-hidden="true">
        <div class="bulk-actions-header">
            <h3 id="bulkActionsTitle">Bulk Operations</h3>
            <button class="bulk-actions-close" onclick="closeBulkActionsPanel()" aria-label="Close bulk actions panel">&times;</button>
        </div>
        <div class="bulk-actions-content">
            <!-- Streamlined Essential Actions Grid -->
            <div class="bulk-actions-grid">
                <button onclick="bulkDownloadSelected()" class="bulk-btn-compact btn-primary" id="bulkDownloadBtn" disabled>
                    <iconify-icon icon="tabler:download"></iconify-icon>
                    <span>Download</span>
                </button>
                
                <button onclick="bulkSetStatus('WANTED')" class="bulk-btn-compact btn-info" id="bulkWantedBtn" disabled>
                    <iconify-icon icon="tabler:star"></iconify-icon>
                    <span>Mark Wanted</span>
                </button>
                
                <button onclick="bulkSetStatus('IGNORED')" class="bulk-btn-compact btn-secondary" id="bulkIgnoreBtn" disabled>
                    <iconify-icon icon="tabler:x"></iconify-icon>
                    <span>Ignore</span>
                </button>
                
                <button onclick="showBulkAddToPlaylistModal()" class="bulk-btn-compact btn-success" id="bulkAddToPlaylistBtn" disabled>
                    <iconify-icon icon="tabler:playlist-add"></iconify-icon>
                    <span>Add to Playlist</span>
                </button>
                
                <button onclick="bulkRefreshMetadata()" class="bulk-btn-compact btn-info" id="bulkRefreshMetadataBtn" disabled>
                    <iconify-icon icon="tabler:refresh"></iconify-icon>
                    <span>Refresh Metadata</span>
                </button>
                
                <button onclick="bulkDeleteSelected()" class="bulk-btn-compact btn-danger" id="bulkDeleteBtn" disabled>
                    <iconify-icon icon="tabler:trash"></iconify-icon>
                    <span>Delete</span>
                </button>
                
                <!-- Quick Edit Section -->
                <div class="bulk-quick-edit">
                    <input type="text" id="bulkArtistChange" placeholder="Change artist..." class="bulk-input-compact">
                    <input type="number" id="bulkYearChange" placeholder="Year" min="1950" max="2030" class="bulk-input-compact">
                    <button onclick="applyBulkEdit()" class="bulk-btn-compact btn-primary" id="bulkEditApplyBtn" disabled>
                        <iconify-icon icon="tabler:check"></iconify-icon>
                        <span>Apply</span>
                    </button>
                </div>
            </div>
            
            <!-- Bulk Progress Indicator -->
            <div id="bulkProgress" class="bulk-progress" style="display: none;">
                <div class="progress-bar">
                    <div id="bulkProgressFill" class="progress-fill"></div>
                </div>
                <div id="bulkProgressText" class="progress-text">Ready</div>
            </div>
            
            <div class="bulk-actions-footer">
                <div class="selected-count" id="bulkSelectedCount">0 videos selected</div>
                <div class="bulk-actions-controls">
                    <button onclick="selectAllVideos()" class="btn btn-outline btn-sm">Select All</button>
                    <button onclick="clearSelection()" class="btn btn-outline btn-sm">Clear</button>
                    <button onclick="closeBulkActionsPanel()" class="btn btn-secondary btn-sm">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Pagination Controls Top -->
    <div class="pagination-container top-pagination" id="topPagination" style="display: none;">
        <div class="pagination-info">
            <span id="videoCountInfo">Loading...</span>
        </div>
        <div class="pagination-controls">
            <button class="btn btn-secondary pagination-btn" id="prevPageTop" onclick="previousPage()" disabled>
                ‚Üê Previous
            </button>
            <div class="page-selector">
                <span>Page </span>
                <input type="number" id="pageInputTop" class="page-input" min="1" value="1" onchange="goToPage(this.value)">
                <span> of <span id="totalPagesTop">1</span></span>
            </div>
            <button class="btn btn-secondary pagination-btn" id="nextPageTop" onclick="nextPage()" disabled>
                Next ‚Üí
            </button>
        </div>
        <div class="page-size-selector">
            <label for="pageSizeSelect">Videos per page:</label>
            <select id="pageSizeSelect" onchange="changePageSize(this.value)">
                <option value="25">25</option>
                <option value="50" selected>50</option>
                <option value="100">100</option>
                <option value="200">200</option>
            </select>
        </div>
    </div>

    <div class="videos-grid" id="videos-grid">
        <div class="empty-state">
            <p>No videos loaded yet. Use filters above or <button onclick="loadVideos()" class="btn-link">load all videos</button>.</p>
        </div>
    </div>

    <!-- Pagination Controls Bottom -->
    <div class="pagination-container bottom-pagination" id="bottomPagination" style="display: none;">
        <div class="pagination-info">
            <span id="videoCountInfoBottom">Loading...</span>
        </div>
        <div class="pagination-controls">
            <button class="btn btn-secondary pagination-btn" id="prevPageBottom" onclick="previousPage()" disabled>
                ‚Üê Previous
            </button>
            <div class="page-selector">
                <span>Page </span>
                <input type="number" id="pageInputBottom" class="page-input" min="1" value="1" onchange="goToPage(this.value)">
                <span> of <span id="totalPagesBottom">1</span></span>
            </div>
            <button class="btn btn-secondary pagination-btn" id="nextPageBottom" onclick="nextPage()" disabled>
                Next ‚Üí
            </button>
        </div>
        <div class="page-size-selector">
            <span>Videos per page: <span id="currentPageSize">50</span></span>
        </div>
    </div>
</div>

<!-- Video Player Modal -->
<div id="videoModal" class="video-modal">
    <div class="video-modal-content">
        <div class="video-modal-header">
            <h3 id="videoModalTitle">Playing Video</h3>
            <span class="video-modal-close" onclick="closeVideoModal()">&times;</span>
        </div>
        <div class="video-modal-body">
            <div id="videoPlayer"></div>
        </div>
    </div>
</div>

<!-- Edit Video Modal -->
<div id="editVideoModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Edit Video Metadata</h3>
            <span class="modal-close" onclick="closeEditVideoModal()">&times;</span>
        </div>
        <div class="modal-body">
            <form id="editVideoForm">
                <div class="form-group">
                    <label for="videoTitle">Video Title:</label>
                    <input type="text" id="videoTitle" name="title" required>
                </div>
                
                <div class="form-group">
                    <label for="videoArtist">Artist Name:</label>
                    <div class="artist-input-container">
                        <input type="text" id="videoArtist" name="artist_name" required>
                        <button type="button" id="identifyArtistBtn" class="btn btn-secondary btn-small" onclick="identifyArtist()" style="margin-left: 10px;">
                            üîç Identify Artist
                        </button>
                        <div id="artistSuggestions" class="artist-suggestions" style="display: none;">
                            <!-- Artist suggestions will be populated here -->
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="videoYear">Year:</label>
                    <input type="number" id="videoYear" name="year" min="1900" max="2030">
                </div>
                
                <div class="form-group">
                    <label for="videoGenre">Genre:</label>
                    <input type="text" id="videoGenre" name="genre" placeholder="Rock, Pop, Hip-Hop, etc.">
                </div>
                
                <div class="form-group">
                    <label for="videoStatus">Status:</label>
                    <select id="videoStatus" name="status">
                        <option value="DOWNLOADED">Downloaded</option>
                        <option value="WANTED">Wanted</option>
                        <option value="IGNORED">Ignored</option>
                        <option value="FAILED">Failed</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="videoUrl">Video URL:</label>
                    <input type="url" id="videoUrl" name="video_url" placeholder="https://youtube.com/watch?v=...">
                </div>
                
                <div class="form-group">
                    <label for="videoThumbnailUrl">Thumbnail URL:</label>
                    <input type="url" id="videoThumbnailUrl" name="thumbnail_url">
                    <button type="button" onclick="openVideoThumbnailManager()" class="btn btn-info btn-small" style="margin-top: 5px;">
                        üñºÔ∏è Manage Thumbnail
                    </button>
                </div>
                
                <div class="form-group">
                    <label for="videoDuration">Duration (seconds):</label>
                    <input type="number" id="videoDuration" name="duration" min="0">
                </div>
                
                <div class="form-group">
                    <label for="videoImvdbId">IMVDb ID:</label>
                    <input type="text" id="videoImvdbId" name="imvdb_id">
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="moveFile" name="move_file" checked>
                        Move/rename file if artist or title changes
                    </label>
                </div>
                
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Save Changes</button>
                    <button type="button" class="btn btn-secondary" onclick="closeEditVideoModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>



<script>
// Global function definitions for immediate availability
window.toggleSearchPanel = window.toggleSearchPanel || function() {
    const searchPanel = document.getElementById('videoSearchPanel');
    if (searchPanel) {
        const isVisible = searchPanel.style.display !== 'none';
        searchPanel.style.display = isVisible ? 'none' : 'block';
        
        // Focus on search input when panel is shown
        if (!isVisible) {
            const searchInput = document.getElementById('videoSearchInput');
            if (searchInput) {
                setTimeout(() => searchInput.focus(), 100);
            }
        }
    }
};

window.handleSearchKeyup = window.handleSearchKeyup || function(event) {
    // Handle Enter key to trigger search
    if (event.key === 'Enter') {
        if (typeof applyVideoFilters === 'function') {
            applyVideoFilters();
        }
    }
    // Could add more keyup handling here (like auto-search after delay)
};


// Enhanced error handling with categorization and actionable guidance
function showEnhancedError(error, context = '') {
    const errorInfo = categorizeError(error, context);
    showToast(errorInfo.message, 'error');
    
    // Log detailed error for debugging
    console.error(`[${errorInfo.category}] ${context}:`, error);
    
    // Show additional guidance if available
    if (errorInfo.guidance) {
        setTimeout(() => {
            showToast(errorInfo.guidance, 'info');
        }, 2000);
    }
}

function categorizeError(error, context) {
    const errorMessage = error.message || error.toString();
    const errorName = error.name || 'Error';
    
    // Network errors
    if (errorName === 'TypeError' && errorMessage.includes('fetch')) {
        return {
            category: 'Network',
            message: 'üåê Connection failed. Please check your internet connection.',
            guidance: 'Try refreshing the page or check if the server is running.'
        };
    }
    
    if (errorMessage.includes('HTTP error') || errorMessage.includes('status')) {
        const statusMatch = errorMessage.match(/(\d{3})/);
        const status = statusMatch ? statusMatch[1] : 'unknown';
        
        switch (status) {
            case '404':
                return {
                    category: 'NotFound',
                    message: 'üìÑ Resource not found. The video or data may have been moved or deleted.',
                    guidance: 'Try refreshing the page or check if the video still exists.'
                };
            case '500':
                return {
                    category: 'ServerError',
                    message: 'üîß Server error occurred. This is likely temporary.',
                    guidance: 'Please try again in a moment. If it persists, contact support.'
                };
            case '403':
                return {
                    category: 'Permission',
                    message: 'üîí Access denied. You may not have permission for this action.',
                    guidance: 'Check your user role or try logging out and back in.'
                };
            default:
                return {
                    category: 'ServerError',
                    message: `üö´ Server responded with error (${status}). Please try again.`,
                    guidance: 'If this continues, the issue may be temporary.'
                };
        }
    }
    
    // File system errors
    if (errorMessage.includes('local_path') || errorMessage.includes('file not found')) {
        return {
            category: 'FileSystem',
            message: 'üìÅ Video file not found. The file may have been moved or deleted.',
            guidance: 'Try reorganizing files or check the Downloads page for file status.'
        };
    }
    
    // Validation errors
    if (context.includes('validation') || errorMessage.includes('invalid') || errorMessage.includes('required')) {
        return {
            category: 'Validation',
            message: '‚ö†Ô∏è Invalid input provided. Please check your entries.',
            guidance: 'Make sure all required fields are filled and formats are correct.'
        };
    }
    
    // Timeout errors
    if (errorMessage.includes('timeout') || errorMessage.includes('abort')) {
        return {
            category: 'Timeout',
            message: '‚è±Ô∏è Operation timed out. The server may be busy.',
            guidance: 'Try again with smaller batches or during off-peak hours.'
        };
    }
    
    // Parsing errors
    if (errorMessage.includes('JSON') || errorMessage.includes('parse') || errorMessage.includes('Invalid response format')) {
        return {
            category: 'DataFormat',
            message: 'üìä Invalid data format received from server.',
            guidance: 'This may indicate a server issue. Please refresh and try again.'
        };
    }
    
    // Generic fallback
    return {
        category: 'Generic',
        message: `‚ùå An error occurred${context ? ` while ${context}` : ''}. Please try again.`,
        guidance: 'If the problem persists, try refreshing the page or contact support.'
    };
}

// Debouncing utility for performance optimization
let filterDebounceTimer = null;

function debounceVideoFilters() {
    clearTimeout(filterDebounceTimer);
    filterDebounceTimer = setTimeout(() => {
        applyVideoFilters();
    }, 300); // 300ms delay
}

// Video filtering functions - previously missing
function applyVideoFilters() {
    console.log('Applying video filters...');
    
    // Get all filter values
    const filters = {
        status: document.getElementById('videoStatusFilter').value,
        quality: document.getElementById('videoQualityFilter').value,
        has_thumbnail: document.getElementById('videoThumbnailFilter').value,
        source: document.getElementById('videoSourceFilter').value,
        genre: document.getElementById('videoGenreFilter').value,
        duration_min: document.getElementById('videoDurationMin').value,
        duration_max: document.getElementById('videoDurationMax').value,
        date_from: document.getElementById('videoDateFrom').value,
        date_to: document.getElementById('videoDateTo').value,
        year_from: document.getElementById('videoYearFrom').value,
        year_to: document.getElementById('videoYearTo').value,
        artist: document.getElementById('videoArtistFilter').value,
        keywords: document.getElementById('videoKeywordsFilter').value,
        sort_by: document.getElementById('videoSortBy').value,
        sort_order: document.getElementById('videoSortOrder').value
    };
    
    // Build query parameters
    const params = new URLSearchParams();
    
    // Add non-empty filters
    for (const [key, value] of Object.entries(filters)) {
        if (value && value.trim() !== '') {
            params.append(key, value);
        }
    }
    
    // Make API call to search/filter videos
    fetch(`/api/videos/search?${params.toString()}`)
        .then(response => response.json())
        .then(data => {
            displaySearchResults(data);
            updateVideoFilterCount();
        })
        .catch(error => {
            showEnhancedError(error, 'filtering videos');
        });
}

function displaySearchResults(data) {
    const grid = document.getElementById('videos-grid');
    
    if (data.videos && data.videos.length > 0) {
        grid.innerHTML = data.videos.map(video => `
            <div class="video-card">
                <div class="video-select">
                    <input type="checkbox" class="video-checkbox" value="${video.id}" onchange="updateSelectedCount()">
                </div>
                <div class="video-thumbnail" data-video-id="${video.id}" data-action="play">
                    <img src="/api/videos/${video.id}/thumbnail" 
                         alt="${video.title}" onerror="this.src='/static/placeholder-video.png'">
                    <div class="play-overlay">
                        <div class="play-button">‚ñ∂</div>
                    </div>
                </div>
                <div class="video-info">
                    <h3>${video.title}</h3>
                    <p>Artist: ${video.artist_name || 'Unknown'}</p>
                    <p>Status: ${video.status}</p>
                    ${video.year ? `<p>Year: ${video.year}</p>` : ''}
                </div>
                <div class="video-actions">
                    <button data-video-id="${video.id}" data-action="view" class="btn-icon" title="View Details">
                        <iconify-icon icon="tabler:eye"></iconify-icon>
                    </button>
                    <button data-video-id="${video.id}" data-action="edit" class="btn-icon" title="Edit Video">
                        <iconify-icon icon="tabler:edit"></iconify-icon>
                    </button>
                    <button data-video-id="${video.id}" data-action="refresh-metadata" class="btn-icon" title="Refresh Metadata">
                        <iconify-icon icon="tabler:refresh"></iconify-icon>
                    </button>
                    ${video.status === 'WANTED' ? 
                        `<button data-video-id="${video.id}" data-action="download" class="btn-icon" title="Download Video">
                            <iconify-icon icon="tabler:download"></iconify-icon>
                        </button>` : 
                        ''}
                    <button data-video-id="${video.id}" data-action="delete" class="btn-icon btn-danger" title="Delete Video">
                        <iconify-icon icon="tabler:trash"></iconify-icon>
                    </button>
                </div>
            </div>
        `).join('');
    } else {
        grid.innerHTML = '<p>No videos found matching your search criteria.</p>';
    }
    
    // Update pagination controls with filtered results
    updatePagination(data);
}

function toggleVideoAdvancedFilters() {
    const filters = document.getElementById('videoAdvancedFilters');
    const button = document.getElementById('videoFiltersToggle');
    
    if (filters.style.display === 'none') {
        filters.style.display = 'block';
        button.textContent = 'Hide Filters';
    } else {
        filters.style.display = 'none';
        button.textContent = 'Show Filters';
    }
}

function clearAllVideoFilters() {
    // Clear all filter inputs
    document.getElementById('videoStatusFilter').value = '';
    document.getElementById('videoQualityFilter').value = '';
    document.getElementById('videoThumbnailFilter').value = '';
    document.getElementById('videoSourceFilter').value = '';
    document.getElementById('videoGenreFilter').value = '';
    document.getElementById('videoDurationMin').value = '';
    document.getElementById('videoDurationMax').value = '';
    document.getElementById('videoDateFrom').value = '';
    document.getElementById('videoDateTo').value = '';
    document.getElementById('videoYearFrom').value = '';
    document.getElementById('videoYearTo').value = '';
    document.getElementById('videoArtistFilter').value = '';
    document.getElementById('videoKeywordsFilter').value = '';
    document.getElementById('videoSortBy').value = 'title';
    document.getElementById('videoSortOrder').value = 'asc';
    
    // Reload all videos
    searchActive = false;
    loadVideos();
    updateVideoFilterCount();
}

function updateVideoFilterCount() {
    const filterCount = document.getElementById('videoFilterCount');
    if (!filterCount) {
        // Element may not be accessible if search panel is hidden, this is normal
        return;
    }
    
    let activeFilters = 0;
    
    // Count active filters
    const filterElements = [
        'videoStatusFilter', 'videoQualityFilter', 'videoThumbnailFilter',
        'videoSourceFilter', 'videoGenreFilter', 'videoDurationMin', 'videoDurationMax',
        'videoDateFrom', 'videoDateTo', 'videoYearFrom', 'videoYearTo',
        'videoArtistFilter', 'videoKeywordsFilter'
    ];
    
    filterElements.forEach(id => {
        const element = document.getElementById(id);
        if (element && element.value && element.value.trim() !== '') {
            activeFilters++;
        }
    });
    
    if (activeFilters > 0) {
        filterCount.textContent = activeFilters;
        filterCount.style.display = 'inline';
    } else {
        filterCount.style.display = 'none';
    }
}

function loadVideoGenreOptions() {
    // Load available genres from the API
    fetch('/api/genres')
        .then(response => response.json())
        .then(data => {
            const genreSelect = document.getElementById('videoGenreFilter');
            if (data.video_genres && data.video_genres.length > 0) {
                // Clear existing options (except the first "All Genres" option)
                genreSelect.innerHTML = '<option value="">All Genres</option>';
                
                // Add each genre as an option
                data.video_genres.forEach(genre => {
                    const option = document.createElement('option');
                    option.value = genre;
                    option.textContent = genre;
                    genreSelect.appendChild(option);
                });
            }
        })
        .catch(error => {
            console.error('Error loading video genres:', error);
        });
}

// Search Presets Management
function saveVideoSearchPreset() {
    const currentFilters = {
        status: document.getElementById('videoStatusFilter').value,
        quality: document.getElementById('videoQualityFilter').value,
        has_thumbnail: document.getElementById('videoThumbnailFilter').value,
        source: document.getElementById('videoSourceFilter').value,
        genre: document.getElementById('videoGenreFilter').value,
        duration_min: document.getElementById('videoDurationMin').value,
        duration_max: document.getElementById('videoDurationMax').value,
        date_from: document.getElementById('videoDateFrom').value,
        date_to: document.getElementById('videoDateTo').value,
        artist: document.getElementById('videoArtistFilter').value,
        keywords: document.getElementById('videoKeywordsFilter').value,
        sort_by: document.getElementById('videoSortBy').value,
        sort_order: document.getElementById('videoSortOrder').value
    };
    
    // Check if any filters are active
    const hasActiveFilters = Object.values(currentFilters).some(value => value && value.trim() !== '');
    
    if (!hasActiveFilters) {
        showToast('No active filters to save as preset', 'warning');
        return;
    }
    
    // Prompt for preset name
    const presetName = prompt('Enter a name for this search preset:');
    
    if (!presetName || !presetName.trim()) {
        showToast('Preset name is required', 'warning');
        return;
    }
    
    try {
        // Get existing presets from localStorage
        const existingPresets = JSON.parse(localStorage.getItem('videoSearchPresets') || '{}');
        
        // Add new preset
        existingPresets[presetName.trim()] = {
            filters: currentFilters,
            created: new Date().toISOString(),
            description: generatePresetDescription(currentFilters)
        };
        
        // Save to localStorage
        localStorage.setItem('videoSearchPresets', JSON.stringify(existingPresets));
        
        showToast(`Search preset "${presetName}" saved successfully!`, 'success');
        updateSearchPresetsUI();
        
    } catch (error) {
        console.error('Error saving search preset:', error);
        showToast('Error saving search preset', 'error');
    }
}

function generatePresetDescription(filters) {
    const activeFilters = [];
    
    if (filters.status) activeFilters.push(`Status: ${filters.status}`);
    if (filters.quality) activeFilters.push(`Quality: ${filters.quality}`);
    if (filters.genre) activeFilters.push(`Genre: ${filters.genre}`);
    if (filters.artist) activeFilters.push(`Artist: ${filters.artist}`);
    if (filters.keywords) activeFilters.push(`Keywords: ${filters.keywords}`);
    if (filters.source) activeFilters.push(`Source: ${filters.source}`);
    if (filters.duration_min || filters.duration_max) {
        const durationText = `Duration: ${filters.duration_min || '0'} - ${filters.duration_max || '‚àû'} mins`;
        activeFilters.push(durationText);
    }
    if (filters.date_from || filters.date_to) {
        const dateText = `Date: ${filters.date_from || 'Any'} to ${filters.date_to || 'Any'}`;
        activeFilters.push(dateText);
    }
    
    return activeFilters.length > 0 ? activeFilters.join(', ') : 'Custom filter preset';
}

function loadVideoSearchPreset(presetName) {
    try {
        const presets = JSON.parse(localStorage.getItem('videoSearchPresets') || '{}');
        const preset = presets[presetName];
        
        if (!preset) {
            showToast('Search preset not found', 'error');
            return;
        }
        
        // Apply all filter values
        const filters = preset.filters;
        
        document.getElementById('videoStatusFilter').value = filters.status || '';
        document.getElementById('videoQualityFilter').value = filters.quality || '';
        document.getElementById('videoThumbnailFilter').value = filters.has_thumbnail || '';
        document.getElementById('videoSourceFilter').value = filters.source || '';
        document.getElementById('videoGenreFilter').value = filters.genre || '';
        document.getElementById('videoDurationMin').value = filters.duration_min || '';
        document.getElementById('videoDurationMax').value = filters.duration_max || '';
        document.getElementById('videoDateFrom').value = filters.date_from || '';
        document.getElementById('videoDateTo').value = filters.date_to || '';
        document.getElementById('videoArtistFilter').value = filters.artist || '';
        document.getElementById('videoKeywordsFilter').value = filters.keywords || '';
        document.getElementById('videoSortBy').value = filters.sort_by || 'title';
        document.getElementById('videoSortOrder').value = filters.sort_order || 'asc';
        
        // Apply the filters
        applyVideoFilters();
        
        showToast(`Search preset "${presetName}" loaded successfully!`, 'success');
        
    } catch (error) {
        console.error('Error loading search preset:', error);
        showToast('Error loading search preset', 'error');
    }
}

function deleteVideoSearchPreset(presetName) {
    if (!confirm(`Are you sure you want to delete the preset "${presetName}"?`)) {
        return;
    }
    
    try {
        const presets = JSON.parse(localStorage.getItem('videoSearchPresets') || '{}');
        delete presets[presetName];
        localStorage.setItem('videoSearchPresets', JSON.stringify(presets));
        
        showToast(`Search preset "${presetName}" deleted`, 'success');
        updateSearchPresetsUI();
        
    } catch (error) {
        console.error('Error deleting search preset:', error);
        showToast('Error deleting search preset', 'error');
    }
}

function updateSearchPresetsUI() {
    // Create presets dropdown if it doesn't exist
    let presetsContainer = document.getElementById('searchPresetsContainer');
    
    if (!presetsContainer) {
        // Add presets container to the filter actions area
        const filterActions = document.querySelector('.filter-actions');
        if (filterActions) {
            presetsContainer = document.createElement('div');
            presetsContainer.id = 'searchPresetsContainer';
            presetsContainer.className = 'search-presets-container';
            presetsContainer.style.marginLeft = '10px';
            presetsContainer.style.display = 'inline-block';
            
            filterActions.appendChild(presetsContainer);
        }
    }
    
    if (!presetsContainer) return;
    
    try {
        const presets = JSON.parse(localStorage.getItem('videoSearchPresets') || '{}');
        const presetNames = Object.keys(presets);
        
        if (presetNames.length === 0) {
            presetsContainer.innerHTML = '';
            return;
        }
        
        presetsContainer.innerHTML = `
            <select id="searchPresetSelect" class="form-control" style="width: auto; display: inline-block; margin-right: 5px;">
                <option value="">Select Preset...</option>
                ${presetNames.map(name => `
                    <option value="${name}" title="${presets[name].description}">
                        ${name} (${new Date(presets[name].created).toLocaleDateString()})
                    </option>
                `).join('')}
            </select>
            <button onclick="loadSelectedPreset()" class="btn btn-primary btn-sm" title="Load selected preset">
                üìÅ Load
            </button>
            <button onclick="deleteSelectedPreset()" class="btn btn-danger btn-sm" title="Delete selected preset">
                üóëÔ∏è Delete
            </button>
            <button onclick="exportSearchPresets()" class="btn btn-info btn-sm" title="Export all presets">
                üì§ Export
            </button>
        `;
        
    } catch (error) {
        console.error('Error updating search presets UI:', error);
    }
}

function loadSelectedPreset() {
    const select = document.getElementById('searchPresetSelect');
    if (!select || !select.value) {
        showToast('Please select a preset to load', 'warning');
        return;
    }
    
    loadVideoSearchPreset(select.value);
}

function deleteSelectedPreset() {
    const select = document.getElementById('searchPresetSelect');
    if (!select || !select.value) {
        showToast('Please select a preset to delete', 'warning');
        return;
    }
    
    deleteVideoSearchPreset(select.value);
}

function exportSearchPresets() {
    try {
        const presets = JSON.parse(localStorage.getItem('videoSearchPresets') || '{}');
        const presetNames = Object.keys(presets);
        
        if (presetNames.length === 0) {
            showToast('No search presets to export', 'warning');
            return;
        }
        
        const exportData = {
            version: '1.0',
            exported: new Date().toISOString(),
            presets: presets
        };
        
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `mvidarr-search-presets-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showToast(`Exported ${presetNames.length} search presets`, 'success');
        
    } catch (error) {
        console.error('Error exporting search presets:', error);
        showToast('Error exporting search presets', 'error');
    }
}

// Initialize search presets UI when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Delay to ensure other elements are loaded
    setTimeout(updateSearchPresetsUI, 1000);
});

function exportVideoSearchResults() {
    showInfo('Video search results export functionality coming soon!');
}

function refreshThumbnails() {
    const selectedVideoIds = getSelectedVideoIds();
    const isSelectedVideos = selectedVideoIds.length > 0;
    const message = isSelectedVideos 
        ? `Download thumbnails for ${selectedVideoIds.length} selected videos that are missing them?`
        : 'Download thumbnails for all videos that are missing them?';
        
    toastConfirm(message, () => {
        const requestBody = isSelectedVideos ? { video_ids: selectedVideoIds } : {};
        
        fetch('/api/videos/refresh-thumbnails', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        })
        .then(response => response.json())
        .then(result => {
            if (result.error) {
                showError('Error: ' + result.error);
            } else {
                showSuccess(result.message);
                loadVideos(); // Refresh the video list
            }
        })
        .catch(error => {
            console.error('Error refreshing thumbnails:', error);
            showError('Error refreshing thumbnails');
        });
    });
}

function viewVideo(id) {
    // Navigate to video detail page
    window.location.href = `/video/${id}`;
}

function editVideo(id) {
    // Fetch video data and populate the edit form
    fetch(`/api/videos/${id}`)
        .then(response => response.json())
        .then(video => {
            if (video.error) {
                showError('Error loading video data: ' + video.error);
                return;
            }
            
            // Populate the form with current video data
            document.getElementById('videoTitle').value = video.title || '';
            document.getElementById('videoArtist').value = video.artist_name || '';
            document.getElementById('videoYear').value = video.year || '';
            document.getElementById('videoGenre').value = (video.genres && video.genres.length > 0) ? video.genres[0] : '';
            document.getElementById('videoStatus').value = video.status || 'DOWNLOADED';
            document.getElementById('videoUrl').value = video.video_url || '';
            document.getElementById('videoThumbnailUrl').value = video.thumbnail_url || '';
            document.getElementById('videoDuration').value = video.duration || '';
            document.getElementById('videoImvdbId').value = video.imvdb_id || '';
            document.getElementById('moveFile').checked = true;
            
            // Store the current video ID for the form submission
            window.currentEditVideoId = id;
            
            // Reset the identify artist button and hide suggestions
            resetIdentifyArtistButton();
            document.getElementById('artistSuggestions').style.display = 'none';
            
            // Show the edit modal
            document.getElementById('editVideoModal').style.display = 'block';
        })
        .catch(error => {
            console.error('Error fetching video data:', error);
            showError('Error loading video data');
        });
}

function closeEditVideoModal() {
    document.getElementById('editVideoModal').style.display = 'none';
    document.getElementById('artistSuggestions').style.display = 'none';
    resetIdentifyArtistButton();
    window.currentEditVideoId = null;
}

// Handle edit video form submission
document.getElementById('editVideoForm').addEventListener('submit', function(e) {
    e.preventDefault();
    
    if (!window.currentEditVideoId) {
        showWarning('No video selected for editing');
        return;
    }
    
    const formData = new FormData(this);
    const updateData = {
        title: formData.get('title'),
        artist_name: formData.get('artist_name'),
        year: formData.get('year') ? parseInt(formData.get('year')) : null,
        genres: formData.get('genre') ? [formData.get('genre')] : [],
        status: formData.get('status'),
        video_url: formData.get('video_url'),
        thumbnail_url: formData.get('thumbnail_url'),
        duration: formData.get('duration') ? parseInt(formData.get('duration')) : null,
        imvdb_id: formData.get('imvdb_id'),
        move_file: formData.get('move_file') === 'on'
    };
    
    // Remove empty string values
    Object.keys(updateData).forEach(key => {
        if (updateData[key] === '') {
            updateData[key] = null;
        }
    });
    
    fetch(`/api/videos/${window.currentEditVideoId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
    })
    .then(response => response.json())
    .then(result => {
        if (result.error) {
            showError('Error updating video: ' + result.error);
        } else {
            showSuccess('Video updated successfully!');
            closeEditVideoModal();
            loadVideos(); // Refresh the video list
        }
    })
    .catch(error => {
        console.error('Error updating video:', error);
        showError('Error updating video');
    });
});

function playVideo(videoId, title, localPath, videoUrl) {
    // Set modal title
    document.getElementById('videoModalTitle').textContent = title || 'Playing Video';
    
    // Create video player
    const playerDiv = document.getElementById('videoPlayer');
    
    // Prioritize local file if available
    if (localPath && localPath !== 'null' && localPath !== 'undefined') {
        // Check if this is a known unsupported format that needs VLC streaming
        let needsVLCStreaming = localPath.toLowerCase().endsWith('.mkv') || 
                                localPath.toLowerCase().endsWith('.avi');
        
        if (needsVLCStreaming) {
            // Use direct streaming for unsupported formats
            playerDiv.innerHTML = `
                <div class="video-loading">
                    <h3>üé¨ Starting Video Stream...</h3>
                    <p>Transcoding video for browser playback using FFmpeg.</p>
                    <div class="loading-spinner">
                        <img src="{{ url_for('static', filename='MVidarr.png') }}" alt="MVidarr" class="spinning mvidarr-logo-spinner" style="width: 24px; height: 24px;">
                    </div>
                </div>
            `;
            
            // Show modal
            document.getElementById('videoModal').style.display = 'block';
            
            // Track current video ID for cleanup
            window.currentVideoId = videoId;
            
            // Use the direct streaming endpoint
            const streamUrl = `/api/videos/${videoId}/stream`;
            
            // Give it a moment to show the loading message, then start the stream
            setTimeout(() => {
                playerDiv.innerHTML = `
                    <video width="800" height="450" controls autoplay>
                        <source src="${streamUrl}" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <div class="stream-info">
                        <p><small>Streaming via FFmpeg transcoding</small></p>
                    </div>
                `;
            }, 1000);
            
            return;
        }
        
        // Determine MIME type based on file extension
        let mimeType = 'video/mp4'; // default
        if (localPath.toLowerCase().endsWith('.mkv')) {
            mimeType = 'video/x-matroska';
        } else if (localPath.toLowerCase().endsWith('.webm')) {
            mimeType = 'video/webm';
        } else if (localPath.toLowerCase().endsWith('.avi')) {
            mimeType = 'video/x-msvideo';
        } else if (localPath.toLowerCase().endsWith('.mov')) {
            mimeType = 'video/quicktime';
        }
        
        // Play local file via streaming endpoint with proper MIME type
        playerDiv.innerHTML = `
            <video width="800" height="450" controls preload="metadata">
                <source src="/api/videos/${videoId}/stream" type="${mimeType}">
                Your browser does not support the video tag or this video format.
            </video>
        `;
        
        // Add error handling for video load failures
        const video = playerDiv.querySelector('video');
        
        // Add timeout for video loading
        let loadTimeout;
        let hasLoaded = false;
        
        video.addEventListener('error', function(e) {
            console.error('Video playback error:', e);
            clearTimeout(loadTimeout);
            showVideoError(videoId, localPath, mimeType, 'Video failed to load');
        });
        
        video.addEventListener('loadstart', function() {
            console.log('Video load started for:', localPath, 'Type:', mimeType);
            hasLoaded = false;
            
            // Set timeout for loading - if video doesn't load within 10 seconds, show error
            loadTimeout = setTimeout(() => {
                if (!hasLoaded) {
                    console.warn('Video loading timeout for:', localPath);
                    showVideoError(videoId, localPath, mimeType, 'Video loading timeout - format may not be supported');
                }
            }, 10000);
        });
        
        video.addEventListener('loadeddata', function() {
            console.log('Video loaded successfully:', localPath);
            hasLoaded = true;
            clearTimeout(loadTimeout);
        });
        
        video.addEventListener('canplay', function() {
            hasLoaded = true;
            clearTimeout(loadTimeout);
        });
        
        // Check if format is likely unsupported and warn immediately
        let formatUnsupported = localPath.toLowerCase().endsWith('.mkv') || 
                               localPath.toLowerCase().endsWith('.avi');
        
        if (formatUnsupported) {
            // Show immediate warning for known unsupported formats
            setTimeout(() => {
                if (!hasLoaded) {
                    console.warn('Likely unsupported format detected:', localPath);
                    showVideoError(videoId, localPath, mimeType, 'This video format may not be supported by your browser');
                }
            }, 3000); // Check after 3 seconds
        }
        
    } else if (videoUrl && videoUrl !== 'null' && videoUrl !== 'undefined') {
        // Fall back to YouTube or other URL
        if (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')) {
            // Extract YouTube video ID
            const youtubeId = extractYouTubeId(videoUrl);
            if (youtubeId) {
                playerDiv.innerHTML = `
                    <iframe width="800" height="450" 
                            src="https://www.youtube.com/embed/${youtubeId}" 
                            frameborder="0" 
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                            allowfullscreen>
                    </iframe>
                `;
            }
        } else {
            // For other video URLs, try using HTML5 video element
            playerDiv.innerHTML = `
                <video width="800" height="450" controls>
                    <source src="${videoUrl}" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            `;
        }
    } else {
        showWarning('No video file available for playback');
        return;
    }
    
    // Show modal
    document.getElementById('videoModal').style.display = 'block';
}

function extractYouTubeId(url) {
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const match = url.match(regExp);
    return (match && match[2].length === 11) ? match[2] : null;
}

function closeVideoModal() {
    const modal = document.getElementById('videoModal');
    const playerDiv = document.getElementById('videoPlayer');
    
    // Clear the player to stop playback
    playerDiv.innerHTML = '';
    
    // Hide modal
    modal.style.display = 'none';
    
    // Clear current video ID
    window.currentVideoId = null;
}









// Close modal when clicking outside of it
window.addEventListener('click', function(event) {
    const videoModal = document.getElementById('videoModal');
    const editModal = document.getElementById('editVideoModal');
    
    if (event.target === videoModal) {
        closeVideoModal();
    }
    
    if (event.target === editModal) {
        closeEditVideoModal();
    }
});

function downloadVideo(id) {
    // Removed download confirmation popup - direct download
    {
        fetch(`/api/videos/${id}/download`, {
            method: 'POST'
        })
        .then(response => response.json())
        .then(result => {
            if (result.error) {
                showError('Error: ' + result.error);
            } else {
                showSuccessToast('Video queued for download');
                loadVideos();
            }
        })
        .catch(error => {
            console.error('Error downloading video:', error);
            showErrorToast('Error queuing video for download');
        });
    }
}

function transcodeVideo(id) {
    toastConfirm('Convert this video to MP4 for better browser compatibility? This may take a few minutes depending on file size.', () => {
        // Show progress in the modal
        const playerDiv = document.getElementById('videoPlayer');
        playerDiv.innerHTML = `
            <div class="transcoding-progress">
                <h3>üîÑ Converting Video...</h3>
                <p>Converting to MP4 format for better browser compatibility.</p>
                <p>This may take several minutes depending on the video size.</p>
                <div class="progress-spinner"></div>
                <button onclick="closeVideoModal()" class="btn btn-secondary">Close</button>
            </div>
        `;
        
        fetch(`/api/videos/${id}/transcode`, {
            method: 'POST'
        })
        .then(response => response.json())
        .then(result => {
            if (result.error) {
                playerDiv.innerHTML = `
                    <div class="transcoding-error">
                        <h3>‚ùå Conversion Failed</h3>
                        <p>Error: ${result.error}</p>
                        <button onclick="closeVideoModal()" class="btn btn-primary">Close</button>
                    </div>
                `;
            } else {
                // Start checking status
                checkTranscodingStatus(id);
            }
        })
        .catch(error => {
            console.error('Error transcoding video:', error);
            playerDiv.innerHTML = `
                <div class="transcoding-error">
                    <h3>‚ùå Conversion Failed</h3>
                    <p>Error starting video conversion: ${error.message}</p>
                    <button onclick="closeVideoModal()" class="btn btn-primary">Close</button>
                </div>
            `;
        });
    });
}

function checkTranscodingStatus(id) {
    const playerDiv = document.getElementById('videoPlayer');
    
    fetch(`/api/videos/${id}/transcode/status`)
        .then(response => response.json())
        .then(result => {
            if (result.status === 'completed') {
                playerDiv.innerHTML = `
                    <div class="transcoding-success">
                        <h3>‚úÖ Conversion Complete!</h3>
                        <p>Video has been converted to MP4 format.</p>
                        <button onclick="refreshAndPlay(${id})" class="btn btn-success">Play Video</button>
                        <button onclick="closeVideoModal()" class="btn btn-secondary">Close</button>
                    </div>
                `;
            } else if (result.status === 'processing' || result.status === 'not_started') {
                // Keep checking every 5 seconds
                setTimeout(() => checkTranscodingStatus(id), 5000);
            } else {
                playerDiv.innerHTML = `
                    <div class="transcoding-error">
                        <h3>‚ùå Conversion Status Unknown</h3>
                        <p>Status: ${result.status}</p>
                        <button onclick="closeVideoModal()" class="btn btn-primary">Close</button>
                    </div>
                `;
            }
        })
        .catch(error => {
            console.error('Error checking transcoding status:', error);
            // Stop checking on error
        });
}

function tryPlayAnyway(videoId, title, localPath, videoUrl) {
    // Proceed with normal playback attempt
    const playerDiv = document.getElementById('videoPlayer');
    
    // Determine MIME type based on file extension
    let mimeType = 'video/mp4'; // default
    if (localPath.toLowerCase().endsWith('.mkv')) {
        mimeType = 'video/x-matroska';
    } else if (localPath.toLowerCase().endsWith('.webm')) {
        mimeType = 'video/webm';
    } else if (localPath.toLowerCase().endsWith('.avi')) {
        mimeType = 'video/x-msvideo';
    } else if (localPath.toLowerCase().endsWith('.mov')) {
        mimeType = 'video/quicktime';
    }
    
    // Play local file via streaming endpoint with proper MIME type
    playerDiv.innerHTML = `
        <video width="800" height="450" controls preload="metadata">
            <source src="/api/videos/${videoId}/stream" type="${mimeType}">
            Your browser does not support the video tag or this video format.
        </video>
    `;
    
    // Add all the same error handling as the normal playback
    const video = playerDiv.querySelector('video');
    let loadTimeout;
    let hasLoaded = false;
    
    video.addEventListener('error', function(e) {
        console.error('Video playback error:', e);
        clearTimeout(loadTimeout);
        showVideoError(videoId, localPath, mimeType, 'Video failed to load');
    });
    
    video.addEventListener('loadstart', function() {
        console.log('Video load started for:', localPath, 'Type:', mimeType);
        hasLoaded = false;
        
        loadTimeout = setTimeout(() => {
            if (!hasLoaded) {
                console.warn('Video loading timeout for:', localPath);
                showVideoError(videoId, localPath, mimeType, 'Video loading timeout - format may not be supported');
            }
        }, 10000);
    });
    
    video.addEventListener('loadeddata', function() {
        console.log('Video loaded successfully:', localPath);
        hasLoaded = true;
        clearTimeout(loadTimeout);
    });
    
    video.addEventListener('canplay', function() {
        hasLoaded = true;
        clearTimeout(loadTimeout);
    });
}

function showVideoError(videoId, localPath, mimeType, errorMessage) {
    const playerDiv = document.getElementById('videoPlayer');
    let unsupportedVideoFormat = localPath.toLowerCase().endsWith('.mkv') || 
                                 localPath.toLowerCase().endsWith('.avi');
    
    playerDiv.innerHTML = `
        <div class="video-error">
            <p>‚ö†Ô∏è ${errorMessage}</p>
            <p><strong>File:</strong> ${localPath}</p>
            <p><strong>Type:</strong> ${mimeType}</p>
            ${unsupportedVideoFormat ? `
                <p><em>Note: .mkv and .avi files have limited browser support.</em></p>
                <button onclick="transcodeVideo(${videoId})" class="btn btn-warning">Convert to MP4</button>
            ` : ''}
            <button onclick="closeVideoModal()" class="btn btn-primary">Close</button>
        </div>
    `;
}

function refreshAndPlay(id) {
    // Refresh the video list to get updated paths
    loadVideos();
    
    // Close modal and show success message
    closeVideoModal();
    showSuccess('Video converted successfully! Try playing it again.');
}

function refreshVideoMetadata(id) {
    toastConfirm('Refresh metadata for this video from IMVDb and extract FFmpeg technical data? This will update year, directors, producers, thumbnail, duration, quality, and technical metadata.', () => {
        // Find the video card to show loading state
        const videoCard = document.querySelector(`[data-video-id="${id}"]`).closest('.video-card');
        const originalContent = videoCard.innerHTML;
        
        // Show enhanced loading state
        videoCard.innerHTML = `
            <div style="padding: 20px; text-align: center;">
                <div class="loading-spinner">
                    <img src="{{ url_for('static', filename='MVidarr.png') }}" alt="MVidarr" class="spinning mvidarr-logo-spinner" style="width: 24px; height: 24px;">
                </div>
                <p>Refreshing metadata from IMVDb and extracting technical data...</p>
                <small style="color: var(--text-muted);">This may take a moment for video analysis</small>
            </div>
        `;
        
        fetch(`/api/videos/${id}/refresh-metadata`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => {
            if (response.status === 409) {
                // Handle duplicate IMVDb ID conflict
                return response.json().then(result => {
                    showDuplicateVideoDialog(result, originalContent, videoCard);
                    return null; // Skip normal processing
                });
            }
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(result => {
            if (!result) return; // Skip if duplicate was handled
            
            if (result.error && result.error !== 'duplicate_imvdb_id') {
                showError('Error: ' + result.error);
                // Restore original content on error
                videoCard.innerHTML = originalContent;
            } else if (result.success === false) {
                showWarning('Warning: ' + result.message);
                // Restore original content if no match found
                videoCard.innerHTML = originalContent;
            } else {
                // Build success message based on what was updated
                let message = `Metadata refreshed successfully from ${result.source}!`;
                if (result.ffmpeg_extracted) {
                    message += ' Technical metadata also extracted from video file.';
                }
                showSuccess(message);
                
                // Update just this video card instead of reloading entire page
                try {
                    updateSingleVideoCard(id);
                } catch (updateError) {
                    console.error('Error updating video card after refresh:', updateError);
                    // Fallback: restore original content
                    videoCard.innerHTML = originalContent;
                    showWarning('Metadata refreshed successfully, but card display update failed. Please refresh the page to see changes.');
                }
            }
        })
        .catch(error => {
            console.error('Error refreshing metadata:', error);
            showError(`Error refreshing metadata: ${error.message}`);
            // Restore original content on error
            videoCard.innerHTML = originalContent;
        });
        
        // Add a timeout to prevent cards getting stuck indefinitely
        setTimeout(() => {
            if (videoCard && videoCard.innerHTML.includes('Refreshing metadata')) {
                console.warn(`Metadata refresh for video ${id} timed out`);
                videoCard.innerHTML = originalContent;
                showWarning('Metadata refresh timed out. Please try again.');
            }
        }, 60000); // 60 second timeout
    });
}

function updateSingleVideoCard(videoId) {
    // Fetch updated video data from API
    fetch(`/api/videos/${videoId}`)
        .then(response => response.json())
        .then(video => {
            if (video.error) {
                showError('Error loading updated video data');
                return;
            }
            
            // Find the video card that needs updating
            const videoElement = document.querySelector(`[data-video-id="${videoId}"]`);
            if (!videoElement) {
                console.warn(`Video element with ID ${videoId} not found for update - may be on different page or filtered out`);
                return;
            }
            
            const videoCard = videoElement.closest('.video-card');
            if (!videoCard) {
                console.error(`Video card not found for video ID ${videoId}`);
                return;
            }
            
            // Preserve checkbox state
            const checkbox = videoCard.querySelector('.video-checkbox');
            const isChecked = checkbox ? checkbox.checked : false;
            
            // Generate new video card HTML (matching the template from loadVideos)
            const newCardHTML = `
                <div class="video-select">
                    <input type="checkbox" class="video-checkbox" value="${video.id}" onchange="updateSelectedCount()" ${isChecked ? 'checked' : ''}>
                </div>
                <div class="video-thumbnail" data-video-id="${video.id}" data-action="play">
                    <img src="/api/videos/${video.id}/thumbnail" 
                         alt="${video.title}"
                         onerror="this.src='/static/placeholder-video.png'">
                    <div class="play-overlay">
                        <div class="play-button">‚ñ∂</div>
                    </div>
                </div>
                <div class="video-info">
                    <h3>${escapeHtml(video.title)}</h3>
                    <p>Artist: ${video.artist_id ? `<a href="/artist/${video.artist_id}" class="artist-link">${escapeHtml(video.artist_name || 'Unknown')}</a>` : escapeHtml(video.artist_name || 'Unknown')}</p>
                    <p>Status: <span class="status-${video.status ? video.status.toLowerCase() : 'unknown'}">${video.status || 'Unknown'}</span></p>
                    ${video.year ? `<p>Year: ${video.year}</p>` : ''}
                    ${video.genres && video.genres.length > 0 ? `<p>Genres: ${video.genres.join(', ')}</p>` : ''}
                    <div class="video-metadata">
                        ${video.quality ? `<span class="metadata-item quality">üì∫ ${video.quality}</span>` : ''}
                        ${video.duration ? `<span class="metadata-item duration">‚è±Ô∏è ${formatDuration(video.duration)}</span>` : ''}
                    </div>
                </div>
                <div class="video-actions">
                    <button data-video-id="${video.id}" data-action="edit" class="btn-icon" title="Edit Video">
                        <iconify-icon icon="tabler:edit"></iconify-icon>
                    </button>
                    <button data-video-id="${video.id}" data-action="download" class="btn-icon" title="Download Video">
                        <iconify-icon icon="tabler:download"></iconify-icon>
                    </button>
                    <button data-video-id="${video.id}" data-action="add-to-playlist" class="btn-icon" title="Add to Playlist">
                        <iconify-icon icon="tabler:playlist-add"></iconify-icon>
                    </button>
                    <button data-video-id="${video.id}" data-action="refresh-metadata" class="btn-icon" title="Refresh Metadata">
                        <iconify-icon icon="tabler:refresh"></iconify-icon>
                    </button>
                    <button data-video-id="${video.id}" data-action="delete" class="btn-icon btn-danger" title="Delete Video">
                        <iconify-icon icon="tabler:trash"></iconify-icon>
                    </button>
                </div>
            `;
            
            // Replace the video card content
            videoCard.innerHTML = newCardHTML;
        })
        .catch(error => {
            console.error('Error updating video card:', error);
            showError('Error updating video display');
            
            // Try to restore the card by refreshing the page or falling back
            const videoElement = document.querySelector(`[data-video-id="${videoId}"]`);
            if (videoElement) {
                const videoCard = videoElement.closest('.video-card');
                if (videoCard && videoCard.innerHTML.includes('Refreshing metadata')) {
                    // Card is stuck in loading state, force a page refresh to restore
                    console.warn('Video card stuck in loading state, refreshing page...');
                    location.reload();
                }
            }
        });
}

function refreshAllMetadata() {
    const selectedVideoIds = getSelectedVideoIds();
    const isSelectedVideos = selectedVideoIds.length > 0;
    const message = isSelectedVideos 
        ? `Refresh metadata from IMVDb for ${selectedVideoIds.length} selected videos that don't have IMVDb data? This may take several minutes.`
        : 'Refresh metadata from IMVDb for all videos that don\'t have IMVDb data? This may take several minutes.';
        
    toastConfirm(message, () => {
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = 'Refreshing...';
        button.disabled = true;
        
        const requestBody = {
            force_refresh: false,
            limit: isSelectedVideos ? selectedVideoIds.length : 100  // Process selected videos or first 100
        };
        
        if (isSelectedVideos) {
            requestBody.video_ids = selectedVideoIds;
        }
        
        fetch('/api/videos/refresh-all-metadata', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(result => {
            button.textContent = originalText;
            button.disabled = false;
            
            if (result.error) {
                showError('Error: ' + result.error);
            } else {
                const message = `Metadata refresh completed!\n\nProcessed: ${result.processed}\nUpdated: ${result.updated}\nErrors: ${result.errors}`;
                showSuccess(message);
                loadVideos(); // Refresh the video list
            }
        })
        .catch(error => {
            console.error('Error refreshing all metadata:', error);
            showError(`Error refreshing metadata: ${error.message}`);
            button.textContent = originalText;
            button.disabled = false;
        });
    });
}


function deleteVideo(id) {
    // Get video information from the card
    const videoCard = document.querySelector(`[data-video-id="${id}"]`).closest('.video-card');
    const title = videoCard.querySelector('h3').textContent;
    const artist = videoCard.querySelector('.video-info p').textContent.replace('Artist: ', '');
    
    // Fetch video details to get YouTube URL
    fetch(`/api/videos/${id}`)
        .then(response => response.json())
        .then(video => {
            if (video.error) {
                console.error('Error fetching video details:', video.error);
                showDeleteVideoModal(id, title, artist, '');
                return;
            }
            
            // Try multiple URL fields to find YouTube URL
            const url = video.video_url || video.url || video.youtube_url || '';
            showDeleteVideoModal(id, title, artist, url);
        })
        .catch(error => {
            console.error('Error fetching video details:', error);
            // Fallback to show modal without URL
            showDeleteVideoModal(id, title, artist, '');
        });
}

function showDeleteVideoModal(videoId, title, artist, url) {
    const modal = document.getElementById('deleteVideoModal');
    
    // Store video ID for use in confirm function
    modal.dataset.videoId = videoId;
    
    // Populate modal with video information
    document.getElementById('deleteVideoTitle').textContent = title;
    document.getElementById('deleteVideoArtist').textContent = artist;
    document.getElementById('deleteVideoUrl').textContent = url || 'No URL available';
    
    // Show/hide blacklist option based on whether URL exists and is a YouTube URL
    const blacklistGroup = document.getElementById('deleteBlacklistGroup');
    const blacklistCheckbox = document.getElementById('deleteAddToBlacklist');
    
    if (!blacklistGroup || !blacklistCheckbox) {
        console.error('Blacklist elements not found in DOM');
        modal.style.display = 'block';
        return;
    }
    
    // Reset checkbox state
    blacklistCheckbox.checked = false;
    blacklistGroup.style.opacity = '1';
    
    // Reset the checkbox text
    const checkboxText = blacklistGroup.querySelector('.checkbox-text strong');
    if (checkboxText) {
        checkboxText.textContent = 'Add to blacklist';
    }
    
    // Show blacklist option for any video that has a URL (not just YouTube)
    // The backend will handle checking if it's actually a valid URL to blacklist
    if (url && url.trim() !== '' && url !== 'No URL available') {
        blacklistGroup.style.display = 'block';
        
        // Add note if it's not a YouTube URL
        if (!url.includes('youtube.com') && !url.includes('youtu.be')) {
            blacklistGroup.style.opacity = '0.8';
            if (checkboxText) {
                checkboxText.textContent = 'Add to blacklist (Non-YouTube URL)';
            }
        }
    } else {
        blacklistGroup.style.display = 'none';
    }
    
    modal.style.display = 'block';
}

function closeDeleteVideoModal() {
    document.getElementById('deleteVideoModal').style.display = 'none';
}

function confirmDeleteVideo() {
    const modal = document.getElementById('deleteVideoModal');
    const videoId = modal.dataset.videoId;
    
    if (!videoId) {
        showError('No video ID found');
        return;
    }
    
    const addToBlacklist = document.getElementById('deleteAddToBlacklist').checked;
    
    const requestBody = {};
    if (addToBlacklist) {
        requestBody.add_to_blacklist = true;
    }
    
    fetch(`/api/videos/${videoId}`, {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
    })
    .then(response => response.json())
    .then(result => {
        if (result.error) {
            showError('Error: ' + result.error);
        } else {
            let message = 'Video deleted successfully!';
            if (result.blacklisted) {
                message += ' Video URL has been added to blacklist.';
            }
            showSuccess(message);
            closeDeleteVideoModal();
            loadVideos();
        }
    })
    .catch(error => {
        console.error('Error deleting video:', error);
        showError('Error deleting video: ' + error.message);
    });
}

function identifyArtist() {
    const videoId = window.currentEditVideoId;
    if (!videoId) {
        showWarning('No video selected');
        return;
    }
    
    const button = document.getElementById('identifyArtistBtn');
    button.textContent = 'üîÑ Identifying...';
    button.disabled = true;
    
    // Store the request so it can be aborted if needed
    const abortController = new AbortController();
    window.currentIdentifyRequest = abortController;
    
    fetch(`/api/videos/${videoId}/identify-artist`, {
        method: 'POST',
        signal: abortController.signal
    })
    .then(response => response.json())
    .then(result => {
        // Only process if this request is still current
        if (window.currentIdentifyRequest === abortController) {
            resetIdentifyArtistButton();
            
            if (result.error) {
                showError('Error identifying artist: ' + result.error);
                return;
            }
            
            displayArtistSuggestions(result);
        }
    })
    .catch(error => {
        // Only show error if request wasn't aborted
        if (window.currentIdentifyRequest === abortController && error.name !== 'AbortError') {
            console.error('Error identifying artist:', error);
            showError('Error identifying artist');
        }
        
        // Reset button if this was the current request
        if (window.currentIdentifyRequest === abortController) {
            resetIdentifyArtistButton();
        }
    });
}

function displayArtistSuggestions(data) {
    const suggestionsDiv = document.getElementById('artistSuggestions');
    
    if (!data.suggestions || data.suggestions.length === 0) {
        suggestionsDiv.innerHTML = `
            <h4>No Artist Suggestions Found</h4>
            <p>No automatic suggestions could be generated for "${data.title}".</p>
            <div class="manual-entry">
                <label>Enter artist name manually:</label>
                <div class="autocomplete-container">
                    <input type="text" id="manualArtistInput" placeholder="Enter artist name" 
                           oninput="searchExistingArtists(this.value)" 
                           onkeydown="handleAutocompleteKeydown(event)"
                           autocomplete="off">
                    <div id="artistAutocomplete" class="autocomplete-suggestions" style="display: none;"></div>
                </div>
                <button type="button" onclick="applyManualArtist()" class="btn btn-primary btn-small" style="margin-top: 5px;">Apply</button>
            </div>
        `;
        suggestionsDiv.style.display = 'block';
        return;
    }
    
    let html = `<h4>Artist Suggestions for "${data.title}":</h4>`;
    
    data.suggestions.forEach((suggestion, index) => {
        const confidenceClass = getConfidenceClass(suggestion.confidence);
        const confidencePercent = Math.round(suggestion.confidence * 100);
        
        html += `
            <div class="artist-suggestion" onclick="selectArtistSuggestion('${suggestion.artist_name}')">
                <div class="artist-suggestion-name">${suggestion.artist_name}</div>
                <div class="artist-suggestion-details">
                    <span class="artist-suggestion-confidence ${confidenceClass}">
                        ${confidencePercent}%
                    </span>
                    Source: ${suggestion.source}
                    ${suggestion.reason ? `<br><em>${suggestion.reason}</em>` : ''}
                </div>
            </div>
        `;
    });
    
    // Add manual entry option
    html += `
        <div class="manual-entry">
            <label>Or enter artist name manually:</label>
            <input type="text" id="manualArtistInput" placeholder="Enter artist name">
            <button type="button" onclick="applyManualArtist()" class="btn btn-primary btn-small" style="margin-top: 5px;">Apply</button>
        </div>
    `;
    
    suggestionsDiv.innerHTML = html;
    suggestionsDiv.style.display = 'block';
}

function getConfidenceClass(confidence) {
    if (confidence >= 0.8) return 'high';
    if (confidence >= 0.6) return 'medium';
    return 'low';
}

function selectArtistSuggestion(artistName) {
    document.getElementById('videoArtist').value = artistName;
    document.getElementById('artistSuggestions').style.display = 'none';
}

function applyManualArtist() {
    const manualInput = document.getElementById('manualArtistInput');
    const artistName = manualInput.value.trim();
    
    if (artistName) {
        document.getElementById('videoArtist').value = artistName;
        document.getElementById('artistSuggestions').style.display = 'none';
    } else {
        showWarning('Please enter an artist name');
    }
}

function resetIdentifyArtistButton() {
    // Abort any pending identify request
    if (window.currentIdentifyRequest) {
        window.currentIdentifyRequest.abort();
        window.currentIdentifyRequest = null;
    }
    
    const button = document.getElementById('identifyArtistBtn');
    if (button) {
        button.textContent = 'üîç Identify Artist';
        button.disabled = false;
    }
}

// Autocomplete functionality for artist search
let autocompleteTimeout;
let selectedAutocompleteIndex = -1;

function searchExistingArtists(query) {
    // Clear previous timeout
    if (autocompleteTimeout) {
        clearTimeout(autocompleteTimeout);
    }
    
    // Reset selection
    selectedAutocompleteIndex = -1;
    
    // Debounce the search
    autocompleteTimeout = setTimeout(() => {
        if (query.length < 2) {
            hideAutocomplete();
            return;
        }
        
        fetch(`/api/videos/search-artists?q=${encodeURIComponent(query)}`)
            .then(response => response.json())
            .then(data => {
                displayAutocomplete(data.artists);
            })
            .catch(error => {
                console.error('Error searching artists:', error);
                hideAutocomplete();
            });
    }, 300); // Wait 300ms after user stops typing
}

function displayAutocomplete(artists) {
    const autocompleteDiv = document.getElementById('artistAutocomplete');
    
    if (!artists || artists.length === 0) {
        hideAutocomplete();
        return;
    }
    
    let html = '';
    artists.forEach((artist, index) => {
        html += `
            <div class="autocomplete-suggestion" data-artist-name="${artist.name.replace(/"/g, '&quot;')}" data-index="${index}">
                <span class="autocomplete-suggestion-name">${artist.name}</span>
                <span class="autocomplete-suggestion-count">(${artist.video_count} videos)</span>
            </div>
        `;
    });
    
    autocompleteDiv.innerHTML = html;
    autocompleteDiv.style.display = 'block';
    
    // Add click event listeners for autocomplete suggestions
    autocompleteDiv.querySelectorAll('.autocomplete-suggestion').forEach(suggestion => {
        suggestion.addEventListener('click', function() {
            const artistName = this.getAttribute('data-artist-name');
            selectAutocompleteArtist(artistName);
        });
    });
}

function hideAutocomplete() {
    const autocompleteDiv = document.getElementById('artistAutocomplete');
    if (autocompleteDiv) {
        autocompleteDiv.style.display = 'none';
    }
    selectedAutocompleteIndex = -1;
}

function selectAutocompleteArtist(artistName) {
    document.getElementById('manualArtistInput').value = artistName;
    hideAutocomplete();
}

function handleAutocompleteKeydown(event) {
    const autocompleteDiv = document.getElementById('artistAutocomplete');
    const suggestions = autocompleteDiv.querySelectorAll('.autocomplete-suggestion');
    
    if (suggestions.length === 0) {
        return;
    }
    
    switch (event.key) {
        case 'ArrowDown':
            event.preventDefault();
            selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, suggestions.length - 1);
            updateAutocompleteSelection(suggestions);
            break;
            
        case 'ArrowUp':
            event.preventDefault();
            selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, -1);
            updateAutocompleteSelection(suggestions);
            break;
            
        case 'Enter':
            event.preventDefault();
            if (selectedAutocompleteIndex >= 0) {
                const selectedSuggestion = suggestions[selectedAutocompleteIndex];
                const artistName = selectedSuggestion.getAttribute('data-artist-name');
                selectAutocompleteArtist(artistName);
            }
            break;
            
        case 'Escape':
            hideAutocomplete();
            break;
    }
}

function updateAutocompleteSelection(suggestions) {
    // Remove previous selection
    suggestions.forEach(suggestion => {
        suggestion.classList.remove('selected');
    });
    
    // Add selection to current item
    if (selectedAutocompleteIndex >= 0) {
        suggestions[selectedAutocompleteIndex].classList.add('selected');
    }
}

// Hide autocomplete when clicking outside
document.addEventListener('click', function(event) {
    const autocompleteContainer = document.querySelector('.autocomplete-container');
    if (autocompleteContainer && !autocompleteContainer.contains(event.target)) {
        hideAutocomplete();
    }
});

// Bulk Selection Functions
function toggleSelectAll() {
    const selectAllCheckbox = document.getElementById('selectAllVideos');
    const videoCheckboxes = document.querySelectorAll('.video-checkbox');
    
    videoCheckboxes.forEach(checkbox => {
        checkbox.checked = selectAllCheckbox.checked;
    });
    
    updateSelectedCount();
}

function updateSelectedCount() {
    const selectedCheckboxes = document.querySelectorAll('.video-checkbox:checked');
    const count = selectedCheckboxes.length;
    
    const selectedCountEl = document.getElementById('selectedCount');
    if (selectedCountEl) {
        selectedCountEl.textContent = count;
    }
    
    const deleteSelectedBtn = document.getElementById('deleteSelectedBtn');
    if (deleteSelectedBtn) {
        deleteSelectedBtn.disabled = count === 0;
    }
    
    // Update playlist bulk action buttons
    const addToPlaylistBtn = document.getElementById('bulkAddToPlaylistBtn');
    const createPlaylistBtn = document.getElementById('bulkCreatePlaylistBtn');
    
    if (addToPlaylistBtn) {
        addToPlaylistBtn.disabled = count === 0; // Requires videos to be selected
    }
    if (createPlaylistBtn) {
        createPlaylistBtn.disabled = false; // Always enabled - can create playlist with or without videos
    }
    
    // Update all bulk button states
    updateBulkButtonStates();
    
    // Update select all checkbox state
    const selectAllCheckbox = document.getElementById('selectAllVideos');
    const videoCheckboxes = document.querySelectorAll('.video-checkbox');
    
    if (count === 0) {
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.checked = false;
    } else if (count === videoCheckboxes.length) {
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.checked = true;
    } else {
        selectAllCheckbox.indeterminate = true;
    }
}

function deleteSelectedVideos() {
    const selectedCheckboxes = document.querySelectorAll('.video-checkbox:checked');
    const videoIds = Array.from(selectedCheckboxes).map(checkbox => parseInt(checkbox.value));
    
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    const confirmed = confirm(`Are you sure you want to delete ${videoIds.length} selected video(s)?\n\nThis action cannot be undone.`);
    
    if (confirmed) {
        const deleteBtn = document.getElementById('deleteSelectedBtn');
        deleteBtn.disabled = true;
        deleteBtn.innerHTML = 'üîÑ Deleting...';
        
        fetch('/api/videos/bulk/delete', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                video_ids: videoIds
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.deleted_count > 0) {
                showSuccess(`Successfully deleted ${data.deleted_count} video(s)`);
                if (data.failed_count > 0) {
                    showWarning(`Failed to delete ${data.failed_count} video(s)`);
                }
                // Refresh the video list
                loadVideos();
            } else {
                showError('Failed to delete videos: ' + (data.error || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Error deleting videos:', error);
            showError('Failed to delete videos: ' + error.message);
        })
        .finally(() => {
            deleteBtn.disabled = false;
            deleteBtn.innerHTML = 'üóëÔ∏è Delete Selected (<span id="selectedCount">0</span>)';
            // Reset selection
            document.getElementById('selectAllVideos').checked = false;
            updateSelectedCount();
        });
    }
}

</script>

<!-- Video Thumbnail Management Modal -->
<div id="videoThumbnailModal" class="modal" style="z-index: 2000;">
    <div class="modal-content" style="width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
            <h3>üñºÔ∏è Video Thumbnail Management</h3>
            <span class="modal-close" onclick="closeVideoThumbnailModal()">&times;</span>
        </div>
        <div class="modal-body">
            <!-- Current Thumbnail Display -->
            <div class="current-thumbnail-section">
                <div class="thumbnail-display">
                    <div class="thumbnail-container" id="videoThumbnailContainer">
                        <img id="currentVideoThumbnailImg" src="" alt="Video thumbnail" style="display: none; max-width: 300px; max-height: 300px;">
                        <div id="noVideoThumbnailPlaceholder" class="no-thumbnail-placeholder">
                            <div class="placeholder-icon">üñºÔ∏è</div>
                            <div class="placeholder-text">No thumbnail available</div>
                        </div>
                        <div class="thumbnail-overlay" id="videoThumbnailOverlay" style="display: none;">
                            <div class="thumbnail-actions-overlay">
                                <button onclick="cropVideoThumbnail()" class="btn-overlay" title="Crop">‚úÇÔ∏è</button>
                                <button onclick="replaceVideoThumbnail()" class="btn-overlay" title="Replace">üîÑ</button>
                                <button onclick="deleteVideoThumbnail()" class="btn-overlay" title="Delete">üóëÔ∏è</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Thumbnail Metadata -->
                    <div class="thumbnail-metadata" id="videoThumbnailMetadata" style="display: none;">
                        <h5>Thumbnail Information:</h5>
                        <div class="metadata-grid">
                            <div class="metadata-item">
                                <span class="metadata-label">Source:</span>
                                <span class="metadata-value" id="videoThumbnailSource">-</span>
                            </div>
                            <div class="metadata-item">
                                <span class="metadata-label">Size:</span>
                                <span class="metadata-value" id="videoThumbnailSize">-</span>
                            </div>
                            <div class="metadata-item">
                                <span class="metadata-label">Format:</span>
                                <span class="metadata-value" id="videoThumbnailFormat">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Upload Methods -->
            <div class="upload-methods">
                <div class="upload-tabs">
                    <button class="upload-tab active" onclick="switchVideoUploadTab('manual')" id="videoManualUploadTab">
                        üìÅ Manual Upload
                    </button>
                    <button class="upload-tab" onclick="switchVideoUploadTab('url')" id="videoUrlUploadTab">
                        üîó From URL
                    </button>
                    <button class="upload-tab" onclick="switchVideoUploadTab('search')" id="videoSearchUploadTab">
                        üîç Search Online
                    </button>
                </div>
                
                <!-- Manual Upload Panel -->
                <div class="upload-panel active" id="videoManualUploadPanel">
                    <div class="drag-drop-area" id="videoDragDropArea">
                        <div class="drag-drop-content">
                            <div class="upload-icon">üì§</div>
                            <div class="upload-text">
                                <h4>Drag & Drop Image Here</h4>
                                <p>Or click to browse and select an image</p>
                                <small>Supported formats: JPEG, PNG, WebP, GIF (max 10MB)</small>
                            </div>
                            <input type="file" id="videoThumbnailFileInput" accept="image/*" style="display: none;">
                        </div>
                        <div class="upload-progress" id="videoUploadProgress" style="display: none;">
                            <div class="progress-bar">
                                <div class="progress-fill" id="videoUploadProgressFill"></div>
                            </div>
                            <div class="progress-text" id="videoUploadProgressText">Uploading...</div>
                        </div>
                    </div>
                </div>
                
                <!-- URL Upload Panel -->
                <div class="upload-panel" id="videoUrlUploadPanel" style="display: none;">
                    <div class="url-upload-form">
                        <div class="form-group">
                            <label for="videoThumbnailUrlInput">Image URL:</label>
                            <input type="url" id="videoThumbnailUrlInput" placeholder="https://example.com/image.jpg" class="form-control">
                        </div>
                        <div class="form-actions">
                            <button onclick="previewVideoUrlImage()" class="btn btn-info">üîç Preview</button>
                            <button onclick="uploadVideoFromUrl()" class="btn btn-primary">üì• Upload</button>
                        </div>
                        <div class="url-preview" id="videoUrlPreview" style="display: none;">
                            <img id="videoUrlPreviewImg" alt="URL preview" style="max-width: 300px; max-height: 200px;">
                        </div>
                    </div>
                </div>
                
                <!-- Search Upload Panel -->
                <div class="upload-panel" id="videoSearchUploadPanel" style="display: none;">
                    <div class="search-options">
                        <div class="form-group">
                            <label>Search Sources:</label>
                            <div class="checkbox-group">
                                <label><input type="checkbox" id="searchYoutube" checked> YouTube</label>
                                <label><input type="checkbox" id="searchImvdb" checked> IMVDb</label>
                                <label><input type="checkbox" id="searchGoogle" checked> Google Images</label>
                            </div>
                        </div>
                        <div class="form-actions">
                            <button onclick="searchVideoThumbnails()" class="btn btn-primary">üîç Search Thumbnails</button>
                            <button onclick="refreshVideoThumbnailSearch()" class="btn btn-secondary" id="videoThumbnailRefreshBtn" style="display: none;">üîÑ Refresh</button>
                        </div>
                        
                        <div class="search-results" id="videoThumbnailSearchResults" style="display: none;">
                            <h5>Search Results:</h5>
                            <div class="thumbnail-results-grid" id="videoThumbnailResultsGrid">
                                <!-- Search results will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="form-actions" style="margin-top: 20px;">
                <button type="button" class="btn btn-secondary" onclick="closeVideoThumbnailModal()">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Advanced Thumbnail Cropping Modal -->
<div id="thumbnailCropModal" class="modal" style="z-index: 2500;">
    <div class="modal-content" style="width: 90%; max-width: 1000px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
            <h3>‚úÇÔ∏è Advanced Thumbnail Cropping</h3>
            <span class="modal-close" onclick="closeThumbnailCropModal()">&times;</span>
        </div>
        <div class="modal-body">
            <div class="crop-container">
                <div class="crop-workspace">
                    <div class="crop-canvas-container">
                        <canvas id="cropCanvas" style="max-width: 100%; max-height: 500px; border: 2px solid var(--search-accent, #4a90e2); background: var(--light-input-bg, #f0f0f0);"></canvas>
                        <div class="crop-overlay" id="cropOverlay">
                            <div class="crop-selection" id="cropSelection">
                                <div class="crop-handle crop-handle-nw" data-direction="nw"></div>
                                <div class="crop-handle crop-handle-ne" data-direction="ne"></div>
                                <div class="crop-handle crop-handle-sw" data-direction="sw"></div>
                                <div class="crop-handle crop-handle-se" data-direction="se"></div>
                                <div class="crop-handle crop-handle-n" data-direction="n"></div>
                                <div class="crop-handle crop-handle-s" data-direction="s"></div>
                                <div class="crop-handle crop-handle-e" data-direction="e"></div>
                                <div class="crop-handle crop-handle-w" data-direction="w"></div>
                                <div class="crop-center" id="cropCenter"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="crop-controls">
                    <div class="crop-presets">
                        <h4>Aspect Ratio Presets:</h4>
                        <div class="preset-buttons">
                            <button onclick="setCropAspectRatio(1)" class="btn btn-sm">1:1 Square</button>
                            <button onclick="setCropAspectRatio(16/9)" class="btn btn-sm">16:9 Widescreen</button>
                            <button onclick="setCropAspectRatio(4/3)" class="btn btn-sm">4:3 Standard</button>
                            <button onclick="setCropAspectRatio(3/2)" class="btn btn-sm">3:2 Photo</button>
                            <button onclick="setCropAspectRatio(0)" class="btn btn-sm">Free Form</button>
                        </div>
                    </div>
                    
                    <div class="crop-settings">
                        <h4>Crop Settings:</h4>
                        <div class="settings-grid">
                            <div class="setting-group">
                                <label>Width:</label>
                                <input type="number" id="cropWidth" min="1" max="2000" onchange="updateCropFromInput()">
                            </div>
                            <div class="setting-group">
                                <label>Height:</label>
                                <input type="number" id="cropHeight" min="1" max="2000" onchange="updateCropFromInput()">
                            </div>
                            <div class="setting-group">
                                <label>X Position:</label>
                                <input type="number" id="cropX" min="0" onchange="updateCropFromInput()">
                            </div>
                            <div class="setting-group">
                                <label>Y Position:</label>
                                <input type="number" id="cropY" min="0" onchange="updateCropFromInput()">
                            </div>
                        </div>
                    </div>
                    
                    <div class="crop-effects">
                        <h4>Image Effects:</h4>
                        <div class="effects-grid">
                            <div class="effect-group">
                                <label>Brightness:</label>
                                <input type="range" id="brightnessSlider" min="0" max="200" value="100" onchange="updateCropPreview()">
                                <span id="brightnessValue">100%</span>
                            </div>
                            <div class="effect-group">
                                <label>Contrast:</label>
                                <input type="range" id="contrastSlider" min="0" max="200" value="100" onchange="updateCropPreview()">
                                <span id="contrastValue">100%</span>
                            </div>
                            <div class="effect-group">
                                <label>Saturation:</label>
                                <input type="range" id="saturationSlider" min="0" max="200" value="100" onchange="updateCropPreview()">
                                <span id="saturationValue">100%</span>
                            </div>
                            <div class="effect-group">
                                <label>Blur:</label>
                                <input type="range" id="blurSlider" min="0" max="10" value="0" onchange="updateCropPreview()">
                                <span id="blurValue">0px</span>
                            </div>
                        </div>
                        <div class="effect-buttons">
                            <button onclick="resetImageEffects()" class="btn btn-sm">Reset Effects</button>
                            <button onclick="applyImageFilter('grayscale')" class="btn btn-sm">Grayscale</button>
                            <button onclick="applyImageFilter('sepia')" class="btn btn-sm">Sepia</button>
                            <button onclick="applyImageFilter('invert')" class="btn btn-sm">Invert</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="crop-preview">
                <h4>Cropped Preview:</h4>
                <div class="preview-container">
                    <canvas id="cropPreviewCanvas" style="max-width: 200px; max-height: 200px; border: 1px solid var(--border-secondary, #ccc); background: var(--light-bg-secondary, #f9f9f9);"></canvas>
                    <div class="preview-info">
                        <div>Preview Size: <span id="previewSize">0x0</span></div>
                        <div>Aspect Ratio: <span id="previewAspectRatio">1:1</span></div>
                        <div>File Size: <span id="previewFileSize">~0KB</span></div>
                    </div>
                </div>
            </div>
            
            <div class="crop-actions">
                <button onclick="resetCrop()" class="btn btn-secondary">Reset</button>
                <button onclick="applyCrop()" class="btn btn-primary">Apply Crop</button>
                <button onclick="saveCroppedThumbnail()" class="btn btn-success">Save Thumbnail</button>
                <button onclick="closeThumbnailCropModal()" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>
</div>


<script>
// Global video pagination variables
let currentPage = 1;
let pageSize = 50;
let totalPages = 1;
let searchActive = false;

// Video Thumbnail Management Functions
let currentVideoThumbnailId = null;

function openVideoThumbnailManager() {
    if (!window.currentEditVideoId) {
        showError('No video selected for thumbnail management');
        return;
    }
    
    currentVideoThumbnailId = window.currentEditVideoId;
    document.getElementById('videoThumbnailModal').style.display = 'block';
    
    // Load current thumbnail info
    loadVideoThumbnailInfo();
    
    // Initialize drag & drop
    initializeVideoThumbnailUpload();
}

function closeVideoThumbnailModal() {
    document.getElementById('videoThumbnailModal').style.display = 'none';
    currentVideoThumbnailId = null;
}

function switchVideoUploadTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.upload-tab').forEach(tab => tab.classList.remove('active'));
    document.getElementById(`video${tabName.charAt(0).toUpperCase() + tabName.slice(1)}UploadTab`).classList.add('active');
    
    // Update panels
    document.querySelectorAll('.upload-panel').forEach(panel => panel.style.display = 'none');
    document.getElementById(`video${tabName.charAt(0).toUpperCase() + tabName.slice(1)}UploadPanel`).style.display = 'block';
}

function loadVideoThumbnailInfo() {
    if (!currentVideoThumbnailId) return;
    
    fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail/info`)
        .then(response => response.json())
        .then(data => {
            const thumbnailImg = document.getElementById('currentVideoThumbnailImg');
            const placeholder = document.getElementById('noVideoThumbnailPlaceholder');
            const overlay = document.getElementById('videoThumbnailOverlay');
            const metadata = document.getElementById('videoThumbnailMetadata');
            
            if (data.has_thumbnail) {
                // Show thumbnail image with cache busting
                thumbnailImg.src = `/api/videos/${currentVideoThumbnailId}/thumbnail?t=${Date.now()}`;
                thumbnailImg.style.display = 'block';
                placeholder.style.display = 'none';
                overlay.style.display = 'block';
                
                // Update metadata
                document.getElementById('videoThumbnailSource').textContent = data.thumbnail_source || 'Unknown';
                document.getElementById('videoThumbnailSize').textContent = data.file_size || 'Unknown';
                document.getElementById('videoThumbnailFormat').textContent = data.format || 'Unknown';
                metadata.style.display = 'block';
            } else {
                // Show placeholder
                thumbnailImg.style.display = 'none';
                placeholder.style.display = 'block';
                overlay.style.display = 'none';
                metadata.style.display = 'none';
            }
        })
        .catch(error => {
            console.error('Error loading thumbnail info:', error);
            showError('Failed to load thumbnail information');
        });
}

function initializeVideoThumbnailUpload() {
    const dragDropArea = document.getElementById('videoDragDropArea');
    const fileInput = document.getElementById('videoThumbnailFileInput');
    
    if (!dragDropArea || !fileInput) return;
    
    // Drag & drop handlers
    dragDropArea.addEventListener('click', () => fileInput.click());
    
    dragDropArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        dragDropArea.classList.add('drag-over');
    });
    
    dragDropArea.addEventListener('dragleave', () => {
        dragDropArea.classList.remove('drag-over');
    });
    
    dragDropArea.addEventListener('drop', (e) => {
        e.preventDefault();
        dragDropArea.classList.remove('drag-over');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleVideoThumbnailFile(files[0]);
        }
    });
    
    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
            handleVideoThumbnailFile(e.target.files[0]);
        }
    });
}

function handleVideoThumbnailFile(file) {
    if (!file.type.startsWith('image/')) {
        showError('Please select an image file');
        return;
    }
    
    if (file.size > 10 * 1024 * 1024) { // 10MB
        showError('File size must be less than 10MB');
        return;
    }
    
    const formData = new FormData();
    formData.append('file', file);
    
    const progress = document.getElementById('videoUploadProgress');
    const progressFill = document.getElementById('videoUploadProgressFill');
    const progressText = document.getElementById('videoUploadProgressText');
    
    progress.style.display = 'block';
    progressFill.style.width = '0%';
    
    fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail/upload`, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        progressFill.style.width = '100%';
        return response.json();
    })
    .then(data => {
        progress.style.display = 'none';
        
        if (data.error) {
            showError('Upload failed: ' + data.error);
        } else {
            showSuccess('Thumbnail uploaded successfully');
            loadVideoThumbnailInfo();
            refreshVideoDisplayThumbnail();
            
            // Update the thumbnail URL field in the edit form
            document.getElementById('videoThumbnailUrl').value = '';
        }
    })
    .catch(error => {
        progress.style.display = 'none';
        console.error('Upload error:', error);
        showError('Upload failed: ' + error.message);
    });
}

function previewVideoUrlImage() {
    const url = document.getElementById('videoThumbnailUrlInput').value;
    if (!url) {
        showError('Please enter an image URL');
        return;
    }
    
    const preview = document.getElementById('videoUrlPreview');
    const img = document.getElementById('videoUrlPreviewImg');
    
    img.src = url;
    preview.style.display = 'block';
}

function uploadVideoFromUrl() {
    const url = document.getElementById('videoThumbnailUrlInput').value;
    if (!url) {
        showError('Please enter an image URL');
        return;
    }
    
    fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            action: 'update',
            thumbnail_url: url
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            showError('Failed to update thumbnail: ' + data.error);
        } else {
            showSuccess('Thumbnail URL updated successfully');
            loadVideoThumbnailInfo();
            refreshVideoDisplayThumbnail();
            
            // Update the thumbnail URL field in the edit form
            document.getElementById('videoThumbnailUrl').value = url;
        }
    })
    .catch(error => {
        console.error('Error updating thumbnail:', error);
        showError('Failed to update thumbnail');
    });
}

function searchVideoThumbnails() {
    console.log('searchVideoThumbnails called, currentVideoThumbnailId:', currentVideoThumbnailId);
    
    const youtubeCheckbox = document.getElementById('searchYoutube');
    const imvdbCheckbox = document.getElementById('searchImvdb');
    const googleCheckbox = document.getElementById('searchGoogle');
    
    console.log('YouTube checkbox element:', youtubeCheckbox);
    console.log('IMVDb checkbox element:', imvdbCheckbox);
    console.log('Google checkbox element:', googleCheckbox);
    
    if (!youtubeCheckbox || !imvdbCheckbox || !googleCheckbox) {
        showError('Search checkboxes not found');
        return;
    }
    
    const includeYoutube = youtubeCheckbox.checked;
    const includeImvdb = imvdbCheckbox.checked;
    const includeGoogle = googleCheckbox.checked;
    
    console.log('YouTube checked:', includeYoutube, 'IMVDb checked:', includeImvdb, 'Google checked:', includeGoogle);
    
    const sources = [];
    if (includeYoutube) sources.push('youtube');
    if (includeImvdb) sources.push('imvdb');
    if (includeGoogle) sources.push('google');
    
    if (sources.length === 0) {
        showError('Please select at least one search source');
        return;
    }
    
    if (!currentVideoThumbnailId) {
        showError('No video selected for thumbnail search');
        return;
    }
    
    console.log('Making API call with sources:', sources);
    
    fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail/search`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            sources: sources
        })
    })
    .then(response => {
        console.log('API response received:', response.status, response.statusText);
        return response.json();
    })
    .then(data => {
        console.log('API response data:', data);
        if (data.error) {
            showError('Search failed: ' + data.error);
        } else {
            displayVideoThumbnailResults(data.results);
        }
    })
    .catch(error => {
        console.error('Search error:', error);
        showError('Search failed: ' + error.message);
    });
}

function displayVideoThumbnailResults(results) {
    console.log('displayVideoThumbnailResults called with:', results);
    const resultsContainer = document.getElementById('videoThumbnailSearchResults');
    const grid = document.getElementById('videoThumbnailResultsGrid');
    
    console.log('Results container:', resultsContainer);
    console.log('Results container class:', resultsContainer.className);
    console.log('Results container style:', resultsContainer.style.display);
    console.log('Grid container:', grid);
    console.log('Grid container class:', grid.className);
    
    if (!resultsContainer || !grid) {
        console.error('Results container or grid not found');
        showError('Search results container not found');
        return;
    }
    
    if (results.length === 0) {
        grid.innerHTML = '<p>No thumbnails found</p>';
        console.log('No results found, showing "No thumbnails found" message');
    } else {
        const htmlContent = results.map(result => `
            <div class="thumbnail-result" onclick="selectVideoThumbnailResult('${result.url}')">
                <img src="${result.url}" alt="${result.title || 'Thumbnail'}" 
                     style="max-width: 150px; max-height: 150px; cursor: pointer;"
                     onerror="this.style.display='none'">
                <div class="result-info">
                    <small>${result.source} - ${result.quality || 'Standard'}</small>
                </div>
            </div>
        `).join('');
        
        console.log('Generated HTML content:', htmlContent);
        grid.innerHTML = htmlContent;
        console.log('Grid innerHTML set to:', grid.innerHTML);
    }
    
    resultsContainer.style.display = 'block';
    resultsContainer.style.visibility = 'visible';
    resultsContainer.style.opacity = '1';
    
    // Ensure the grid is also visible
    grid.style.display = 'block';
    grid.style.visibility = 'visible';
    
    console.log('Results container display set to block');
    console.log('Results container final style:', resultsContainer.style.cssText);
    console.log('Results container computed style:', window.getComputedStyle(resultsContainer).display);
    console.log('Grid final style:', grid.style.cssText);
    
    // Show the refresh button once results are displayed
    document.getElementById('videoThumbnailRefreshBtn').style.display = 'inline-block';
}

function selectVideoThumbnailResult(url) {
    // Update the URL input and preview
    document.getElementById('videoThumbnailUrlInput').value = url;
    previewVideoUrlImage();
    
    // Automatically upload the selected thumbnail
    uploadVideoFromUrl();
    
    // Switch back to the URL tab to show the selection
    switchVideoUploadTab('url');
}

function refreshVideoThumbnailSearch() {
    if (!currentVideoThumbnailId) {
        showError('No video selected for thumbnail refresh');
        return;
    }
    
    // Clear current results
    const resultsContainer = document.getElementById('videoThumbnailSearchResults');
    const grid = document.getElementById('videoThumbnailResultsGrid');
    
    if (resultsContainer) {
        resultsContainer.style.display = 'none';
    }
    
    if (grid) {
        grid.innerHTML = '<div class="loading-placeholder">Refreshing search results...</div>';
    }
    
    // Hide refresh button during refresh
    document.getElementById('videoThumbnailRefreshBtn').style.display = 'none';
    
    // Trigger a new search with current settings
    searchVideoThumbnails();
}

function deleteVideoThumbnail() {
    if (!confirm('Are you sure you want to delete this thumbnail?')) {
        return;
    }
    
    fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            action: 'remove'
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            showError('Failed to delete thumbnail: ' + data.error);
        } else {
            showSuccess('Thumbnail deleted successfully');
            loadVideoThumbnailInfo();
            refreshVideoDisplayThumbnail();
            
            // Clear the thumbnail URL field in the edit form
            document.getElementById('videoThumbnailUrl').value = '';
        }
    })
    .catch(error => {
        console.error('Error deleting thumbnail:', error);
        showError('Failed to delete thumbnail');
    });
}

function replaceVideoThumbnail() {
    // Switch to manual upload tab for replacement
    switchVideoUploadTab('manual');
}

function cropVideoThumbnail() {
    if (!currentVideoThumbnailId) {
        showError('No video selected for cropping');
        return;
    }
    
    // Load the current thumbnail image
    const thumbnailImg = document.getElementById('currentVideoThumbnailImg');
    if (!thumbnailImg.src || thumbnailImg.style.display === 'none') {
        showError('No thumbnail available to crop');
        return;
    }
    
    // Open crop modal
    document.getElementById('thumbnailCropModal').style.display = 'block';
    
    // Initialize cropping interface
    initializeCropInterface(thumbnailImg.src);
}

function closeThumbnailCropModal() {
    document.getElementById('thumbnailCropModal').style.display = 'none';
    // Clean up crop interface
    if (window.cropImage) {
        window.cropImage = null;
    }
}

// Advanced Cropping Functions
let cropImage = null;
let cropSelection = { x: 0, y: 0, width: 100, height: 100 };
let cropAspectRatio = 0; // 0 = free form
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let dragMode = 'move'; // 'move' or resize direction

function initializeCropInterface(imageSrc) {
    const canvas = document.getElementById('cropCanvas');
    const ctx = canvas.getContext('2d');
    
    // Load image
    cropImage = new Image();
    cropImage.crossOrigin = 'anonymous';
    cropImage.onload = function() {
        // Set canvas size
        const maxWidth = 600;
        const maxHeight = 400;
        const ratio = Math.min(maxWidth / cropImage.width, maxHeight / cropImage.height);
        
        canvas.width = cropImage.width * ratio;
        canvas.height = cropImage.height * ratio;
        
        // Draw image
        ctx.drawImage(cropImage, 0, 0, canvas.width, canvas.height);
        
        // Initialize crop selection (center 50% of image)
        const margin = 0.25;
        cropSelection = {
            x: canvas.width * margin,
            y: canvas.height * margin,
            width: canvas.width * (1 - 2 * margin),
            height: canvas.height * (1 - 2 * margin)
        };
        
        // Setup crop overlay
        setupCropOverlay();
        updateCropPreview();
        updateCropInputs();
    };
    
    cropImage.src = imageSrc;
}

function setupCropOverlay() {
    const canvas = document.getElementById('cropCanvas');
    const overlay = document.getElementById('cropOverlay');
    const selection = document.getElementById('cropSelection');
    
    // Position overlay to match canvas
    const rect = canvas.getBoundingClientRect();
    overlay.style.width = rect.width + 'px';
    overlay.style.height = rect.height + 'px';
    
    // Position selection
    updateCropSelectionDisplay();
    
    // Add event listeners
    selection.addEventListener('mousedown', handleCropMouseDown);
    document.addEventListener('mousemove', handleCropMouseMove);
    document.addEventListener('mouseup', handleCropMouseUp);
    
    // Add handle event listeners
    document.querySelectorAll('.crop-handle').forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            dragMode = handle.dataset.direction;
            isDragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
        });
    });
}

function updateCropSelectionDisplay() {
    const selection = document.getElementById('cropSelection');
    const canvas = document.getElementById('cropCanvas');
    const canvasRect = canvas.getBoundingClientRect();
    
    const scaleX = canvasRect.width / canvas.width;
    const scaleY = canvasRect.height / canvas.height;
    
    selection.style.left = (cropSelection.x * scaleX) + 'px';
    selection.style.top = (cropSelection.y * scaleY) + 'px';
    selection.style.width = (cropSelection.width * scaleX) + 'px';
    selection.style.height = (cropSelection.height * scaleY) + 'px';
}

function handleCropMouseDown(e) {
    if (!e.target.classList.contains('crop-handle')) {
        dragMode = 'move';
        isDragging = true;
        dragStart = { x: e.clientX, y: e.clientY };
    }
}

function handleCropMouseMove(e) {
    if (!isDragging) return;
    
    const deltaX = e.clientX - dragStart.x;
    const deltaY = e.clientY - dragStart.y;
    const canvas = document.getElementById('cropCanvas');
    const canvasRect = canvas.getBoundingClientRect();
    
    // Convert screen coordinates to canvas coordinates
    const scaleX = canvas.width / canvasRect.width;
    const scaleY = canvas.height / canvasRect.height;
    const scaledDeltaX = deltaX * scaleX;
    const scaledDeltaY = deltaY * scaleY;
    
    let newSelection = { ...cropSelection };
    
    switch (dragMode) {
        case 'move':
            newSelection.x += scaledDeltaX;
            newSelection.y += scaledDeltaY;
            break;
        case 'nw':
            newSelection.x += scaledDeltaX;
            newSelection.y += scaledDeltaY;
            newSelection.width -= scaledDeltaX;
            newSelection.height -= scaledDeltaY;
            break;
        case 'ne':
            newSelection.y += scaledDeltaY;
            newSelection.width += scaledDeltaX;
            newSelection.height -= scaledDeltaY;
            break;
        case 'sw':
            newSelection.x += scaledDeltaX;
            newSelection.width -= scaledDeltaX;
            newSelection.height += scaledDeltaY;
            break;
        case 'se':
            newSelection.width += scaledDeltaX;
            newSelection.height += scaledDeltaY;
            break;
        case 'n':
            newSelection.y += scaledDeltaY;
            newSelection.height -= scaledDeltaY;
            break;
        case 's':
            newSelection.height += scaledDeltaY;
            break;
        case 'e':
            newSelection.width += scaledDeltaX;
            break;
        case 'w':
            newSelection.x += scaledDeltaX;
            newSelection.width -= scaledDeltaX;
            break;
    }
    
    // Apply aspect ratio constraint
    if (cropAspectRatio > 0) {
        if (dragMode.includes('e') || dragMode.includes('w')) {
            newSelection.height = newSelection.width / cropAspectRatio;
        } else if (dragMode.includes('n') || dragMode.includes('s')) {
            newSelection.width = newSelection.height * cropAspectRatio;
        }
    }
    
    // Constrain to canvas bounds
    newSelection.x = Math.max(0, Math.min(newSelection.x, canvas.width - newSelection.width));
    newSelection.y = Math.max(0, Math.min(newSelection.y, canvas.height - newSelection.height));
    newSelection.width = Math.max(10, Math.min(newSelection.width, canvas.width - newSelection.x));
    newSelection.height = Math.max(10, Math.min(newSelection.height, canvas.height - newSelection.y));
    
    cropSelection = newSelection;
    updateCropSelectionDisplay();
    updateCropPreview();
    updateCropInputs();
    
    dragStart = { x: e.clientX, y: e.clientY };
}

function handleCropMouseUp() {
    isDragging = false;
    dragMode = 'move';
}

function setCropAspectRatio(ratio) {
    cropAspectRatio = ratio;
    
    if (ratio > 0) {
        // Adjust current selection to match aspect ratio
        const centerX = cropSelection.x + cropSelection.width / 2;
        const centerY = cropSelection.y + cropSelection.height / 2;
        
        if (cropSelection.width / cropSelection.height > ratio) {
            // Too wide, adjust width
            cropSelection.width = cropSelection.height * ratio;
        } else {
            // Too tall, adjust height
            cropSelection.height = cropSelection.width / ratio;
        }
        
        // Re-center
        cropSelection.x = centerX - cropSelection.width / 2;
        cropSelection.y = centerY - cropSelection.height / 2;
        
        // Constrain to canvas
        const canvas = document.getElementById('cropCanvas');
        cropSelection.x = Math.max(0, Math.min(cropSelection.x, canvas.width - cropSelection.width));
        cropSelection.y = Math.max(0, Math.min(cropSelection.y, canvas.height - cropSelection.height));
        
        updateCropSelectionDisplay();
        updateCropPreview();
        updateCropInputs();
    }
}

function updateCropFromInput() {
    const canvas = document.getElementById('cropCanvas');
    const width = parseInt(document.getElementById('cropWidth').value) || cropSelection.width;
    const height = parseInt(document.getElementById('cropHeight').value) || cropSelection.height;
    const x = parseInt(document.getElementById('cropX').value) || cropSelection.x;
    const y = parseInt(document.getElementById('cropY').value) || cropSelection.y;
    
    cropSelection = {
        x: Math.max(0, Math.min(x, canvas.width - width)),
        y: Math.max(0, Math.min(y, canvas.height - height)),
        width: Math.max(10, Math.min(width, canvas.width)),
        height: Math.max(10, Math.min(height, canvas.height))
    };
    
    updateCropSelectionDisplay();
    updateCropPreview();
}

function updateCropInputs() {
    document.getElementById('cropWidth').value = Math.round(cropSelection.width);
    document.getElementById('cropHeight').value = Math.round(cropSelection.height);
    document.getElementById('cropX').value = Math.round(cropSelection.x);
    document.getElementById('cropY').value = Math.round(cropSelection.y);
}

function updateCropPreview() {
    if (!cropImage) return;
    
    const previewCanvas = document.getElementById('cropPreviewCanvas');
    const previewCtx = previewCanvas.getContext('2d');
    const canvas = document.getElementById('cropCanvas');
    
    // Calculate scale factors
    const scaleX = cropImage.width / canvas.width;
    const scaleY = cropImage.height / canvas.height;
    
    // Set preview canvas size
    previewCanvas.width = cropSelection.width;
    previewCanvas.height = cropSelection.height;
    
    // Apply image effects
    const brightness = document.getElementById('brightnessSlider').value;
    const contrast = document.getElementById('contrastSlider').value;
    const saturation = document.getElementById('saturationSlider').value;
    const blur = document.getElementById('blurSlider').value;
    
    previewCtx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%) blur(${blur}px)`;
    
    // Draw cropped image
    previewCtx.drawImage(
        cropImage,
        cropSelection.x * scaleX, cropSelection.y * scaleY,
        cropSelection.width * scaleX, cropSelection.height * scaleY,
        0, 0,
        cropSelection.width, cropSelection.height
    );
    
    // Update preview info
    document.getElementById('previewSize').textContent = `${Math.round(cropSelection.width)}x${Math.round(cropSelection.height)}`;
    document.getElementById('previewAspectRatio').textContent = `${Math.round(cropSelection.width / cropSelection.height * 100) / 100}:1`;
    
    // Estimate file size (rough approximation)
    const pixels = cropSelection.width * cropSelection.height;
    const estimatedSize = Math.round(pixels * 3 / 1024); // Rough JPEG estimate
    document.getElementById('previewFileSize').textContent = `~${estimatedSize}KB`;
    
    // Update slider value displays
    document.getElementById('brightnessValue').textContent = brightness + '%';
    document.getElementById('contrastValue').textContent = contrast + '%';
    document.getElementById('saturationValue').textContent = saturation + '%';
    document.getElementById('blurValue').textContent = blur + 'px';
}

function resetImageEffects() {
    document.getElementById('brightnessSlider').value = 100;
    document.getElementById('contrastSlider').value = 100;
    document.getElementById('saturationSlider').value = 100;
    document.getElementById('blurSlider').value = 0;
    updateCropPreview();
}

function applyImageFilter(filterType) {
    const brightness = document.getElementById('brightnessSlider');
    const contrast = document.getElementById('contrastSlider');
    const saturation = document.getElementById('saturationSlider');
    
    switch (filterType) {
        case 'grayscale':
            saturation.value = 0;
            break;
        case 'sepia':
            brightness.value = 110;
            contrast.value = 90;
            saturation.value = 180;
            break;
        case 'invert':
            brightness.value = 0;
            contrast.value = 200;
            break;
    }
    
    updateCropPreview();
}

function resetCrop() {
    const canvas = document.getElementById('cropCanvas');
    const margin = 0.25;
    cropSelection = {
        x: canvas.width * margin,
        y: canvas.height * margin,
        width: canvas.width * (1 - 2 * margin),
        height: canvas.height * (1 - 2 * margin)
    };
    
    cropAspectRatio = 0;
    resetImageEffects();
    updateCropSelectionDisplay();
    updateCropPreview();
    updateCropInputs();
}

function applyCrop() {
    updateCropPreview();
    showSuccess('Crop applied to preview');
}

function saveCroppedThumbnail() {
    if (!cropImage || !currentVideoThumbnailId) {
        showError('No image or video selected');
        return;
    }
    
    // Convert preview canvas to blob
    const previewCanvas = document.getElementById('cropPreviewCanvas');
    previewCanvas.toBlob((blob) => {
        if (!blob) {
            showError('Failed to generate cropped image');
            return;
        }
        
        // Create form data
        const formData = new FormData();
        formData.append('file', blob, 'cropped_thumbnail.jpg');
        
        // Upload cropped thumbnail
        fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail/upload`, {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                showError('Failed to save cropped thumbnail: ' + data.error);
            } else {
                showSuccess('Cropped thumbnail saved successfully');
                closeThumbnailCropModal();
                loadVideoThumbnailInfo();
                refreshVideoDisplayThumbnail();
            }
        })
        .catch(error => {
            console.error('Error saving cropped thumbnail:', error);
            showError('Error saving cropped thumbnail');
        });
    }, 'image/jpeg', 0.9);
}

function refreshVideoDisplayThumbnail() {
    // Refresh the thumbnail in the main video grid
    const videoCard = document.querySelector(`[data-video-id="${currentVideoThumbnailId}"]`);
    if (videoCard) {
        const thumbnailImg = videoCard.querySelector('img');
        if (thumbnailImg) {
            // Update with cache busting
            thumbnailImg.src = `/api/videos/${currentVideoThumbnailId}/thumbnail?t=${Date.now()}`;
        }
    }
    
    // Refresh the video list
    loadVideos();
}

// Close thumbnail modal when clicking outside
window.addEventListener('click', function(event) {
    const thumbnailModal = document.getElementById('videoThumbnailModal');
    if (event.target === thumbnailModal) {
        closeVideoThumbnailModal();
    }
});

// Enhanced Bulk Actions Functions
function toggleBulkActionsPanel() {
    const panel = document.getElementById('bulkActionsPanel');
    if (panel.style.display === 'none' || panel.style.display === '') {
        panel.style.display = 'block';
        updateBulkButtonStates();
    } else {
        panel.style.display = 'none';
    }
}

function closeBulkActionsPanel() {
    document.getElementById('bulkActionsPanel').style.display = 'none';
}

function switchBulkTab(tabName) {
    // Hide all tab contents
    const tabContents = document.querySelectorAll('.tab-content');
    tabContents.forEach(content => content.classList.remove('active'));
    
    // Deactivate all tab buttons
    const tabButtons = document.querySelectorAll('.tab-button');
    tabButtons.forEach(button => button.classList.remove('active'));
    
    // Show selected tab content
    document.getElementById(`bulk${tabName.charAt(0).toUpperCase() + tabName.slice(1)}Tab`).classList.add('active');
    
    // Activate selected tab button
    event.target.classList.add('active');
    
    updateBulkButtonStates();
}

function updateBulkButtonStates() {
    const selectedCount = document.querySelectorAll('.video-checkbox:checked').length;
    const bulkButtons = document.querySelectorAll('.bulk-btn, .bulk-btn-compact');
    
    bulkButtons.forEach(button => {
        if (button.id === 'bulkMergeBtn') {
            // Merge button requires at least 2 videos
            button.disabled = selectedCount < 2;
        } else {
            // Other bulk buttons require at least 1 video
            button.disabled = selectedCount === 0;
        }
    });
    
    // Update the bulk selected count display
    const bulkSelectedCount = document.getElementById('bulkSelectedCount');
    if (bulkSelectedCount) {
        bulkSelectedCount.textContent = `${selectedCount} video${selectedCount !== 1 ? 's' : ''} selected`;
    }
}

function getSelectedVideoIds() {
    const selectedCheckboxes = document.querySelectorAll('.video-checkbox:checked');
    return Array.from(selectedCheckboxes).map(checkbox => parseInt(checkbox.value));
}

// Enhanced bulk progress tracking
let bulkOperationState = {
    total: 0,
    completed: 0,
    failed: 0,
    currentOperation: '',
    startTime: null,
    details: []
};

function showBulkProgress(text, total = 0) {
    const progressDiv = document.getElementById('bulkProgress');
    const progressText = document.getElementById('bulkProgressText');
    const progressFill = document.getElementById('bulkProgressFill');
    
    // Initialize operation state
    bulkOperationState = {
        total: total,
        completed: 0,
        failed: 0,
        currentOperation: text,
        startTime: new Date(),
        details: []
    };
    
    const displayText = text + (total > 0 ? ` (0/${total})` : ' - Preparing...');
    progressText.innerHTML = `
        <div class="progress-main">${displayText}</div>
        <div class="progress-details" id="bulkProgressDetails" style="font-size: 12px; opacity: 0.8; margin-top: 4px;"></div>
    `;
    progressFill.style.width = '0%';
    progressDiv.style.display = 'block';
}

function updateBulkProgress(percentage, text, details = null) {
    const progressText = document.getElementById('bulkProgressText');
    const progressFill = document.getElementById('bulkProgressFill');
    const progressDetails = document.getElementById('bulkProgressDetails');
    
    // Legacy support for simple percentage updates
    if (typeof percentage === 'number') {
        progressFill.style.width = percentage + '%';
        if (text) {
            progressText.querySelector('.progress-main').textContent = text;
        }
        return;
    }
    
    // Enhanced progress update with detailed tracking
    const { completed = 0, failed = 0, total = 0, currentItem = '', operation = '' } = percentage;
    
    bulkOperationState.completed = completed;
    bulkOperationState.failed = failed;
    if (total > 0) bulkOperationState.total = total;
    if (details) bulkOperationState.details.push(details);
    
    const processed = completed + failed;
    const progressPercentage = bulkOperationState.total > 0 ? Math.round((processed / bulkOperationState.total) * 100) : 0;
    
    // Update progress bar
    progressFill.style.width = `${progressPercentage}%`;
    
    // Build status text
    let statusText = operation || bulkOperationState.currentOperation;
    if (bulkOperationState.total > 0) {
        statusText += ` (${processed}/${bulkOperationState.total})`;
        if (failed > 0) {
            statusText += ` - ${failed} failed`;
        }
    }
    
    // Update main progress text
    progressText.querySelector('.progress-main').textContent = statusText;
    
    // Update details
    if (progressDetails) {
        let detailText = '';
        
        if (currentItem) {
            detailText += `Current: ${currentItem}`;
        }
        
        // Add time estimate for operations with progress
        if (bulkOperationState.total > 0 && processed > 0 && processed < bulkOperationState.total) {
            const elapsed = (new Date() - bulkOperationState.startTime) / 1000;
            const rate = processed / elapsed;
            const remaining = bulkOperationState.total - processed;
            const estimate = Math.ceil(remaining / rate);
            
            if (estimate > 5) {
                detailText += detailText ? ` ‚Ä¢ ~${estimate}s remaining` : `~${estimate}s remaining`;
            }
        }
        
        // Show success rate for completed operations
        if (processed > 0 && detailText) {
            const successRate = Math.round((completed / processed) * 100);
            detailText += ` ‚Ä¢ ${successRate}% success rate`;
        }
        
        progressDetails.textContent = detailText;
    }
}

function hideBulkProgress() {
    const progressDiv = document.getElementById('bulkProgress');
    progressDiv.style.display = 'none';
    
    // Reset state
    bulkOperationState = { total: 0, completed: 0, failed: 0, currentOperation: '', startTime: null, details: [] };
}

// Bulk Actions Functions
function bulkDownloadSelected() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    showBulkProgress('Initiating downloads...', videoIds.length);
    
    fetch('/api/videos/bulk/download', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds
        })
    })
    .then(response => response.json())
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error initiating downloads: ' + data.error);
        } else {
            showSuccess(`Successfully initiated ${data.queued_count} downloads`);
            if (data.failed_count > 0) {
                showWarning(`Failed to queue ${data.failed_count} videos`);
            }
            loadVideos();
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error:', error);
        showError('Error initiating bulk downloads');
    });
}

function bulkDeleteSelected() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    const confirmed = confirm(`Are you sure you want to delete ${videoIds.length} selected video(s)?\n\nThis action cannot be undone.`);
    
    if (confirmed) {
        showBulkProgress('Deleting videos...', videoIds.length);
        
        fetch('/api/videos/bulk/delete', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                video_ids: videoIds
            })
        })
        .then(response => response.json())
        .then(data => {
            hideBulkProgress();
            if (data.deleted_count > 0) {
                showSuccess(`Successfully deleted ${data.deleted_count} video(s)`);
            }
            if (data.failed_count > 0) {
                showWarning(`Failed to delete ${data.failed_count} video(s)`);
            }
            loadVideos();
            updateSelectedCount();
        })
        .catch(error => {
            hideBulkProgress();
            console.error('Error:', error);
            showError('Error deleting videos');
        });
    }
}

function bulkRefreshMetadata() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    const confirmed = confirm(`Refresh metadata from IMVDb for ${videoIds.length} selected video(s)? This will update year, directors, producers, and thumbnail information.`);
    
    if (confirmed) {
        showBulkProgress('Refreshing metadata...');
        
        fetch('/api/videos/bulk/refresh-metadata', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                video_ids: videoIds
            })
        })
        .then(response => response.json())
        .then(data => {
            hideBulkProgress();
            if (data.updated_count > 0) {
                showSuccess(`Successfully refreshed metadata for ${data.updated_count} video(s)`);
            }
            if (data.failed_count > 0) {
                showWarning(`Failed to refresh metadata for ${data.failed_count} video(s)`);
            }
            if (data.skipped_count > 0) {
                showInfo(`Skipped ${data.skipped_count} video(s) - no IMVDb ID available`);
            }
            loadVideos();
            updateSelectedCount();
        })
        .catch(error => {
            hideBulkProgress();
            console.error('Error:', error);
            showError('Error refreshing metadata');
        });
    }
}

function bulkSetStatus(status) {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    showBulkProgress(`Setting status to ${status}...`);
    
    fetch('/api/videos/bulk/status', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds,
            status: status
        })
    })
    .then(response => response.json())
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error updating status: ' + data.error);
        } else {
            showSuccess(`Successfully updated status for ${data.updated_count} videos`);
            loadVideos();
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error:', error);
        showError('Error updating video status');
    });
}

function applyBulkEdit() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    const updates = {};
    
    // Collect changes
    const artistChange = document.getElementById('bulkArtistChange').value.trim();
    const yearChange = document.getElementById('bulkYearChange').value.trim();
    const statusChange = document.getElementById('bulkStatusChange').value;
    const priorityChange = document.getElementById('bulkPriorityChange').value;
    
    if (artistChange) updates.artist_name = artistChange;
    if (yearChange) updates.year = parseInt(yearChange);
    if (statusChange) updates.status = statusChange;
    if (priorityChange) updates.priority = priorityChange;
    
    if (Object.keys(updates).length === 0) {
        showError('No changes specified');
        return;
    }
    
    showBulkProgress('Applying bulk edits...');
    
    fetch('/api/videos/bulk/edit', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds,
            updates: updates
        })
    })
    .then(response => response.json())
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error applying bulk edits: ' + data.error);
        } else {
            showSuccess(`Successfully updated ${data.updated_count} videos`);
            loadVideos();
            
            // Clear form
            document.getElementById('bulkArtistChange').value = '';
            document.getElementById('bulkYearChange').value = '';
            document.getElementById('bulkStatusChange').value = '';
            document.getElementById('bulkPriorityChange').value = '';
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error:', error);
        showError('Error applying bulk edits');
    });
}

function bulkOrganizeFiles() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    const options = {
        create_folders: document.getElementById('bulkCreateFolders').checked,
        rename_files: document.getElementById('bulkRenameFiles').checked,
        remove_duplicates: document.getElementById('bulkRemoveDuplicates').checked
    };
    
    showBulkProgress('Organizing files...');
    
    fetch('/api/videos/bulk/organize', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds,
            options: options
        })
    })
    .then(response => response.json())
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error organizing files: ' + data.error);
        } else {
            showSuccess(`Successfully organized ${data.organized_count} files`);
            if (data.failed_count > 0) {
                showWarning(`Failed to organize ${data.failed_count} files`);
            }
            loadVideos();
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error:', error);
        showError('Error organizing files');
    });
}

function bulkCheckQuality() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    showBulkProgress('Checking video quality...', videoIds.length);
    
    fetch('/api/videos/bulk/quality-check', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds
        })
    })
    .then(response => {
        if (!response.ok) {
            if (response.status === 404) {
                throw new Error('Quality check feature is not available (endpoint not found)');
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            return response.json();
        } else {
            return response.text().then(text => {
                throw new Error(`Expected JSON but received: ${text.substring(0, 200)}...`);
            });
        }
    })
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error checking quality: ' + data.error);
        } else {
            showSuccess(`Quality check completed for ${data.checked_count} videos. Found ${data.issues_count || 0} quality issues.`);
            // Refresh the video list to show updated quality info
            refreshVideos();
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error checking quality:', error);
        showError('Error checking quality: ' + error.message);
    });
}

function bulkUpgradeQuality() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    if (!confirm(`Are you sure you want to upgrade the quality of ${videoIds.length} selected video${videoIds.length > 1 ? 's' : ''}? This will re-download higher quality versions.`)) {
        return;
    }
    
    showBulkProgress('Upgrading video quality...', videoIds.length);
    
    fetch('/api/videos/bulk/upgrade-quality', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds
        })
    })
    .then(response => {
        if (!response.ok) {
            if (response.status === 404) {
                throw new Error('Quality upgrade feature is not available (endpoint not found)');
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            return response.json();
        } else {
            return response.text().then(text => {
                throw new Error(`Expected JSON but received: ${text.substring(0, 200)}...`);
            });
        }
    })
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error upgrading quality: ' + data.error);
        } else {
            showSuccess(`Quality upgrade initiated for ${data.queued_count} videos.`);
            refreshVideos();
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error upgrading quality:', error);
        showError('Error upgrading quality: ' + error.message);
    });
}

function bulkTranscode() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    if (!confirm(`Are you sure you want to transcode ${videoIds.length} selected video${videoIds.length > 1 ? 's' : ''}? This process may take a long time.`)) {
        return;
    }
    
    showBulkProgress('Starting transcode jobs...', videoIds.length);
    
    fetch('/api/videos/bulk/transcode', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds
        })
    })
    .then(response => {
        if (!response.ok) {
            if (response.status === 404) {
                throw new Error('Transcode feature is not available (endpoint not found)');
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            return response.json();
        } else {
            return response.text().then(text => {
                throw new Error(`Expected JSON but received: ${text.substring(0, 200)}...`);
            });
        }
    })
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error starting transcode: ' + data.error);
        } else {
            showSuccess(`Transcode jobs started for ${data.queued_count} videos.`);
            refreshVideos();
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error starting transcode:', error);
        showError('Error starting transcode: ' + error.message);
    });
}

// Bulk Video Merge Functions
function showBulkVideoMergeModal() {
    const selectedVideos = getSelectedVideoIds();
    if (selectedVideos.length < 2) {
        showError('Please select at least 2 videos to merge');
        return;
    }
    
    document.getElementById('bulkVideoMergeModal').style.display = 'block';
    updateSelectedVideosDisplay();
    updateMergeMode();
}

function closeBulkVideoMergeModal() {
    document.getElementById('bulkVideoMergeModal').style.display = 'none';
    document.getElementById('mergePreview').style.display = 'none';
    document.getElementById('performMergeBtn').disabled = true;
}

function updateMergeMode() {
    const mode = document.querySelector('input[name="mergeMode"]:checked').value;
    const autoOptions = document.getElementById('autoMergeOptions');
    const manualOptions = document.getElementById('manualMergeOptions');
    
    if (mode === 'auto') {
        autoOptions.style.display = 'block';
        manualOptions.style.display = 'none';
    } else {
        autoOptions.style.display = 'none';
        manualOptions.style.display = 'block';
        updateSelectedVideosDisplay();
    }
}

function updateSimilarityDisplay() {
    const threshold = document.getElementById('similarityThreshold').value;
    document.getElementById('similarityDisplay').textContent = threshold + '%';
}

function updateSelectedVideosDisplay() {
    const selectedVideoIds = getSelectedVideoIds();
    const container = document.getElementById('selectedVideosForMerge');
    
    if (selectedVideoIds.length < 2) {
        container.innerHTML = '<p class="text-muted">Please select at least 2 videos to merge.</p>';
        return;
    }
    
    // Get video information for selected videos
    const videoCards = document.querySelectorAll('.video-card');
    const selectedVideos = [];
    
    videoCards.forEach(card => {
        const checkbox = card.querySelector('.video-checkbox');
        if (checkbox && checkbox.checked) {
            const videoId = checkbox.value;
            const title = card.querySelector('.video-title').textContent;
            const artist = card.querySelector('.video-artist').textContent;
            const quality = card.querySelector('.video-quality')?.textContent || 'Unknown';
            const duration = card.querySelector('.video-duration')?.textContent || 'Unknown';
            
            selectedVideos.push({
                id: videoId,
                title: title,
                artist: artist,
                quality: quality,
                duration: duration
            });
        }
    });
    
    container.innerHTML = selectedVideos.map(video => `
        <div class="video-merge-item">
            <div class="video-info-compact">
                <strong>${video.title}</strong><br>
                <span class="text-muted">${video.artist} ‚Ä¢ ${video.quality} ‚Ä¢ ${video.duration}</span>
            </div>
        </div>
    `).join('');
}

function previewMerge() {
    const mode = document.querySelector('input[name="mergeMode"]:checked').value;
    const selectedVideoIds = getSelectedVideoIds();
    
    if (mode === 'manual' && selectedVideoIds.length < 2) {
        showError('Please select at least 2 videos to merge');
        return;
    }
    
    // Show loading state
    const previewContainer = document.getElementById('mergePreview');
    const groupsContainer = document.getElementById('mergeGroupsContainer');
    
    previewContainer.style.display = 'block';
    groupsContainer.innerHTML = '<div class="loading-spinner"><img src="{{ url_for("static", filename="MVidarr.png") }}" alt="MVidarr" class="spinning mvidarr-logo-spinner" style="width: 24px; height: 24px;"></div><p>Analyzing videos for merge...</p>';
    
    const requestData = {
        mode: mode,
        video_ids: mode === 'manual' ? selectedVideoIds : [],
        options: {}
    };
    
    if (mode === 'auto') {
        requestData.options = {
            match_title: document.getElementById('matchTitle').checked,
            match_artist: document.getElementById('matchArtist').checked,
            match_duration: document.getElementById('matchDuration').checked,
            similarity_threshold: parseInt(document.getElementById('similarityThreshold').value)
        };
    } else {
        requestData.options = {
            primary_strategy: document.getElementById('primaryVideoStrategy').value
        };
    }
    
    fetch('/api/videos/bulk/merge-preview', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            groupsContainer.innerHTML = `<div class="error-message">${data.error}</div>`;
            document.getElementById('performMergeBtn').disabled = true;
            return;
        }
        
        if (data.merge_groups.length === 0) {
            groupsContainer.innerHTML = '<p class="text-muted">No duplicate videos found to merge.</p>';
            document.getElementById('performMergeBtn').disabled = true;
            return;
        }
        
        // Display merge groups
        groupsContainer.innerHTML = data.merge_groups.map((group, index) => `
            <div class="merge-group">
                <h5>Merge Group ${index + 1}</h5>
                <div class="merge-videos">
                    <div class="primary-video">
                        <strong>Primary (Keep):</strong>
                        <div class="video-merge-item primary">
                            <strong>${group.primary.title}</strong><br>
                            <span class="text-muted">${group.primary.artist_name} ‚Ä¢ ${group.primary.quality || 'Unknown'} ‚Ä¢ ${group.primary.duration || 'Unknown'}s</span>
                        </div>
                    </div>
                    <div class="merge-videos-list">
                        <strong>To Merge (Remove):</strong>
                        ${group.duplicates.map(video => `
                            <div class="video-merge-item duplicate">
                                <strong>${video.title}</strong><br>
                                <span class="text-muted">${video.artist_name} ‚Ä¢ ${video.quality || 'Unknown'} ‚Ä¢ ${video.duration || 'Unknown'}s</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
                <div class="merge-summary">
                    <small class="text-muted">
                        ${group.duplicates.length} video(s) will be merged into the primary video.
                        Playlists and metadata will be transferred.
                    </small>
                </div>
            </div>
        `).join('');
        
        document.getElementById('performMergeBtn').disabled = false;
    })
    .catch(error => {
        console.error('Error previewing merge:', error);
        groupsContainer.innerHTML = `<div class="error-message">Error previewing merge: ${error.message}</div>`;
        document.getElementById('performMergeBtn').disabled = true;
    });
}

function performBulkVideoMerge() {
    const mode = document.querySelector('input[name="mergeMode"]:checked').value;
    const selectedVideoIds = getSelectedVideoIds();
    
    if (!confirm('Are you sure you want to perform this merge? This action cannot be undone.')) {
        return;
    }
    
    const requestData = {
        mode: mode,
        video_ids: mode === 'manual' ? selectedVideoIds : [],
        options: {}
    };
    
    if (mode === 'auto') {
        requestData.options = {
            match_title: document.getElementById('matchTitle').checked,
            match_artist: document.getElementById('matchArtist').checked,
            match_duration: document.getElementById('matchDuration').checked,
            similarity_threshold: parseInt(document.getElementById('similarityThreshold').value)
        };
    } else {
        requestData.options = {
            primary_strategy: document.getElementById('primaryVideoStrategy').value
        };
    }
    
    // Show progress
    showBulkProgress('Merging videos...', selectedVideoIds.length);
    
    fetch('/api/videos/bulk/merge', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
    })
    .then(response => response.json())
    .then(data => {
        hideBulkProgress();
        
        if (data.error) {
            showError('Error performing merge: ' + data.error);
            return;
        }
        
        showSuccess(`Successfully merged ${data.merged_count} video(s) in ${data.merge_groups.length} group(s).`);
        closeBulkVideoMergeModal();
        refreshVideos();
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error performing merge:', error);
        showError('Error performing merge: ' + error.message);
    });
}

// Selection helper functions
function selectByStatus() {
    const status = prompt('Select videos by status (WANTED, DOWNLOADING, DOWNLOADED, IGNORED, FAILED):');
    if (!status) return;
    
    const videoCards = document.querySelectorAll('.video-card');
    videoCards.forEach(card => {
        const statusText = card.querySelector('.video-info p:nth-child(3)').textContent;
        const checkbox = card.querySelector('.video-checkbox');
        
        if (statusText.includes(status.toUpperCase())) {
            checkbox.checked = true;
        }
    });
    
    updateSelectedCount();
}

function selectByArtist() {
    const artist = prompt('Select videos by artist:');
    if (!artist) return;
    
    const videoCards = document.querySelectorAll('.video-card');
    videoCards.forEach(card => {
        const artistText = card.querySelector('.video-info p:nth-child(2)').textContent;
        const checkbox = card.querySelector('.video-checkbox');
        
        if (artistText.toLowerCase().includes(artist.toLowerCase())) {
            checkbox.checked = true;
        }
    });
    
    updateSelectedCount();
}

function selectByYear() {
    const year = prompt('Select videos by year:');
    if (!year) return;
    
    const videoCards = document.querySelectorAll('.video-card');
    videoCards.forEach(card => {
        const yearElement = card.querySelector('.video-info p:nth-child(4)');
        const checkbox = card.querySelector('.video-checkbox');
        
        if (yearElement && yearElement.textContent.includes(year)) {
            checkbox.checked = true;
        }
    });
    
    updateSelectedCount();
}

function deselectAll() {
    const checkboxes = document.querySelectorAll('.video-checkbox');
    checkboxes.forEach(checkbox => checkbox.checked = false);
    document.getElementById('selectAllVideos').checked = false;
    updateSelectedCount();
}

// Update the existing updateSelectedCount function to work with new bulk actions
function updateSelectedCount() {
    const selectedCheckboxes = document.querySelectorAll('.video-checkbox:checked');
    const count = selectedCheckboxes.length;
    
    document.getElementById('selectedCount').textContent = count;
    
    // Update legacy delete button
    const deleteBtn = document.getElementById('deleteSelectedBtn');
    if (deleteBtn) {
        deleteBtn.disabled = count === 0;
    }
    
    // Update bulk action buttons
    updateBulkButtonStates();
    
    // Update select all checkbox state
    const selectAllCheckbox = document.getElementById('selectAllVideos');
    const videoCheckboxes = document.querySelectorAll('.video-checkbox');
    
    if (count === 0) {
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.checked = false;
    } else if (count === videoCheckboxes.length) {
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.checked = true;
    } else {
        selectAllCheckbox.indeterminate = true;
    }
}

// Close bulk actions panel when clicking outside
window.addEventListener('click', function(event) {
    const bulkPanel = document.getElementById('bulkActionsPanel');
    const bulkButton = document.getElementById('bulkActionsToggle');
    
    if (event.target === bulkPanel) {
        closeBulkActionsPanel();
    }
});

// Pagination Functions
// Old updatePaginationControls function removed - replaced by updatePagination

function nextPage() {
    if (currentPage < totalPages) {
        loadVideos(currentPage + 1, pageSize);
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function previousPage() {
    if (currentPage > 1) {
        loadVideos(currentPage - 1, pageSize);
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function goToPage(page) {
    const pageNum = parseInt(page);
    if (pageNum >= 1 && pageNum <= totalPages && pageNum !== currentPage) {
        loadVideos(pageNum, pageSize);
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    } else {
        // Reset invalid input
        document.getElementById('pageInputTop').value = currentPage;
        document.getElementById('pageInputBottom').value = currentPage;
    }
}

function changePageSize(newSize) {
    const size = parseInt(newSize);
    if (size !== pageSize) {
        pageSize = size;
        // Reset to page 1 when changing page size
        loadVideos(1, pageSize, true);
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

// Display videos in the grid
function displayVideos(videos) {
    const grid = document.getElementById('videos-grid');
    
    if (videos && videos.length > 0) {
        try {
            grid.innerHTML = videos.map(video => {
                // Safely escape and validate video data
                const safeVideo = {
                    id: video.id || '',
                    title: escapeHtml(video.title || 'Unknown Title'),
                    artist_name: escapeHtml(video.artist_name || 'Unknown'),
                    artist_id: video.artist_id || null,
                    status: escapeHtml(video.status || 'UNKNOWN'),
                    year: video.year || null
                };
                
                return `
                    <div class="video-card">
                        <div class="video-select">
                            <input type="checkbox" class="video-checkbox" value="${safeVideo.id}" onchange="updateSelectedCount()">
                        </div>
                        <div class="video-thumbnail" data-video-id="${safeVideo.id}" data-action="play">
                            <img src="/api/videos/${safeVideo.id}/thumbnail" 
                                 alt="${safeVideo.title}" onerror="this.src='/static/placeholder-video.png'">
                            <div class="play-overlay">
                                <div class="play-button">‚ñ∂</div>
                            </div>
                        </div>
                        <div class="video-info">
                            <h3>${safeVideo.title}</h3>
                            <p>Artist: ${safeVideo.artist_id ? `<a href="/artist/${safeVideo.artist_id}" class="artist-link">${safeVideo.artist_name}</a>` : safeVideo.artist_name}</p>
                            <p>Status: ${safeVideo.status}</p>
                            ${safeVideo.year ? `<p>Year: ${safeVideo.year}</p>` : ''}
                            <div class="video-metadata">
                                ${safeVideo.quality ? `<span class="metadata-item quality">üì∫ ${safeVideo.quality}</span>` : ''}
                                ${safeVideo.duration ? `<span class="metadata-item duration">‚è±Ô∏è ${formatDuration(safeVideo.duration)}</span>` : ''}
                            </div>
                        </div>
                        <div class="video-actions">
                            <button data-video-id="${safeVideo.id}" data-action="view" class="btn-icon" title="View Details">
                                <i class="icon-eye"></i>
                            </button>
                            <button data-video-id="${safeVideo.id}" data-action="edit" class="btn-icon" title="Edit Video">
                                <i class="icon-edit"></i>
                            </button>
                            <button data-video-id="${safeVideo.id}" data-action="add-to-playlist" class="btn-icon" title="Add to Playlist">
                                <iconify-icon icon="tabler:playlist-add"></iconify-icon>
                            </button>
                            <button data-video-id="${safeVideo.id}" data-action="refresh-metadata" class="btn-icon" title="Refresh Metadata">
                                <i class="icon-refresh"></i>
                            </button>
                            ${safeVideo.status === 'WANTED' ? 
                                `<button data-video-id="${safeVideo.id}" data-action="download" class="btn-icon" title="Download Video">
                                    <i class="icon-download"></i>
                                </button>` : 
                                ''}
                            <button data-video-id="${safeVideo.id}" data-action="delete" class="btn-icon btn-danger" title="Delete Video">
                                <i class="icon-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        } catch (error) {
            console.error('Error rendering videos:', error);
            grid.innerHTML = '<div class="error-message">Error displaying videos. Please refresh the page.</div>';
        }
    } else {
        grid.innerHTML = '<p>No videos found.</p>';
    }
}

// Helper function to escape HTML and prevent XSS
function escapeHtml(text) {
    if (typeof text !== 'string') {
        return String(text || '');
    }
    
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Helper function to format duration in seconds to MM:SS format
function formatDuration(seconds) {
    if (!seconds || seconds === 0 || isNaN(seconds)) return 'N/A';
    
    const numSeconds = typeof seconds === 'string' ? parseInt(seconds) : seconds;
    if (isNaN(numSeconds) || numSeconds <= 0) return 'N/A';
    
    const minutes = Math.floor(numSeconds / 60);
    const remainingSeconds = numSeconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

// Update pagination controls based on API response
function updatePagination(data) {
    const totalVideos = data.total || 0;
    const currentTotal = data.count || 0;
    
    // Calculate pagination values
    totalPages = Math.ceil(totalVideos / pageSize);
    const startIndex = totalVideos > 0 ? ((currentPage - 1) * pageSize) + 1 : 0;
    const endIndex = Math.min(currentPage * pageSize, totalVideos);
    
    // Update pagination info displays
    const topInfo = document.getElementById('videoCountInfo');
    const bottomInfo = document.getElementById('videoCountInfoBottom');
    const infoText = `Showing ${startIndex}-${endIndex} of ${totalVideos} videos`;
    
    if (topInfo) topInfo.textContent = infoText;
    if (bottomInfo) bottomInfo.textContent = infoText;
    
    // Update total pages displays
    document.getElementById('totalPagesTop').textContent = totalPages;
    document.getElementById('totalPagesBottom').textContent = totalPages;
    
    // Update page inputs
    document.getElementById('pageInputTop').value = currentPage;
    document.getElementById('pageInputBottom').value = currentPage;
    document.getElementById('pageInputTop').max = totalPages;
    document.getElementById('pageInputBottom').max = totalPages;
    
    // Update page size display
    document.getElementById('currentPageSize').textContent = pageSize;
    document.getElementById('pageSizeSelect').value = pageSize;
    
    // Update button states
    const hasPrevious = currentPage > 1;
    const hasNext = currentPage < totalPages;
    
    document.getElementById('prevPageTop').disabled = !hasPrevious;
    document.getElementById('prevPageBottom').disabled = !hasPrevious;
    document.getElementById('nextPageTop').disabled = !hasNext;
    document.getElementById('nextPageBottom').disabled = !hasNext;
    
    // Show pagination controls when we have videos (even if only one page)
    const showPagination = totalVideos > 0;
    document.getElementById('topPagination').style.display = showPagination ? 'flex' : 'none';
    document.getElementById('bottomPagination').style.display = showPagination ? 'flex' : 'none';
    
    console.log(`Pagination updated: page ${currentPage} of ${totalPages}, showing ${startIndex}-${endIndex} of ${totalVideos} videos`);
}

// Core video loading function with proper authentication
async function loadVideos(page = 1, size = 50, resetPage = false) {
    console.log(`Loading videos: page=${page}, size=${size}`);
    
    // Update pagination state
    if (resetPage) {
        currentPage = 1;
    } else {
        currentPage = page;
    }
    pageSize = size;
    
    try {
        // Show loading state
        const grid = document.getElementById('videos-grid');
        if (grid) {
            grid.innerHTML = '<div class="loading-spinner"><img src="{{ url_for("static", filename="MVidarr.png") }}" alt="MVidarr" class="spinning mvidarr-logo-spinner" style="width: 24px; height: 24px;">Loading videos...</div>';
        }
        
        // Build API URL with pagination
        const params = new URLSearchParams({
            limit: pageSize,
            offset: (currentPage - 1) * pageSize,
            sort: 'title',
            order: 'asc'
        });
        
        // Make authenticated API request - credentials: 'same-origin' includes session cookies
        const response = await fetch(`/api/videos?${params.toString()}`, {
            method: 'GET',
            credentials: 'same-origin',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            if (response.status === 401) {
                // Handle authentication required
                window.location.href = '/simple-login';
                return;
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Videos loaded:', data);
        
        // Validate response data structure
        if (!data || typeof data !== 'object') {
            throw new Error('Invalid response format from server');
        }
        
        // Ensure videos is an array
        const videos = Array.isArray(data.videos) ? data.videos : [];
        
        // Filter out any malformed video entries
        const validVideos = videos.filter(video => {
            if (!video || typeof video !== 'object') return false;
            if (!video.id) return false;
            return true;
        });
        
        console.log(`Displaying ${validVideos.length} valid videos out of ${videos.length} total`);
        
        // Display videos
        displayVideos(validVideos);
        
        // Update pagination
        updatePagination(data);
        
        // Update selected count
        updateSelectedCount();
        
    } catch (error) {
        showEnhancedError(error, 'loading videos');
        const grid = document.getElementById('videos-grid');
        if (grid) {
            const errorInfo = categorizeError(error, 'loading videos');
            grid.innerHTML = `
                <div class="error-message">
                    <div class="error-title">${errorInfo.message}</div>
                    ${errorInfo.guidance ? `<div class="error-guidance">${errorInfo.guidance}</div>` : ''}
                    <button onclick="loadVideos()" class="btn btn-primary retry-btn">üîÑ Retry</button>
                </div>
            `;
        }
        
        // Hide pagination on error
        document.getElementById('topPagination').style.display = 'none';
        document.getElementById('bottomPagination').style.display = 'none';
    }
}

// Provide global function for refreshing videos with current pagination
window.refreshVideosWithPagination = function() {
    loadVideos(currentPage, pageSize);
};

// Backward compatibility function for existing refresh buttons
window.refreshVideos = function() {
    loadVideos(currentPage, pageSize);
};

// Toggle search panel visibility - make globally accessible
window.toggleSearchPanel = function() {
    const searchPanel = document.getElementById('videoSearchPanel');
    if (searchPanel) {
        const isVisible = searchPanel.style.display !== 'none';
        searchPanel.style.display = isVisible ? 'none' : 'block';
        
        // Focus on search input when panel is shown
        if (!isVisible) {
            const searchInput = document.getElementById('videoSearchInput');
            if (searchInput) {
                setTimeout(() => searchInput.focus(), 100);
            }
        }
    }
};

// Update other functions to use the new pagination-aware reload
function refreshVideoList() {
    loadVideos(currentPage, pageSize);
}

// Initialize videos when page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log('Videos page loaded, initializing...');
    loadVideos();
});

// Event delegation for video actions
document.addEventListener('click', function(event) {
    const target = event.target.closest('[data-action]');
    if (!target) return;
    
    const action = target.dataset.action;
    const videoId = target.dataset.videoId;
    
    if (!videoId) return;
    
    switch(action) {
        case 'play':
            playVideoById(videoId);
            break;
        case 'view':
            viewVideo(videoId);
            break;
        case 'edit':
            editVideo(videoId);
            break;
        case 'add-to-playlist':
            addSingleVideoToPlaylist(videoId);
            break;
        case 'refresh-metadata':
            refreshVideoMetadata(videoId);
            break;
        case 'download':
            downloadVideo(videoId);
            break;
        case 'delete':
            deleteVideo(videoId);
            break;
    }
});

// Helper function to get video data and play it
async function playVideoById(videoId) {
    try {
        const response = await fetch(`/api/videos/${videoId}`, {
            credentials: 'same-origin'
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const video = await response.json();
        playVideo(video.id, video.title, video.local_path, video.video_url);
    } catch (error) {
        console.error('Error fetching video for playback:', error);
        showError('Error loading video for playback');
    }
}
</script>

<!-- Include shared Add Video modal component -->
{% include 'components/add_video_modal.html' %}

<!-- UI Enhancement Scripts - ENABLED for playlist functionality -->
<script src="{{ url_for('frontend.js_files', filename='video-management-enhanced.js') }}?v=20241213-1620"></script>
<!-- Temporarily disabled virtualization to debug loading issue
<script src="{{ url_for('frontend.js_files', filename='virtualization-engine.js') }}?v=20250813-1447"></script>
<script src="{{ url_for('frontend.js_files', filename='video-virtualization-integration.js') }}"></script>
-->

<script>
// Playlist Global Functions - Fallback registration
window.addEventListener('DOMContentLoaded', function() {
    // Wait for video management to load, then register fallback functions
    setTimeout(function() {
        if (typeof window.showBulkAddToPlaylistModal === 'undefined' && window.videoManagementUI) {
            console.log('Registering fallback playlist functions');
            window.showBulkAddToPlaylistModal = () => window.videoManagementUI.showBulkAddToPlaylistModal();
            window.bulkCreatePlaylistFromSelection = () => window.videoManagementUI.bulkCreatePlaylistFromSelection();
            window.addVideosToPlaylist = () => window.videoManagementUI.addVideosToPlaylist();
            window.closeAddToPlaylistModal = () => window.videoManagementUI.closeAddToPlaylistModal();
        }
        
        // Direct implementation if videoManagementUI doesn't load
        if (typeof window.showBulkAddToPlaylistModal === 'undefined') {
            console.log('Implementing direct playlist functions');
            window.showBulkAddToPlaylistModal = showBulkAddToPlaylistModal;
            window.closeAddToPlaylistModal = closeAddToPlaylistModal;
            window.addVideosToPlaylist = addVideosToPlaylist;
        }
    }, 1000);
});

// Direct playlist modal functions implementation
function showBulkAddToPlaylistModal() {
    const selectedCheckboxes = document.querySelectorAll('.video-checkbox:checked');
    if (selectedCheckboxes.length === 0) {
        showErrorMessage('Please select at least one video to add to a playlist.');
        return;
    }

    // Show selected video count
    document.getElementById('selectedVideosCount').textContent = selectedCheckboxes.length;
    
    // Load and display selected videos preview
    const selectedVideosList = document.getElementById('selectedVideosList');
    const videoCards = Array.from(selectedCheckboxes).map(checkbox => {
        const videoCard = checkbox.closest('.video-card');
        const title = videoCard.querySelector('.video-info h3')?.textContent || 'Unknown Title';
        const artist = videoCard.querySelector('.video-info p')?.textContent || 'Unknown Artist';
        return `<div class="selected-video-item">${title} - ${artist}</div>`;
    }).join('');
    selectedVideosList.innerHTML = videoCards;
    
    // Load playlists into select dropdown
    loadPlaylistsIntoSelect();
    
    // Show the modal
    document.getElementById('addToPlaylistModal').style.display = 'block';
}

function closeAddToPlaylistModal() {
    document.getElementById('addToPlaylistModal').style.display = 'none';
}

async function loadPlaylistsIntoSelect() {
    const playlistSelect = document.getElementById('playlistSelect');
    const createPlaylistGroup = document.getElementById('createPlaylistGroup');
    
    try {
        playlistSelect.innerHTML = '<option value="">Loading playlists...</option>';
        
        const response = await fetch('/api/playlists/');
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.playlists && data.playlists.length > 0) {
            // Populate with existing playlists
            playlistSelect.innerHTML = '<option value="">Select a playlist...</option>' +
                data.playlists.map(playlist => 
                    `<option value="${playlist.id}">${playlist.name} (${playlist.video_count || 0} videos)</option>`
                ).join('');
            createPlaylistGroup.style.display = 'block';
        } else {
            // No playlists exist
            playlistSelect.innerHTML = '<option value="">No playlists available</option>';
            createPlaylistGroup.style.display = 'block';
        }
    } catch (error) {
        console.error('Error loading playlists:', error);
        playlistSelect.innerHTML = '<option value="">Error loading playlists</option>';
        createPlaylistGroup.style.display = 'block';
        showErrorMessage('Failed to load playlists: ' + error.message);
    }
}

function addSingleVideoToPlaylist(videoId) {
    // Create a temporary checkbox to simulate selection for bulk function
    const existingSelection = document.querySelectorAll('.video-checkbox:checked');
    
    // First uncheck all existing selections to avoid adding extra videos
    existingSelection.forEach(checkbox => checkbox.checked = false);
    
    // Find and check the specific video
    const videoCheckbox = document.querySelector(`.video-checkbox[value="${videoId}"]`);
    if (!videoCheckbox) {
        showErrorMessage('Video not found for playlist addition.');
        return;
    }
    
    videoCheckbox.checked = true;
    
    // Use the existing bulk function
    showBulkAddToPlaylistModal();
    
    // Restore original selection after modal is shown
    setTimeout(() => {
        videoCheckbox.checked = false;
        existingSelection.forEach(checkbox => checkbox.checked = true);
        updateSelectedCount();
    }, 100);
}

async function addVideosToPlaylist() {
    const playlistSelect = document.getElementById('playlistSelect');
    const selectedPlaylistId = playlistSelect.value;
    
    if (!selectedPlaylistId) {
        showErrorMessage('Please select a playlist.');
        return;
    }
    
    const selectedCheckboxes = document.querySelectorAll('.video-checkbox:checked');
    const videoIds = Array.from(selectedCheckboxes).map(checkbox => parseInt(checkbox.value));
    
    if (videoIds.length === 0) {
        showErrorMessage('No videos selected.');
        return;
    }
    
    const confirmBtn = document.getElementById('addToPlaylistConfirmBtn');
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '<iconify-icon icon="tabler:loader-2"></iconify-icon> Adding...';
    
    try {
        const response = await fetch(`/api/playlists/${selectedPlaylistId}/videos`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                video_ids: videoIds
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        showSuccessMessage(`Successfully added ${videoIds.length} video(s) to playlist.`);
        closeAddToPlaylistModal();
        
        // Clear selections
        selectedCheckboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        updateSelectedCount();
        
    } catch (error) {
        console.error('Error adding videos to playlist:', error);
        showErrorMessage('Failed to add videos to playlist: ' + error.message);
    } finally {
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = '<iconify-icon icon="tabler:check"></iconify-icon> Add to Playlist';
    }
}

// Duplicate Video Merge Dialog Functions
function showDuplicateVideoDialog(duplicateData, originalContent, videoCard) {
    // Restore original video card content
    videoCard.innerHTML = originalContent;
    
    // Helper function to format duration
    function formatDuration(seconds) {
        if (!seconds) return 'N/A';
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }
    
    // Helper function to get thumbnail URL - try multiple sources
    function getThumbnailUrl(video) {
        // Try thumbnail_path first (local thumbnails)
        if (video.thumbnail_path) {
            return `/api/videos/${video.id}/thumbnail`;
        }
        // Try thumbnail_url (external thumbnails)
        if (video.thumbnail_url) {
            return video.thumbnail_url;
        }
        // Default to a simple colored placeholder
        return `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="120" height="80" viewBox="0 0 120 80"><rect width="120" height="80" fill="%23e0e0e0"/><text x="60" y="45" text-anchor="middle" font-family="Arial" font-size="12" fill="%23888">üìπ</text></svg>`;
    }
    
    // Create and show merge modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.id = 'duplicateVideoModal';
    modal.innerHTML = `
        <div class="modal-content duplicate-modal-content">
            <span class="close" onclick="hideDuplicateVideoModal()">&times;</span>
            <h2>üîÄ Duplicate Video Found</h2>
            <p><strong>A video with the same IMVDb ID already exists!</strong> Choose which to keep as primary:</p>
            
            <div class="duplicate-video-comparison-compact">
                <div class="video-option-compact">
                    <div class="video-selection">
                        <input type="radio" name="primaryVideo" value="${duplicateData.current_video.id}" id="current_video" checked>
                        <label for="current_video" class="selection-label">Select as Primary</label>
                    </div>
                    <div class="video-content">
                        <div class="video-thumbnail-small">
                            <img src="${getThumbnailUrl(duplicateData.current_video)}" alt="Video thumbnail">
                        </div>
                        <div class="video-info">
                            <h4>Current Video (${duplicateData.current_video.id})</h4>
                            <div class="info-grid">
                                <span><strong>Title:</strong> ${duplicateData.current_video.title || 'Unknown'}</span>
                                <span><strong>Artist:</strong> ${duplicateData.current_video.artist || 'Unknown'}</span>
                                <span><strong>Quality:</strong> ${duplicateData.current_video.quality || 'N/A'}</span>
                                <span><strong>Duration:</strong> ${formatDuration(duplicateData.current_video.duration)}</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="vs-divider-compact">VS</div>
                
                <div class="video-option-compact">
                    <div class="video-selection">
                        <input type="radio" name="primaryVideo" value="${duplicateData.duplicate_video.id}" id="existing_video">
                        <label for="existing_video" class="selection-label">Select as Primary</label>
                    </div>
                    <div class="video-content">
                        <div class="video-thumbnail-small">
                            <img src="${getThumbnailUrl(duplicateData.duplicate_video)}" alt="Video thumbnail">
                        </div>
                        <div class="video-info">
                            <h4>Existing Video (${duplicateData.duplicate_video.id})</h4>
                            <div class="info-grid">
                                <span><strong>Title:</strong> ${duplicateData.duplicate_video.title || 'Unknown'}</span>
                                <span><strong>Artist:</strong> ${duplicateData.duplicate_video.artist || 'Unknown'}</span>
                                <span><strong>Quality:</strong> ${duplicateData.duplicate_video.quality || 'N/A'}</span>
                                <span><strong>Duration:</strong> ${formatDuration(duplicateData.duplicate_video.duration)}</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="merge-actions">
                <button onclick="performVideoMerge('${duplicateData.current_video.id}', '${duplicateData.duplicate_video.id}')" class="btn btn-primary" id="performVideoMergeBtn">Merge Videos</button>
                <button onclick="hideDuplicateVideoModal()" class="btn btn-secondary">Skip Merge</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    modal.style.display = 'block';
}

function hideDuplicateVideoModal() {
    const modal = document.getElementById('duplicateVideoModal');
    if (modal) {
        modal.remove();
    }
}

function performVideoMerge(currentVideoId, duplicateVideoId) {
    const primaryVideoId = document.querySelector('input[name="primaryVideo"]:checked').value;
    const duplicateIds = primaryVideoId === currentVideoId ? [duplicateVideoId] : [currentVideoId];
    
    const mergeBtn = document.getElementById('performVideoMergeBtn');
    const originalText = mergeBtn.textContent;
    mergeBtn.textContent = 'Merging...';
    mergeBtn.disabled = true;
    
    fetch('/api/videos/duplicates/merge', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            primary_id: primaryVideoId,
            duplicate_ids: duplicateIds,
            merge_strategy: 'merge_data'
        })
    })
    .then(response => response.json())
    .then(result => {
        if (result.error) {
            showError('Error: ' + result.error);
            mergeBtn.textContent = originalText;
            mergeBtn.disabled = false;
        } else {
            showSuccess(`Successfully merged duplicate videos!`);
            hideDuplicateVideoModal();
            // Refresh the page to show updated data
            loadVideos();
        }
    })
    .catch(error => {
        console.error('Error merging videos:', error);
        showError('Error merging videos');
        mergeBtn.textContent = originalText;
        mergeBtn.disabled = false;
    });
}
</script>

<!-- Add to Playlist Modal -->
<div id="addToPlaylistModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3><iconify-icon icon="tabler:playlist-add"></iconify-icon> Add Videos to Playlist</h3>
            <span class="modal-close" onclick="closeAddToPlaylistModal()">&times;</span>
        </div>
        <div class="modal-body">
            <div class="playlist-selection-container">
                <div class="selected-videos-summary">
                    <p>Adding <span id="selectedVideosCount">0</span> video(s) to playlist:</p>
                    <div id="selectedVideosList" class="selected-videos-preview"></div>
                </div>
                
                <div class="playlist-options">
                    <div class="form-group">
                        <label for="playlistSelect">Select Playlist:</label>
                        <select id="playlistSelect" class="form-control" required>
                            <option value="">Loading playlists...</option>
                        </select>
                    </div>
                    
                    <div class="form-group" id="createPlaylistGroup" style="display: none;">
                        <button onclick="showCreatePlaylistFromModal()" class="btn btn-secondary btn-sm" style="width: 100%;">
                            <iconify-icon icon="tabler:plus"></iconify-icon>
                            Create New Playlist
                        </button>
                        <div class="form-help">Create a new playlist if none exist or you need a new one</div>
                    </div>
                    
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button onclick="addVideosToPlaylist()" class="btn btn-primary" id="addToPlaylistConfirmBtn">
                <iconify-icon icon="tabler:check"></iconify-icon>
                Add to Playlist
            </button>
            <button onclick="closeAddToPlaylistModal()" class="btn btn-secondary">Cancel</button>
        </div>
    </div>
</div>

<!-- Bulk Video Merge Modal -->
<div id="bulkVideoMergeModal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
        <div class="modal-header">
            <h3>üîÄ Bulk Video Merge</h3>
            <span class="modal-close" onclick="closeBulkVideoMergeModal()">&times;</span>
        </div>
        <div class="modal-body">
            <div class="merge-intro">
                <p><strong>Video Merge Operations</strong></p>
                <p>This tool helps you merge duplicate videos by selecting which one to keep as the primary video and which ones to remove. All playlists and metadata from merged videos will be transferred to the primary video.</p>
            </div>
            
            <div class="merge-mode-selection">
                <label>
                    <input type="radio" name="mergeMode" value="auto" checked onchange="updateMergeMode()">
                    <strong>Auto-detect duplicates</strong> - Automatically find and merge videos with matching titles and artists
                </label>
                <label>
                    <input type="radio" name="mergeMode" value="manual" onchange="updateMergeMode()">
                    <strong>Manual selection</strong> - Merge the specific videos you've selected
                </label>
            </div>
            
            <div id="autoMergeOptions" class="merge-options">
                <h4>Auto-Detection Settings</h4>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="matchTitle" checked>
                        Match by title similarity
                    </label>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="matchArtist" checked>
                        Match by same artist
                    </label>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="matchDuration" checked>
                        Match by similar duration (¬±30 seconds)
                    </label>
                </div>
                <div class="form-group">
                    <label for="similarityThreshold">Title similarity threshold:</label>
                    <input type="range" id="similarityThreshold" min="60" max="100" value="80" oninput="updateSimilarityDisplay()">
                    <span id="similarityDisplay">80%</span>
                </div>
            </div>
            
            <div id="manualMergeOptions" class="merge-options" style="display: none;">
                <h4>Selected Videos for Merge</h4>
                <div id="selectedVideosForMerge" class="selected-videos-preview">
                    <p class="text-muted">No videos selected. Please select at least 2 videos to merge.</p>
                </div>
                <div class="merge-strategy">
                    <label for="primaryVideoStrategy">Choose primary video:</label>
                    <select id="primaryVideoStrategy">
                        <option value="highest_quality">Highest quality</option>
                        <option value="longest_duration">Longest duration</option>
                        <option value="newest">Most recently added</option>
                        <option value="manual">Let me choose manually</option>
                    </select>
                </div>
            </div>
            
            <div class="merge-preview" id="mergePreview" style="display: none;">
                <h4>Merge Preview</h4>
                <div class="merge-groups" id="mergeGroupsContainer">
                    <!-- Merge groups will be populated here -->
                </div>
            </div>
            
            <div class="merge-warnings">
                <div class="warning-box">
                    <iconify-icon icon="tabler:alert-triangle"></iconify-icon>
                    <strong>Warning:</strong> This operation cannot be undone. Merged videos will be permanently removed from the database, but their playlists and metadata will be transferred to the primary video.
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button onclick="performBulkVideoMerge()" class="btn btn-warning" id="performMergeBtn" disabled>
                <iconify-icon icon="tabler:git-merge"></iconify-icon>
                Perform Merge
            </button>
            <button onclick="previewMerge()" class="btn btn-info" id="previewMergeBtn">
                <iconify-icon icon="tabler:eye"></iconify-icon>
                Preview Merge
            </button>
            <button onclick="closeBulkVideoMergeModal()" class="btn btn-secondary">Cancel</button>
        </div>
    </div>
</div>

<!-- Delete Video Confirmation Modal -->
<div id="deleteVideoModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
        <div class="modal-header">
            <h3>üóëÔ∏è Delete Video</h3>
            <span class="modal-close" onclick="closeDeleteVideoModal()">&times;</span>
        </div>
        <div class="modal-body">
            <div class="delete-video-info">
                <p><strong>Are you sure you want to delete this video?</strong></p>
                <div class="video-details-preview">
                    <div class="detail-row">
                        <strong>Title:</strong> <span id="deleteVideoTitle"></span>
                    </div>
                    <div class="detail-row">
                        <strong>Artist:</strong> <span id="deleteVideoArtist"></span>
                    </div>
                    <div class="detail-row">
                        <strong>URL:</strong> <span id="deleteVideoUrl" class="url-preview"></span>
                    </div>
                </div>
            </div>
            
            <div id="deleteBlacklistGroup" class="blacklist-option-group">
                <div class="checkbox-container">
                    <label class="checkbox-label">
                        <input type="checkbox" id="deleteAddToBlacklist">
                        <span class="checkmark"></span>
                        <div class="checkbox-text">
                            <strong>Add to blacklist</strong>
                            <small>Prevent this YouTube URL from being downloaded again in the future</small>
                        </div>
                    </label>
                </div>
            </div>
            
            <div class="warning-section">
                <div class="warning-box">
                    <iconify-icon icon="tabler:alert-triangle"></iconify-icon>
                    <div>
                        <strong>Warning:</strong> This action cannot be undone. The video will be permanently removed from the database and all playlists.
                    </div>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button onclick="confirmDeleteVideo()" class="btn btn-danger" id="confirmDeleteBtn">
                <iconify-icon icon="tabler:trash"></iconify-icon>
                Delete Video
            </button>
            <button onclick="closeDeleteVideoModal()" class="btn btn-secondary">Cancel</button>
        </div>
    </div>
</div>

<style>
/* Artist link styles */
.artist-link {
    color: var(--primary-color, #4a9eff);
    text-decoration: none;
    font-weight: 500;
    transition: color 0.2s ease;
}

.artist-link:hover {
    color: var(--primary-color-hover, #6bb6ff);
    text-decoration: underline;
}

/* Video metadata styles */
.video-metadata {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
    padding: 0.25rem 0;
}

.metadata-item {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.85rem;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    background: var(--bg-accent-subtle, rgba(102, 126, 234, 0.1));
    color: var(--text-secondary, #666);
    border: 1px solid var(--border-secondary, rgba(102, 126, 234, 0.2));
}

.metadata-item.quality {
    background: var(--success-bg, rgba(34, 197, 94, 0.1));
    color: var(--success-text, #16a34a);
    border-color: var(--success-border, rgba(34, 197, 94, 0.2));
}

.metadata-item.duration {
    background: var(--info-bg, rgba(59, 130, 246, 0.1));
    color: var(--info-text, #2563eb);
    border-color: var(--info-border, rgba(59, 130, 246, 0.2));
}

/* Enhanced video card layout for metadata */
.video-card .video-info {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.video-card .video-info h3 {
    margin-bottom: 0.25rem;
}

.video-card .video-info p {
    margin-bottom: 0.25rem;
}

/* Responsive adjustments for metadata */
@media (max-width: 768px) {
    .video-metadata {
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .metadata-item {
        font-size: 0.8rem;
        padding: 0.2rem 0.4rem;
    }
}

/* Duplicate Video Dialog Styles - Compact Version */
.duplicate-modal-content {
    max-width: 800px;
    width: 85vw;
    max-height: 80vh;
    overflow-y: auto;
}

.duplicate-video-comparison-compact {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 1.5rem;
    margin: 1.5rem 0;
    align-items: center;
}

.video-option-compact {
    border: 2px solid var(--border-color, #e0e0e0);
    border-radius: 8px;
    padding: 1rem;
    background: var(--card-bg, #fff);
    transition: all 0.3s ease;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}

.video-option-compact:has(input:checked) {
    border-color: var(--primary-color, #007bff);
    background: var(--selected-bg, rgba(0,123,255,0.05));
    box-shadow: 0 3px 10px rgba(0,123,255,0.2);
}

.video-selection {
    margin-bottom: 0.75rem;
    text-align: center;
}

.video-selection input[type="radio"] {
    margin-right: 0.5rem;
    transform: scale(1.1);
}

.selection-label {
    font-weight: 600;
    color: var(--primary-color, #007bff);
    cursor: pointer;
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    background: var(--label-bg, rgba(0,123,255,0.1));
    display: inline-block;
    transition: all 0.2s ease;
    font-size: 0.9rem;
}

.selection-label:hover {
    background: var(--label-hover-bg, rgba(0,123,255,0.2));
}

.video-content {
    display: flex;
    gap: 0.75rem;
    align-items: flex-start;
}

.video-thumbnail-small {
    width: 80px;
    height: 60px;
    flex-shrink: 0;
    overflow: hidden;
    border-radius: 4px;
    background: var(--thumbnail-bg, #f8f9fa);
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid var(--border-color, #e0e0e0);
}

.video-thumbnail-small img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 4px;
}

.video-info {
    flex: 1;
    min-width: 0;
}

.video-info h4 {
    margin: 0 0 0.5rem 0;
    color: var(--heading-color, #333);
    font-size: 1rem;
    font-weight: 600;
}

.info-grid {
    display: grid;
    gap: 0.25rem;
    font-size: 0.85rem;
}

.info-grid span {
    color: var(--text-color, #555);
    word-break: break-word;
}

.info-grid strong {
    color: var(--label-color, #333);
    font-weight: 600;
}

.vs-divider-compact {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--divider-color, #999);
    background: var(--divider-bg, linear-gradient(45deg, #f0f0f0, #e0e0e0));
    border-radius: 50%;
    width: 40px;
    height: 40px;
    margin: auto;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}

.merge-actions {
    text-align: center;
    margin-top: 1.5rem;
    padding-top: 1.5rem;
    border-top: 1px solid var(--border-color, #e0e0e0);
}

.merge-actions .btn {
    margin: 0 0.5rem;
    padding: 0.6rem 1.5rem;
    font-size: 0.95rem;
    font-weight: 600;
}

/* Responsive Design */
@media (max-width: 768px) {
    .duplicate-modal-content {
        width: 95vw;
        padding: 1rem;
        max-height: 85vh;
    }
    
    .duplicate-video-comparison-compact {
        grid-template-columns: 1fr;
        gap: 1rem;
    }
    
    .vs-divider-compact {
        display: none;
    }
    
    .video-content {
        flex-direction: column;
        align-items: center;
        text-align: center;
    }
    
    .video-thumbnail-small {
        width: 100px;
        height: 75px;
    }
    
    .info-grid {
        text-align: left;
    }
}

/* Bulk Video Merge Modal Styles */
.merge-mode-selection {
    margin: 20px 0;
}

.merge-mode-selection label {
    display: block;
    margin: 10px 0;
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    background: var(--card-bg);
}

.merge-mode-selection input[type="radio"] {
    margin-right: 10px;
}

.merge-options {
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    margin: 15px 0;
}

.merge-options h4 {
    margin-top: 0;
    color: var(--text-primary);
}

.merge-options .form-group {
    margin: 15px 0;
}

.merge-options label {
    display: flex;
    align-items: center;
    margin: 8px 0;
}

.merge-options input[type="checkbox"] {
    margin-right: 8px;
}

.merge-options input[type="range"] {
    width: 200px;
    margin: 0 10px;
}

.video-merge-item {
    background: var(--input-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 10px;
    margin: 8px 0;
}

.video-merge-item.primary {
    background: var(--success-bg, #e8f5e8);
    border-color: var(--success-color, #28a745);
}

.video-merge-item.duplicate {
    background: var(--warning-bg, #fff3cd);
    border-color: var(--warning-color, #ffc107);
}

.merge-group {
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 15px;
    margin: 15px 0;
    background: var(--card-bg);
}

.merge-group h5 {
    margin-top: 0;
    color: var(--text-primary);
}

.merge-videos {
    display: grid;
    gap: 15px;
    margin: 15px 0;
}

.primary-video, .merge-videos-list {
    margin: 10px 0;
}

.merge-summary {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid var(--border-color);
}

.warning-box {
    background: var(--warning-bg, #fff3cd);
    border: 1px solid var(--warning-color, #ffc107);
    border-radius: 6px;
    padding: 15px;
    margin: 15px 0;
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

.warning-box iconify-icon {
    color: var(--warning-color, #ffc107);
    font-size: 1.2em;
    margin-top: 2px;
}

.merge-strategy {
    margin: 15px 0;
}

.merge-strategy select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background: var(--input-bg);
    color: var(--text-primary);
}

.video-info-compact {
    font-size: 14px;
}

.video-info-compact strong {
    color: var(--text-primary);
}

.selected-videos-preview {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 10px;
    background: var(--input-bg);
}

.error-message {
    color: var(--error-color, #dc3545);
    background: var(--error-bg, #f8d7da);
    border: 1px solid var(--error-color, #dc3545);
    border-radius: 6px;
    padding: 10px;
    margin: 10px 0;
}

/* Delete Video Modal Styles */
.delete-video-info {
    margin-bottom: 20px;
}

.video-details-preview {
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 15px;
    margin: 15px 0;
}

.detail-row {
    margin: 8px 0;
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

.detail-row strong {
    min-width: 50px;
    color: var(--text-primary);
}

.url-preview {
    word-break: break-all;
    color: var(--text-muted);
    font-family: monospace;
    font-size: 0.9em;
}

.blacklist-option-group {
    background: var(--info-bg, #e3f2fd);
    border: 1px solid var(--info-color, #2196f3);
    border-radius: 8px;
    padding: 15px;
    margin: 15px 0;
}

.checkbox-container {
    display: flex;
    align-items: flex-start;
}

.checkbox-label {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    cursor: pointer;
    margin: 0;
}

.checkbox-label input[type="checkbox"] {
    margin: 0;
    margin-top: 2px;
}

.checkbox-text {
    flex: 1;
}

.checkbox-text strong {
    display: block;
    color: var(--text-primary);
    margin-bottom: 3px;
}

.checkbox-text small {
    color: var(--text-muted);
    font-size: 0.85em;
    line-height: 1.3;
}

.warning-section {
    margin: 15px 0;
}

.warning-section .warning-box {
    background: var(--warning-bg, #fff3cd);
    border: 1px solid var(--warning-color, #ffc107);
    border-radius: 6px;
    padding: 12px;
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

.warning-section .warning-box iconify-icon {
    color: var(--warning-color, #ffc107);
    font-size: 1.1em;
    margin-top: 2px;
    flex-shrink: 0;
}

.warning-section .warning-box div {
    flex: 1;
    font-size: 0.9em;
    line-height: 1.4;
}

/* Bulk Progress Styles */
.bulk-progress {
    margin: 15px 0;
    padding: 10px;
    background: var(--surface-light);
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.progress-bar {
    width: 100%;
    height: 8px;
    background: var(--surface-dark);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 8px;
}

.progress-fill {
    height: 100%;
    background: var(--primary-color);
    border-radius: 4px;
    transition: width 0.3s ease;
    width: 0%;
}

.progress-text {
    font-size: 0.9em;
    color: var(--text-secondary);
    text-align: center;
}

.progress-main {
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.progress-details {
    font-size: 0.8em;
    color: var(--text-secondary);
    opacity: 0.8;
}
</style>

{% endblock %}