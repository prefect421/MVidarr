{% extends "base.html" %}

{% block title %}Videos - MVidarr{% endblock %}

{% block content %}
<style>
.videos-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

.videos-container h1 {
    color: #00d4ff;
    margin-bottom: 10px;
    font-size: 2.5rem;
    text-align: center;
}

.page-description {
    text-align: center;
    color: #ccc;
    margin-bottom: 30px;
    font-size: 1.1rem;
}

.videos-actions {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    border: 1px solid #444;
    border-radius: 12px;
    padding: 25px;
    margin-bottom: 20px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
}

.videos-actions:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 212, 255, 0.15);
}

.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 8px;
}

.btn-primary {
    background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
    color: #fff;
}

.btn-primary:hover {
    background: linear-gradient(135deg, #0099cc 0%, #007799 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
}

.btn-success {
    background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
    color: #fff;
}

.btn-success:hover {
    background: linear-gradient(135deg, #1e7e34 0%, #155724 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
}

.btn-info {
    background: linear-gradient(135deg, #17a2b8 0%, #117a8b 100%);
    color: #fff;
}

.btn-info:hover {
    background: linear-gradient(135deg, #117a8b 0%, #0c5460 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(23, 162, 184, 0.3);
}

.btn-warning {
    background: linear-gradient(135deg, #ffc107 0%, #d39e00 100%);
    color: #000;
}

.btn-warning:hover {
    background: linear-gradient(135deg, #d39e00 0%, #b08800 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
}

.btn-secondary {
    background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
    color: #fff;
}

.btn-secondary:hover {
    background: linear-gradient(135deg, #5a6268 0%, #484e53 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
}

.btn-danger {
    background: linear-gradient(135deg, #dc3545 0%, #bd2130 100%);
    color: #fff;
}

.btn-danger:hover {
    background: linear-gradient(135deg, #bd2130 0%, #a01e2a 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none !important;
    box-shadow: none !important;
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    color: #00d4ff;
    margin-bottom: 8px;
    font-weight: 500;
}

.form-control {
    width: 100%;
    padding: 12px;
    background: #333;
    border: 2px solid #444;
    border-radius: 8px;
    color: #fff;
    font-size: 14px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.form-control:focus {
    outline: none;
    border-color: #00d4ff;
    box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
}

.form-control option {
    background: #333;
    color: #fff;
}

.search-panel {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    border: 1px solid #444;
    border-radius: 12px;
    padding: 25px;
    margin-bottom: 20px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.search-panel:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 212, 255, 0.15);
}

.search-form {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.search-row {
    display: grid;
    grid-template-columns: 1fr 1fr 150px 120px;
    gap: 15px;
    align-items: end;
}

.search-field {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.search-field label {
    color: #00d4ff;
    font-weight: 500;
    font-size: 0.9rem;
}

.search-field input,
.search-field select {
    padding: 10px 12px;
    background: #333;
    border: 2px solid #444;
    border-radius: 8px;
    color: #fff;
    font-size: 14px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.search-field input:focus,
.search-field select:focus {
    outline: none;
    border-color: #00d4ff;
    box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
}

.modal-content {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    margin: 5% auto;
    padding: 0;
    border: 1px solid #444;
    border-radius: 12px;
    width: 90%;
    max-width: 600px;
    color: #fff;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid #444;
}

.modal-header h3 {
    margin: 0;
    color: #00d4ff;
}

.modal-close {
    font-size: 24px;
    cursor: pointer;
    color: #aaa;
    transition: color 0.3s ease;
}

.modal-close:hover {
    color: #00d4ff;
}

.modal-body {
    padding: 20px;
}

.form-actions {
    margin-top: 20px;
    text-align: right;
}

.form-actions button {
    margin-left: 10px;
}

.loading-spinner {
    border: 3px solid #555;
    border-top: 3px solid #00d4ff;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin: 0 auto 10px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Pagination Styles */
.pagination-container {
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 15px 20px;
    margin: 20px 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 15px;
}

.pagination-info {
    color: #ccc;
    font-size: 0.9rem;
}

.pagination-controls {
    display: flex;
    align-items: center;
    gap: 15px;
}

.pagination-btn {
    padding: 8px 16px;
    font-size: 0.9rem;
    min-width: auto;
    transition: all 0.2s ease;
}

.pagination-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background: #333 !important;
    color: #666 !important;
}

.page-selector {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #ccc;
    font-size: 0.9rem;
}

.page-input {
    width: 60px;
    padding: 4px 8px;
    background: #2a2a2a;
    border: 1px solid #444;
    border-radius: 4px;
    color: #f0f0f0;
    text-align: center;
    font-size: 0.9rem;
}

.page-input:focus {
    border-color: #00d4ff;
    outline: none;
}

.page-size-selector {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #ccc;
    font-size: 0.9rem;
}

.page-size-selector select {
    background: #2a2a2a;
    border: 1px solid #444;
    border-radius: 4px;
    color: #f0f0f0;
    padding: 4px 8px;
    font-size: 0.9rem;
}

.page-size-selector select:focus {
    border-color: #00d4ff;
    outline: none;
}

.bottom-pagination .page-size-selector {
    display: none;
}

/* Responsive pagination */
@media (max-width: 768px) {
    .pagination-container {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
    }
    
    .pagination-controls {
        justify-content: center;
    }
    
    .pagination-info {
        text-align: center;
    }
    
    .page-size-selector {
        justify-content: center;
    }
}

.advanced-search-panel {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    border: 1px solid #444;
    border-radius: 12px;
    padding: 25px;
    margin-bottom: 20px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.advanced-search-panel:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 212, 255, 0.15);
}

.search-header {
    display: flex;
    gap: 15px;
    align-items: center;
    margin-bottom: 20px;
}

.search-input-container {
    flex: 1;
    position: relative;
}

.search-input-container input {
    width: 100%;
    padding: 12px 16px;
    background: #333;
    border: 2px solid #444;
    border-radius: 8px;
    color: #fff;
    font-size: 14px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.search-input-container input:focus {
    outline: none;
    border-color: #00d4ff;
    box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
}

.search-suggestions {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: #2d2d2d;
    border: 1px solid #444;
    border-radius: 0 0 8px 8px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
}

.search-suggestion-item {
    padding: 10px 16px;
    color: #ccc;
    cursor: pointer;
    border-bottom: 1px solid #444;
    transition: background-color 0.2s ease;
}

.search-suggestion-item:hover {
    background: #00d4ff;
    color: #000;
}

.search-suggestion-item:last-child {
    border-bottom: none;
}

.filter-count {
    background: #00d4ff;
    color: #000;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 12px;
    font-weight: bold;
    margin-left: 5px;
    display: none;
}

.filter-count.active {
    display: inline;
}

.advanced-filters {
    border-top: 1px solid #444;
    padding-top: 20px;
}

.filter-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.filter-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.filter-group.full-width {
    grid-column: 1 / -1;
}

.filter-group label {
    color: #00d4ff;
    font-weight: 500;
    font-size: 0.9rem;
}

.filter-group input,
.filter-group select {
    padding: 10px 12px;
    background: #333;
    border: 2px solid #444;
    border-radius: 8px;
    color: #fff;
    font-size: 14px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.filter-group input:focus,
.filter-group select:focus {
    outline: none;
    border-color: #00d4ff;
    box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
}

.filter-group select option {
    background: #333;
    color: #fff;
}

.filter-actions {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    justify-content: flex-end;
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid #444;
}

.search-results-info {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid #444;
    color: #ccc;
    font-size: 0.9rem;
    text-align: center;
}

@media (max-width: 768px) {
    .videos-container {
        padding: 15px;
    }
    
    .videos-container h1 {
        font-size: 2rem;
    }
    
    .videos-actions {
        flex-direction: column;
        align-items: stretch;
    }
    
    .btn {
        justify-content: center;
        margin-bottom: 10px;
    }
    
    .search-row {
        grid-template-columns: 1fr;
        gap: 10px;
    }
    
    .search-panel {
        padding: 20px;
    }
    
    .modal-content {
        width: 95%;
        margin: 10% auto;
    }
    
    .search-header {
        flex-direction: column;
        gap: 10px;
    }
    
    .filter-row {
        grid-template-columns: 1fr;
        gap: 10px;
    }
    
    .filter-actions {
        flex-direction: column;
    }
    
    .advanced-search-panel {
        padding: 20px;
    }
}

/* Light Theme Overrides for Videos Page */
body.light-theme .search-panel {
    background: white;
    border: 1px solid #e1e5e9;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

body.light-theme .search-panel:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
}

body.light-theme .search-field label {
    color: #333;
}

body.light-theme .search-field input,
body.light-theme .search-field select {
    background: white;
    border: 2px solid #e1e5e9;
    color: #333;
    border-radius: 8px;
}

body.light-theme .search-field input:focus,
body.light-theme .search-field select:focus {
    border-color: #667eea;
    box-shadow: none;
    outline: none;
}
</style>
<div class="videos-container">
    
    <div class="videos-actions">
        <button onclick="refreshVideos()" class="btn btn-primary">Refresh</button>
        <button onclick="toggleSearchPanel()" class="btn btn-secondary">Search</button>
        <button onclick="refreshThumbnails()" class="btn btn-secondary">Refresh Thumbnails</button>
        <button onclick="refreshAllMetadata()" class="btn btn-secondary">Refresh All Metadata</button>
        <button onclick="refreshAllMetadataForce()" class="btn btn-warning">Force Refresh All Metadata</button>
        
        <div class="bulk-actions" style="margin-left: 20px; display: inline-block;">
            <label>
                <input type="checkbox" id="selectAllVideos" onchange="toggleSelectAll()"> Select All (<span id="selectedCount">0</span>)
            </label>
            <button onclick="toggleBulkActionsPanel()" class="btn btn-secondary" id="bulkActionsToggle">
                üîß Bulk Actions
            </button>
        </div>
    </div>
    
    <!-- Advanced Search Panel -->
    <div class="advanced-search-panel" id="videoSearchPanel" style="display: none;">
        <div class="search-header">
            <div class="search-input-container">
                <input type="text" id="videoSearchInput" placeholder="Search videos, titles, artists, or descriptions..." onkeyup="handleVideoSearchInput(event)">
                <div class="search-suggestions" id="videoSearchSuggestions"></div>
            </div>
            <button onclick="toggleVideoAdvancedFilters()" class="btn btn-secondary" id="videoFiltersToggle">
                <span>Filters</span> <span id="videoFilterCount" class="filter-count"></span>
            </button>
        </div>
        
        <div class="advanced-filters" id="videoAdvancedFilters" style="display: none;">
            <div class="filter-row">
                <div class="filter-group">
                    <label for="videoStatusFilter">Status:</label>
                    <select id="videoStatusFilter" onchange="applyVideoFilters()">
                        <option value="">All Videos</option>
                        <option value="WANTED">Wanted</option>
                        <option value="DOWNLOADED">Downloaded</option>
                        <option value="FAILED">Failed</option>
                        <option value="IGNORED">Ignored</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="videoQualityFilter">Quality:</label>
                    <select id="videoQualityFilter" onchange="applyVideoFilters()">
                        <option value="">Any Quality</option>
                        <option value="360p">360p</option>
                        <option value="480p">480p</option>
                        <option value="720p">720p (HD)</option>
                        <option value="1080p">1080p (Full HD)</option>
                        <option value="1440p">1440p (2K)</option>
                        <option value="2160p">2160p (4K)</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="videoThumbnailFilter">Thumbnails:</label>
                    <select id="videoThumbnailFilter" onchange="applyVideoFilters()">
                        <option value="">Any</option>
                        <option value="true">Has Thumbnail</option>
                        <option value="false">No Thumbnail</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="videoSourceFilter">Source:</label>
                    <select id="videoSourceFilter" onchange="applyVideoFilters()">
                        <option value="">Any Source</option>
                        <option value="youtube">YouTube</option>
                        <option value="imvdb">IMVDb</option>
                        <option value="manual">Manual</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="videoGenreFilter">Genre:</label>
                    <select id="videoGenreFilter" onchange="applyVideoFilters()">
                        <option value="">All Genres</option>
                        <!-- Genre options will be populated by JavaScript -->
                    </select>
                </div>
            </div>
            
            <div class="filter-row">
                <div class="filter-group">
                    <label for="videoDurationMin">Min Duration (seconds):</label>
                    <input type="number" id="videoDurationMin" min="0" placeholder="0" onchange="applyVideoFilters()">
                </div>
                
                <div class="filter-group">
                    <label for="videoDurationMax">Max Duration (seconds):</label>
                    <input type="number" id="videoDurationMax" min="0" placeholder="‚àû" onchange="applyVideoFilters()">
                </div>
                
                <div class="filter-group">
                    <label for="videoDateFrom">Added After:</label>
                    <input type="date" id="videoDateFrom" onchange="applyVideoFilters()">
                </div>
                
                <div class="filter-group">
                    <label for="videoDateTo">Added Before:</label>
                    <input type="date" id="videoDateTo" onchange="applyVideoFilters()">
                </div>
            </div>
            
            <div class="filter-row">
                <div class="filter-group">
                    <label for="videoArtistFilter">Artist:</label>
                    <input type="text" id="videoArtistFilter" placeholder="Filter by artist name..." onchange="applyVideoFilters()">
                </div>
                
                <div class="filter-group">
                    <label for="videoKeywordsFilter">Keywords (comma-separated):</label>
                    <input type="text" id="videoKeywordsFilter" placeholder="Enter keywords..." onchange="applyVideoFilters()">
                </div>
                
                <div class="filter-group">
                    <label for="videoSortBy">Sort By:</label>
                    <select id="videoSortBy" onchange="applyVideoFilters()">
                        <option value="title">Title</option>
                        <option value="artist">Artist</option>
                        <option value="date_added">Date Added</option>
                        <option value="status">Status</option>
                        <option value="quality">Quality</option>
                        <option value="duration">Duration</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="videoSortOrder">Sort Order:</label>
                    <select id="videoSortOrder" onchange="applyVideoFilters()">
                        <option value="asc">Ascending</option>
                        <option value="desc">Descending</option>
                    </select>
                </div>
            </div>
            
            <div class="filter-actions">
                <button onclick="clearAllVideoFilters()" class="btn btn-secondary">Clear All</button>
                <button onclick="saveVideoSearchPreset()" class="btn btn-secondary">Save Preset</button>
                <button onclick="exportVideoSearchResults()" class="btn btn-info">Export Results</button>
            </div>
        </div>
        
        <div class="search-results-info" id="videoSearchResults">
            <span id="videoResultsCount">Loading videos...</span>
        </div>
    </div>
    
    <!-- Enhanced Bulk Actions Panel -->
    <div id="bulkActionsPanel" class="bulk-actions-panel" style="display: none;">
        <div class="bulk-actions-header">
            <h3>üîß Bulk Operations</h3>
            <span class="bulk-actions-close" onclick="closeBulkActionsPanel()">&times;</span>
        </div>
        <div class="bulk-actions-content">
            <div class="bulk-actions-tabs">
                <button class="tab-button active" onclick="switchBulkTab('actions')">Actions</button>
                <button class="tab-button" onclick="switchBulkTab('edit')">Edit</button>
                <button class="tab-button" onclick="switchBulkTab('organize')">Organize</button>
                <button class="tab-button" onclick="switchBulkTab('quality')">Quality</button>
            </div>
            
            <div class="bulk-actions-tab-content">
                <!-- Actions Tab -->
                <div id="bulkActionsTab" class="tab-content active">
                    <div class="bulk-action-group">
                        <h4>Download Actions</h4>
                        <button onclick="bulkDownloadSelected()" class="btn btn-primary bulk-btn" id="bulkDownloadBtn" disabled>
                            üì• Download Selected
                        </button>
                        <button onclick="bulkRetryFailed()" class="btn btn-warning bulk-btn" id="bulkRetryBtn" disabled>
                            üîÑ Retry Failed Downloads
                        </button>
                        <button onclick="bulkPauseDownloads()" class="btn btn-secondary bulk-btn" id="bulkPauseBtn" disabled>
                            ‚è∏Ô∏è Pause Downloads
                        </button>
                    </div>
                    
                    <div class="bulk-action-group">
                        <h4>Status Actions</h4>
                        <button onclick="bulkSetStatus('WANTED')" class="btn btn-info bulk-btn" id="bulkWantedBtn" disabled>
                            ‚≠ê Mark as Wanted
                        </button>
                        <button onclick="bulkSetStatus('IGNORED')" class="btn btn-secondary bulk-btn" id="bulkIgnoreBtn" disabled>
                            üö´ Mark as Ignored
                        </button>
                        <button onclick="bulkSetStatus('FAILED')" class="btn btn-warning bulk-btn" id="bulkFailedBtn" disabled>
                            ‚ùå Mark as Failed
                        </button>
                    </div>
                    
                    <div class="bulk-action-group">
                        <h4>Dangerous Actions</h4>
                        <button onclick="bulkDeleteSelected()" class="btn btn-danger bulk-btn" id="bulkDeleteBtn" disabled>
                            üóëÔ∏è Delete Selected
                        </button>
                        <button onclick="bulkRemoveFiles()" class="btn btn-danger bulk-btn" id="bulkRemoveFilesBtn" disabled>
                            üí• Remove Files Only
                        </button>
                    </div>
                </div>
                
                <!-- Edit Tab -->
                <div id="bulkEditTab" class="tab-content">
                    <div class="bulk-edit-form">
                        <h4>Bulk Edit Properties</h4>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="bulkArtistChange">Change Artist:</label>
                                <input type="text" id="bulkArtistChange" placeholder="New artist name...">
                            </div>
                            <div class="form-group">
                                <label for="bulkYearChange">Change Year:</label>
                                <input type="number" id="bulkYearChange" placeholder="YYYY" min="1900" max="2030">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="bulkStatusChange">Change Status:</label>
                                <select id="bulkStatusChange">
                                    <option value="">Keep Current</option>
                                    <option value="WANTED">Wanted</option>
                                    <option value="DOWNLOADING">Downloading</option>
                                    <option value="DOWNLOADED">Downloaded</option>
                                    <option value="IGNORED">Ignored</option>
                                    <option value="FAILED">Failed</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="bulkPriorityChange">Priority:</label>
                                <select id="bulkPriorityChange">
                                    <option value="">Keep Current</option>
                                    <option value="LOW">Low</option>
                                    <option value="NORMAL">Normal</option>
                                    <option value="HIGH">High</option>
                                    <option value="URGENT">Urgent</option>
                                </select>
                            </div>
                        </div>
                        <button onclick="applyBulkEdit()" class="btn btn-primary bulk-btn" id="bulkEditApplyBtn" disabled>
                            üíæ Apply Changes
                        </button>
                    </div>
                </div>
                
                <!-- Organize Tab -->
                <div id="bulkOrganizeTab" class="tab-content">
                    <div class="bulk-organize-form">
                        <h4>File Organization</h4>
                        <div class="organize-actions">
                            <button onclick="bulkOrganizeFiles()" class="btn btn-primary bulk-btn" id="bulkOrganizeBtn" disabled>
                                üìÅ Organize Files
                            </button>
                            <button onclick="bulkVerifyFiles()" class="btn btn-info bulk-btn" id="bulkVerifyBtn" disabled>
                                üîç Verify File Locations
                            </button>
                            <button onclick="bulkRefreshMetadata()" class="btn btn-secondary bulk-btn" id="bulkRefreshMetadataBtn" disabled>
                                üîÑ Refresh Metadata
                            </button>
                        </div>
                        <div class="organize-options">
                            <label>
                                <input type="checkbox" id="bulkCreateFolders" checked>
                                Create artist folders if missing
                            </label>
                            <label>
                                <input type="checkbox" id="bulkRenameFiles" checked>
                                Rename files to match metadata
                            </label>
                            <label>
                                <input type="checkbox" id="bulkRemoveDuplicates">
                                Remove duplicate files
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Quality Tab -->
                <div id="bulkQualityTab" class="tab-content">
                    <div class="bulk-quality-form">
                        <h4>Quality Control</h4>
                        <div class="quality-actions">
                            <button onclick="bulkCheckQuality()" class="btn btn-info bulk-btn" id="bulkQualityCheckBtn" disabled>
                                üéØ Check Quality
                            </button>
                            <button onclick="bulkUpgradeQuality()" class="btn btn-warning bulk-btn" id="bulkUpgradeBtn" disabled>
                                ‚¨ÜÔ∏è Upgrade Quality
                            </button>
                            <button onclick="bulkTranscode()" class="btn btn-secondary bulk-btn" id="bulkTranscodeBtn" disabled>
                                üîÑ Transcode Selected
                            </button>
                        </div>
                        <div class="quality-options">
                            <div class="form-group">
                                <label for="bulkQualityProfile">Quality Profile:</label>
                                <select id="bulkQualityProfile">
                                    <option value="720p">720p (HD)</option>
                                    <option value="1080p">1080p (Full HD)</option>
                                    <option value="1440p">1440p (2K)</option>
                                    <option value="2160p">2160p (4K)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="bulkFileFormat">File Format:</label>
                                <select id="bulkFileFormat">
                                    <option value="mp4">MP4</option>
                                    <option value="mkv">MKV</option>
                                    <option value="avi">AVI</option>
                                    <option value="webm">WebM</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="bulk-actions-footer">
                <div class="bulk-progress" id="bulkProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="bulkProgressFill"></div>
                    </div>
                    <div class="progress-text" id="bulkProgressText">Processing...</div>
                </div>
                <div class="bulk-actions-buttons">
                    <button onclick="selectByStatus()" class="btn btn-info">Select by Status</button>
                    <button onclick="selectByArtist()" class="btn btn-info">Select by Artist</button>
                    <button onclick="selectByYear()" class="btn btn-info">Select by Year</button>
                    <button onclick="deselectAll()" class="btn btn-secondary">Deselect All</button>
                    <button onclick="closeBulkActionsPanel()" class="btn btn-secondary">Close</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Search Panel -->
    <div id="searchPanel" class="search-panel" style="display: none;">
        <div class="search-form">
            <div class="search-row">
                <div class="search-field">
                    <label for="searchQuery">Search:</label>
                    <input type="text" id="searchQuery" placeholder="Search videos and artists..." onkeyup="handleSearchKeyup(event)">
                </div>
                <div class="search-field">
                    <label for="searchArtist">Artist:</label>
                    <input type="text" id="searchArtist" placeholder="Filter by artist..." onkeyup="handleSearchKeyup(event)">
                </div>
                <div class="search-field">
                    <label for="searchStatus">Status:</label>
                    <select id="searchStatus" onchange="performSearch()">
                        <option value="">All Statuses</option>
                        <option value="WANTED">Wanted</option>
                        <option value="DOWNLOADING">Downloading</option>
                        <option value="DOWNLOADED">Downloaded</option>
                        <option value="IGNORED">Ignored</option>
                        <option value="FAILED">Failed</option>
                    </select>
                </div>
                <div class="search-field">
                    <label for="searchYear">Year:</label>
                    <input type="number" id="searchYear" placeholder="e.g. 2023" min="1900" max="2030" onchange="performSearch()">
                </div>
                <div class="search-field">
                    <label for="sortBy">Sort by:</label>
                    <select id="sortBy" onchange="performSearch()">
                        <option value="title">Title (A-Z)</option>
                        <option value="artist_name">Artist Name</option>
                        <option value="year">Year</option>
                        <option value="created_at">Date Added</option>
                        <option value="status">Status</option>
                    </select>
                </div>
                <div class="search-field">
                    <label for="sortOrder">Order:</label>
                    <select id="sortOrder" onchange="performSearch()">
                        <option value="asc">Ascending</option>
                        <option value="desc">Descending</option>
                    </select>
                </div>
            </div>
            <div class="search-actions">
                <button onclick="performSearch()" class="btn btn-primary">Search</button>
                <button onclick="clearSearch()" class="btn btn-secondary">Clear</button>
                <span id="searchResults" class="search-results-info"></span>
            </div>
        </div>
    </div>

    <!-- Pagination Controls Top -->
    <div class="pagination-container top-pagination" id="topPagination" style="display: none;">
        <div class="pagination-info">
            <span id="videoCountInfo">Loading...</span>
        </div>
        <div class="pagination-controls">
            <button class="btn btn-secondary pagination-btn" id="prevPageTop" onclick="previousPage()" disabled>
                ‚Üê Previous
            </button>
            <div class="page-selector">
                <span>Page </span>
                <input type="number" id="pageInputTop" class="page-input" min="1" value="1" onchange="goToPage(this.value)">
                <span> of <span id="totalPagesTop">1</span></span>
            </div>
            <button class="btn btn-secondary pagination-btn" id="nextPageTop" onclick="nextPage()" disabled>
                Next ‚Üí
            </button>
        </div>
        <div class="page-size-selector">
            <label for="pageSizeSelect">Videos per page:</label>
            <select id="pageSizeSelect" onchange="changePageSize(this.value)">
                <option value="25">25</option>
                <option value="50" selected>50</option>
                <option value="100">100</option>
                <option value="200">200</option>
            </select>
        </div>
    </div>

    <div class="videos-grid" id="videos-grid">
        <p>Loading videos...</p>
    </div>

    <!-- Pagination Controls Bottom -->
    <div class="pagination-container bottom-pagination" id="bottomPagination" style="display: none;">
        <div class="pagination-info">
            <span id="videoCountInfoBottom">Loading...</span>
        </div>
        <div class="pagination-controls">
            <button class="btn btn-secondary pagination-btn" id="prevPageBottom" onclick="previousPage()" disabled>
                ‚Üê Previous
            </button>
            <div class="page-selector">
                <span>Page </span>
                <input type="number" id="pageInputBottom" class="page-input" min="1" value="1" onchange="goToPage(this.value)">
                <span> of <span id="totalPagesBottom">1</span></span>
            </div>
            <button class="btn btn-secondary pagination-btn" id="nextPageBottom" onclick="nextPage()" disabled>
                Next ‚Üí
            </button>
        </div>
        <div class="page-size-selector">
            <span>Videos per page: <span id="currentPageSize">50</span></span>
        </div>
    </div>
</div>

<!-- Video Player Modal -->
<div id="videoModal" class="video-modal">
    <div class="video-modal-content">
        <div class="video-modal-header">
            <h3 id="videoModalTitle">Playing Video</h3>
            <span class="video-modal-close" onclick="closeVideoModal()">&times;</span>
        </div>
        <div class="video-modal-body">
            <div id="videoPlayer"></div>
        </div>
    </div>
</div>

<!-- Edit Video Modal -->
<div id="editVideoModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Edit Video Metadata</h3>
            <span class="modal-close" onclick="closeEditVideoModal()">&times;</span>
        </div>
        <div class="modal-body">
            <form id="editVideoForm">
                <div class="form-group">
                    <label for="videoTitle">Video Title:</label>
                    <input type="text" id="videoTitle" name="title" required>
                </div>
                
                <div class="form-group">
                    <label for="videoArtist">Artist Name:</label>
                    <div class="artist-input-container">
                        <input type="text" id="videoArtist" name="artist_name" required>
                        <button type="button" id="identifyArtistBtn" class="btn btn-secondary btn-small" onclick="identifyArtist()" style="margin-left: 10px;">
                            üîç Identify Artist
                        </button>
                    </div>
                    <div id="artistSuggestions" class="artist-suggestions" style="display: none;">
                        <!-- Artist suggestions will be populated here -->
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="videoYear">Year:</label>
                    <input type="number" id="videoYear" name="year" min="1900" max="2030">
                </div>
                
                <div class="form-group">
                    <label for="videoGenre">Genre:</label>
                    <input type="text" id="videoGenre" name="genre" placeholder="Rock, Pop, Hip-Hop, etc.">
                </div>
                
                <div class="form-group">
                    <label for="videoStatus">Status:</label>
                    <select id="videoStatus" name="status">
                        <option value="DOWNLOADED">Downloaded</option>
                        <option value="WANTED">Wanted</option>
                        <option value="IGNORED">Ignored</option>
                        <option value="FAILED">Failed</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="videoUrl">Video URL:</label>
                    <input type="url" id="videoUrl" name="video_url" placeholder="https://youtube.com/watch?v=...">
                </div>
                
                <div class="form-group">
                    <label for="videoThumbnailUrl">Thumbnail URL:</label>
                    <input type="url" id="videoThumbnailUrl" name="thumbnail_url">
                    <button type="button" onclick="openVideoThumbnailManager()" class="btn btn-info btn-small" style="margin-top: 5px;">
                        üñºÔ∏è Manage Thumbnail
                    </button>
                </div>
                
                <div class="form-group">
                    <label for="videoDuration">Duration (seconds):</label>
                    <input type="number" id="videoDuration" name="duration" min="0">
                </div>
                
                <div class="form-group">
                    <label for="videoImvdbId">IMVDb ID:</label>
                    <input type="text" id="videoImvdbId" name="imvdb_id">
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="moveFile" name="move_file" checked>
                        Move/rename file if artist or title changes
                    </label>
                </div>
                
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Save Changes</button>
                    <button type="button" class="btn btn-secondary" onclick="closeEditVideoModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    loadVideos();
    loadVideoGenreOptions(); // Load genre filter options
});

// Pagination state
let currentPage = 1;
let pageSize = 50;
let totalVideos = 0;
let totalPages = 1;

function loadVideos(page = 1, size = pageSize, resetPage = false) {
    if (resetPage) {
        currentPage = 1;
        page = 1;
    }
    
    const offset = (page - 1) * size;
    fetch(`/api/videos/?sort=title&order=asc&offset=${offset}&limit=${size}`)
        .then(response => response.json())
        .then(data => {
            const grid = document.getElementById('videos-grid');
            
            // Update pagination state
            currentPage = page;
            pageSize = size;
            totalVideos = data.total || 0;
            totalPages = Math.ceil(totalVideos / pageSize);
            
            if (data.videos && data.videos.length > 0) {
                grid.innerHTML = data.videos.map(video => `
                    <div class="video-card">
                        <div class="video-select">
                            <input type="checkbox" class="video-checkbox" value="${video.id}" onchange="updateSelectedCount()">
                        </div>
                        <div class="video-thumbnail" data-video-id="${video.id}" data-action="play">
                            <img src="/api/videos/${video.id}/thumbnail" 
                                 alt="${video.title}" onerror="this.src='/static/placeholder-video.png'">
                            <div class="play-overlay">
                                <div class="play-button">‚ñ∂</div>
                            </div>
                        </div>
                        <div class="video-info">
                            <h3>${video.title}</h3>
                            <p>Artist: ${video.artist_name || 'Unknown'}</p>
                            <p>Status: ${video.status}</p>
                            ${video.year ? `<p>Year: ${video.year}</p>` : ''}
                        </div>
                        <div class="video-actions">
                            <button data-video-id="${video.id}" data-action="view" class="btn-icon" title="View Details">
                                <i class="icon-eye"></i>
                            </button>
                            <button data-video-id="${video.id}" data-action="edit" class="btn-icon" title="Edit Video">
                                <i class="icon-edit"></i>
                            </button>
                            <button data-video-id="${video.id}" data-action="refresh-metadata" class="btn-icon" title="Refresh Metadata">
                                <i class="icon-refresh"></i>
                            </button>
                            ${video.status === 'WANTED' ? 
                                `<button data-video-id="${video.id}" data-action="download" class="btn-icon" title="Download Video">
                                    <i class="icon-download"></i>
                                </button>` : 
                                ''}
                            <button data-video-id="${video.id}" data-action="delete" class="btn-icon btn-danger" title="Delete Video">
                                <i class="icon-trash"></i>
                            </button>
                        </div>
                    </div>
                `).join('');
            } else {
                grid.innerHTML = '<p>No videos found. Add some artists to discover videos!</p>';
            }
            
            // Update pagination controls
            updatePaginationControls();
        })
        .catch(error => {
            console.error('Error loading videos:', error);
            document.getElementById('videos-grid').innerHTML = '<p>Error loading videos.</p>';
            // Hide pagination on error
            document.getElementById('topPagination').style.display = 'none';
            document.getElementById('bottomPagination').style.display = 'none';
        });
}

// Add event delegation for video actions
document.addEventListener('click', function(e) {
    // Check if the clicked element or any of its parents have the data attributes
    let element = e.target;
    let videoId = null;
    let action = null;
    
    // Walk up the DOM tree to find data attributes
    while (element && element !== document) {
        videoId = element.getAttribute('data-video-id');
        action = element.getAttribute('data-action');
        
        if (videoId && action) break;
        element = element.parentElement;
    }
    
    if (!videoId || !action) return;
    
    console.log(`Video action triggered: ${action} for video ${videoId}`);
    
    // Find the video data from the most recent loadVideos call
    const videoCards = document.querySelectorAll('.video-card');
    let videoData = null;
    
    // Find the video card containing this element
    let videoCard = e.target.closest('.video-card');
    if (videoCard) {
        const titleElement = videoCard.querySelector('h3');
        const title = titleElement ? titleElement.textContent : '';
        
        // For play action, we need to get video data from API
        if (action === 'play') {
            fetch(`/api/videos/${videoId}`)
                .then(response => response.json())
                .then(video => {
                    playVideo(video.id, video.title, video.local_path, video.video_url);
                })
                .catch(error => {
                    console.error('Error getting video data:', error);
                    // Fallback to basic data
                    playVideo(parseInt(videoId), title, null, null);
                });
        } else if (action === 'view') {
            viewVideo(parseInt(videoId));
        } else if (action === 'edit') {
            editVideo(parseInt(videoId));
        } else if (action === 'refresh-metadata') {
            refreshVideoMetadata(parseInt(videoId));
        } else if (action === 'download') {
            downloadVideo(parseInt(videoId));
        } else if (action === 'delete') {
            deleteVideo(parseInt(videoId));
        }
    }
});

function refreshVideos() {
    loadVideos();
}

// Search functionality
let searchActive = false;

function toggleSearchPanel() {
    const panel = document.getElementById('searchPanel');
    if (panel.style.display === 'none') {
        panel.style.display = 'block';
    } else {
        panel.style.display = 'none';
        if (searchActive) {
            clearSearch();
        }
    }
}

function handleSearchKeyup(event) {
    if (event.key === 'Enter') {
        performSearch();
    }
}

function performSearch() {
    const query = document.getElementById('searchQuery').value.trim();
    const artist = document.getElementById('searchArtist').value.trim();
    const status = document.getElementById('searchStatus').value;
    const year = document.getElementById('searchYear').value;
    const sortBy = document.getElementById('sortBy').value || 'title';
    const sortOrder = document.getElementById('sortOrder').value || 'asc';
    
    // Build search parameters
    const params = new URLSearchParams();
    if (query) params.append('q', query);
    if (artist) params.append('artist', artist);
    if (status) params.append('status', status);
    if (year) params.append('year', year);
    params.append('sort', sortBy);
    params.append('order', sortOrder);
    
    // Show loading state
    const resultsInfo = document.getElementById('searchResults');
    resultsInfo.textContent = 'Searching...';
    
    // Perform search
    fetch(`/api/videos/search?${params.toString()}`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                showError('Search error: ' + data.error);
                return;
            }
            
            searchActive = true;
            displaySearchResults(data);
            updateSearchResultsInfo(data);
        })
        .catch(error => {
            console.error('Search error:', error);
            showError('Error performing search');
            resultsInfo.textContent = '';
        });
}

function displaySearchResults(data) {
    const grid = document.getElementById('videos-grid');
    
    if (data.videos && data.videos.length > 0) {
        grid.innerHTML = data.videos.map(video => `
            <div class="video-card">
                <div class="video-select">
                    <input type="checkbox" class="video-checkbox" value="${video.id}" onchange="updateSelectedCount()">
                </div>
                <div class="video-thumbnail" data-video-id="${video.id}" data-action="play">
                    <img src="/api/videos/${video.id}/thumbnail" 
                         alt="${video.title}" onerror="this.src='/static/placeholder-video.png'">
                    <div class="play-overlay">
                        <div class="play-button">‚ñ∂</div>
                    </div>
                </div>
                <div class="video-info">
                    <h3>${video.title}</h3>
                    <p>Artist: ${video.artist_name || 'Unknown'}</p>
                    <p>Status: ${video.status}</p>
                    ${video.year ? `<p>Year: ${video.year}</p>` : ''}
                </div>
                <div class="video-actions">
                    <button data-video-id="${video.id}" data-action="view" class="btn-icon" title="View Details">
                        <i class="icon-eye"></i>
                    </button>
                    <button data-video-id="${video.id}" data-action="edit" class="btn-icon" title="Edit Video">
                        <i class="icon-edit"></i>
                    </button>
                    <button data-video-id="${video.id}" data-action="refresh-metadata" class="btn-icon" title="Refresh Metadata">
                        <i class="icon-refresh"></i>
                    </button>
                    ${video.status === 'WANTED' ? 
                        `<button data-video-id="${video.id}" data-action="download" class="btn-icon" title="Download Video">
                            <i class="icon-download"></i>
                        </button>` : 
                        ''}
                    <button data-video-id="${video.id}" data-action="delete" class="btn-icon btn-danger" title="Delete Video">
                        <i class="icon-trash"></i>
                    </button>
                </div>
            </div>
        `).join('');
    } else {
        grid.innerHTML = '<p>No videos found matching your search criteria.</p>';
    }
}

function updateSearchResultsInfo(data) {
    const resultsInfo = document.getElementById('searchResults');
    resultsInfo.textContent = `Found ${data.count} of ${data.total} videos`;
}

function clearSearch() {
    // Clear search fields
    document.getElementById('searchQuery').value = '';
    document.getElementById('searchArtist').value = '';
    document.getElementById('searchStatus').value = '';
    document.getElementById('searchYear').value = '';
    
    // Clear results info
    document.getElementById('searchResults').textContent = '';
    
    // Reload all videos
    searchActive = false;
    loadVideos();
}

// Video filtering functions - previously missing
function applyVideoFilters() {
    console.log('Applying video filters...');
    
    // Get all filter values
    const filters = {
        status: document.getElementById('videoStatusFilter').value,
        quality: document.getElementById('videoQualityFilter').value,
        has_thumbnail: document.getElementById('videoThumbnailFilter').value,
        source: document.getElementById('videoSourceFilter').value,
        genre: document.getElementById('videoGenreFilter').value,
        duration_min: document.getElementById('videoDurationMin').value,
        duration_max: document.getElementById('videoDurationMax').value,
        date_from: document.getElementById('videoDateFrom').value,
        date_to: document.getElementById('videoDateTo').value,
        artist: document.getElementById('videoArtistFilter').value,
        keywords: document.getElementById('videoKeywordsFilter').value,
        sort_by: document.getElementById('videoSortBy').value,
        sort_order: document.getElementById('videoSortOrder').value
    };
    
    // Build query parameters
    const params = new URLSearchParams();
    
    // Add non-empty filters
    for (const [key, value] of Object.entries(filters)) {
        if (value && value.trim() !== '') {
            params.append(key, value);
        }
    }
    
    // Make API call to search/filter videos
    fetch(`/api/videos/search?${params.toString()}`)
        .then(response => response.json())
        .then(data => {
            displaySearchResults(data);
            updateVideoFilterCount();
        })
        .catch(error => {
            console.error('Error filtering videos:', error);
            showError('Error filtering videos');
        });
}

function toggleVideoAdvancedFilters() {
    const filters = document.getElementById('videoAdvancedFilters');
    const button = document.getElementById('videoFiltersToggle');
    
    if (filters.style.display === 'none') {
        filters.style.display = 'block';
        button.textContent = 'Hide Filters';
    } else {
        filters.style.display = 'none';
        button.textContent = 'Show Filters';
    }
}

function clearAllVideoFilters() {
    // Clear all filter inputs
    document.getElementById('videoStatusFilter').value = '';
    document.getElementById('videoQualityFilter').value = '';
    document.getElementById('videoThumbnailFilter').value = '';
    document.getElementById('videoSourceFilter').value = '';
    document.getElementById('videoGenreFilter').value = '';
    document.getElementById('videoDurationMin').value = '';
    document.getElementById('videoDurationMax').value = '';
    document.getElementById('videoDateFrom').value = '';
    document.getElementById('videoDateTo').value = '';
    document.getElementById('videoArtistFilter').value = '';
    document.getElementById('videoKeywordsFilter').value = '';
    document.getElementById('videoSortBy').value = 'title';
    document.getElementById('videoSortOrder').value = 'asc';
    
    // Reload all videos
    searchActive = false;
    loadVideos();
    updateVideoFilterCount();
}

function updateVideoFilterCount() {
    const filterCount = document.getElementById('videoFilterCount');
    let activeFilters = 0;
    
    // Count active filters
    const filterElements = [
        'videoStatusFilter', 'videoQualityFilter', 'videoThumbnailFilter',
        'videoSourceFilter', 'videoGenreFilter', 'videoDurationMin', 'videoDurationMax',
        'videoDateFrom', 'videoDateTo', 'videoArtistFilter', 'videoKeywordsFilter'
    ];
    
    filterElements.forEach(id => {
        const element = document.getElementById(id);
        if (element && element.value && element.value.trim() !== '') {
            activeFilters++;
        }
    });
    
    if (activeFilters > 0) {
        filterCount.textContent = activeFilters;
        filterCount.style.display = 'inline';
    } else {
        filterCount.style.display = 'none';
    }
}

function loadVideoGenreOptions() {
    // Load available genres from the API
    fetch('/api/genres')
        .then(response => response.json())
        .then(data => {
            const genreSelect = document.getElementById('videoGenreFilter');
            if (data.video_genres && data.video_genres.length > 0) {
                // Clear existing options (except the first "All Genres" option)
                genreSelect.innerHTML = '<option value="">All Genres</option>';
                
                // Add each genre as an option
                data.video_genres.forEach(genre => {
                    const option = document.createElement('option');
                    option.value = genre;
                    option.textContent = genre;
                    genreSelect.appendChild(option);
                });
            }
        })
        .catch(error => {
            console.error('Error loading video genres:', error);
        });
}

function saveVideoSearchPreset() {
    showInfo('Video search preset functionality coming soon!');
}

function exportVideoSearchResults() {
    showInfo('Video search results export functionality coming soon!');
}

function refreshThumbnails() {
    toastConfirm('Download thumbnails for videos that are missing them?', () => {
        fetch('/api/videos/refresh-thumbnails', {
            method: 'POST'
        })
        .then(response => response.json())
        .then(result => {
            if (result.error) {
                showError('Error: ' + result.error);
            } else {
                showSuccess(result.message);
                loadVideos(); // Refresh the video list
            }
        })
        .catch(error => {
            console.error('Error refreshing thumbnails:', error);
            showError('Error refreshing thumbnails');
        });
    });
}

function viewVideo(id) {
    // Navigate to video detail page
    window.location.href = `/video/${id}`;
}

function editVideo(id) {
    // Fetch video data and populate the edit form
    fetch(`/api/videos/${id}`)
        .then(response => response.json())
        .then(video => {
            if (video.error) {
                showError('Error loading video data: ' + video.error);
                return;
            }
            
            // Populate the form with current video data
            document.getElementById('videoTitle').value = video.title || '';
            document.getElementById('videoArtist').value = video.artist_name || '';
            document.getElementById('videoYear').value = video.year || '';
            document.getElementById('videoGenre').value = (video.genres && video.genres.length > 0) ? video.genres[0] : '';
            document.getElementById('videoStatus').value = video.status || 'DOWNLOADED';
            document.getElementById('videoUrl').value = video.video_url || '';
            document.getElementById('videoThumbnailUrl').value = video.thumbnail_url || '';
            document.getElementById('videoDuration').value = video.duration || '';
            document.getElementById('videoImvdbId').value = video.imvdb_id || '';
            document.getElementById('moveFile').checked = true;
            
            // Store the current video ID for the form submission
            window.currentEditVideoId = id;
            
            // Reset the identify artist button and hide suggestions
            resetIdentifyArtistButton();
            document.getElementById('artistSuggestions').style.display = 'none';
            
            // Show the edit modal
            document.getElementById('editVideoModal').style.display = 'block';
        })
        .catch(error => {
            console.error('Error fetching video data:', error);
            showError('Error loading video data');
        });
}

function closeEditVideoModal() {
    document.getElementById('editVideoModal').style.display = 'none';
    document.getElementById('artistSuggestions').style.display = 'none';
    resetIdentifyArtistButton();
    window.currentEditVideoId = null;
}

// Handle edit video form submission
document.getElementById('editVideoForm').addEventListener('submit', function(e) {
    e.preventDefault();
    
    if (!window.currentEditVideoId) {
        showWarning('No video selected for editing');
        return;
    }
    
    const formData = new FormData(this);
    const updateData = {
        title: formData.get('title'),
        artist_name: formData.get('artist_name'),
        year: formData.get('year') ? parseInt(formData.get('year')) : null,
        genres: formData.get('genre') ? [formData.get('genre')] : [],
        status: formData.get('status'),
        video_url: formData.get('video_url'),
        thumbnail_url: formData.get('thumbnail_url'),
        duration: formData.get('duration') ? parseInt(formData.get('duration')) : null,
        imvdb_id: formData.get('imvdb_id'),
        move_file: formData.get('move_file') === 'on'
    };
    
    // Remove empty string values
    Object.keys(updateData).forEach(key => {
        if (updateData[key] === '') {
            updateData[key] = null;
        }
    });
    
    fetch(`/api/videos/${window.currentEditVideoId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
    })
    .then(response => response.json())
    .then(result => {
        if (result.error) {
            showError('Error updating video: ' + result.error);
        } else {
            showSuccess('Video updated successfully!');
            closeEditVideoModal();
            loadVideos(); // Refresh the video list
        }
    })
    .catch(error => {
        console.error('Error updating video:', error);
        showError('Error updating video');
    });
});

function playVideo(videoId, title, localPath, videoUrl) {
    // Set modal title
    document.getElementById('videoModalTitle').textContent = title || 'Playing Video';
    
    // Create video player
    const playerDiv = document.getElementById('videoPlayer');
    
    // Prioritize local file if available
    if (localPath && localPath !== 'null' && localPath !== 'undefined') {
        // Check if this is a known unsupported format that needs VLC streaming
        let needsVLCStreaming = localPath.toLowerCase().endsWith('.mkv') || 
                                localPath.toLowerCase().endsWith('.avi');
        
        if (needsVLCStreaming) {
            // Use direct streaming for unsupported formats
            playerDiv.innerHTML = `
                <div class="video-loading">
                    <h3>üé¨ Starting Video Stream...</h3>
                    <p>Transcoding video for browser playback using FFmpeg.</p>
                    <div class="loading-spinner"></div>
                </div>
            `;
            
            // Show modal
            document.getElementById('videoModal').style.display = 'block';
            
            // Track current video ID for cleanup
            window.currentVideoId = videoId;
            
            // Use the direct streaming endpoint
            const streamUrl = `/api/videos/${videoId}/stream`;
            
            // Give it a moment to show the loading message, then start the stream
            setTimeout(() => {
                playerDiv.innerHTML = `
                    <video width="800" height="450" controls autoplay>
                        <source src="${streamUrl}" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <div class="stream-info">
                        <p><small>Streaming via FFmpeg transcoding</small></p>
                    </div>
                `;
            }, 1000);
            
            return;
        }
        
        // Determine MIME type based on file extension
        let mimeType = 'video/mp4'; // default
        if (localPath.toLowerCase().endsWith('.mkv')) {
            mimeType = 'video/x-matroska';
        } else if (localPath.toLowerCase().endsWith('.webm')) {
            mimeType = 'video/webm';
        } else if (localPath.toLowerCase().endsWith('.avi')) {
            mimeType = 'video/x-msvideo';
        } else if (localPath.toLowerCase().endsWith('.mov')) {
            mimeType = 'video/quicktime';
        }
        
        // Play local file via streaming endpoint with proper MIME type
        playerDiv.innerHTML = `
            <video width="800" height="450" controls preload="metadata">
                <source src="/api/videos/${videoId}/stream" type="${mimeType}">
                Your browser does not support the video tag or this video format.
            </video>
        `;
        
        // Add error handling for video load failures
        const video = playerDiv.querySelector('video');
        
        // Add timeout for video loading
        let loadTimeout;
        let hasLoaded = false;
        
        video.addEventListener('error', function(e) {
            console.error('Video playback error:', e);
            clearTimeout(loadTimeout);
            showVideoError(videoId, localPath, mimeType, 'Video failed to load');
        });
        
        video.addEventListener('loadstart', function() {
            console.log('Video load started for:', localPath, 'Type:', mimeType);
            hasLoaded = false;
            
            // Set timeout for loading - if video doesn't load within 10 seconds, show error
            loadTimeout = setTimeout(() => {
                if (!hasLoaded) {
                    console.warn('Video loading timeout for:', localPath);
                    showVideoError(videoId, localPath, mimeType, 'Video loading timeout - format may not be supported');
                }
            }, 10000);
        });
        
        video.addEventListener('loadeddata', function() {
            console.log('Video loaded successfully:', localPath);
            hasLoaded = true;
            clearTimeout(loadTimeout);
        });
        
        video.addEventListener('canplay', function() {
            hasLoaded = true;
            clearTimeout(loadTimeout);
        });
        
        // Check if format is likely unsupported and warn immediately
        let formatUnsupported = localPath.toLowerCase().endsWith('.mkv') || 
                               localPath.toLowerCase().endsWith('.avi');
        
        if (formatUnsupported) {
            // Show immediate warning for known unsupported formats
            setTimeout(() => {
                if (!hasLoaded) {
                    console.warn('Likely unsupported format detected:', localPath);
                    showVideoError(videoId, localPath, mimeType, 'This video format may not be supported by your browser');
                }
            }, 3000); // Check after 3 seconds
        }
        
    } else if (videoUrl && videoUrl !== 'null' && videoUrl !== 'undefined') {
        // Fall back to YouTube or other URL
        if (videoUrl.includes('youtube.com') || videoUrl.includes('youtu.be')) {
            // Extract YouTube video ID
            const youtubeId = extractYouTubeId(videoUrl);
            if (youtubeId) {
                playerDiv.innerHTML = `
                    <iframe width="800" height="450" 
                            src="https://www.youtube.com/embed/${youtubeId}" 
                            frameborder="0" 
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                            allowfullscreen>
                    </iframe>
                `;
            }
        } else {
            // For other video URLs, try using HTML5 video element
            playerDiv.innerHTML = `
                <video width="800" height="450" controls>
                    <source src="${videoUrl}" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            `;
        }
    } else {
        showWarning('No video file available for playback');
        return;
    }
    
    // Show modal
    document.getElementById('videoModal').style.display = 'block';
}

function extractYouTubeId(url) {
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const match = url.match(regExp);
    return (match && match[2].length === 11) ? match[2] : null;
}

function closeVideoModal() {
    const modal = document.getElementById('videoModal');
    const playerDiv = document.getElementById('videoPlayer');
    
    // Clear the player to stop playback
    playerDiv.innerHTML = '';
    
    // Hide modal
    modal.style.display = 'none';
    
    // Clear current video ID
    window.currentVideoId = null;
}

// Close modal when clicking outside of it
window.onclick = function(event) {
    const videoModal = document.getElementById('videoModal');
    const editModal = document.getElementById('editVideoModal');
    
    if (event.target === videoModal) {
        closeVideoModal();
    }
    
    if (event.target === editModal) {
        closeEditVideoModal();
    }
}

function downloadVideo(id) {
    // Removed download confirmation popup - direct download
    {
        fetch(`/api/videos/${id}/download`, {
            method: 'POST'
        })
        .then(response => response.json())
        .then(result => {
            if (result.error) {
                showError('Error: ' + result.error);
            } else {
                showSuccessToast('Video queued for download');
                loadVideos();
            }
        })
        .catch(error => {
            console.error('Error downloading video:', error);
            showErrorToast('Error queuing video for download');
        });
    }
}

function transcodeVideo(id) {
    toastConfirm('Convert this video to MP4 for better browser compatibility? This may take a few minutes depending on file size.', () => {
        // Show progress in the modal
        const playerDiv = document.getElementById('videoPlayer');
        playerDiv.innerHTML = `
            <div class="transcoding-progress">
                <h3>üîÑ Converting Video...</h3>
                <p>Converting to MP4 format for better browser compatibility.</p>
                <p>This may take several minutes depending on the video size.</p>
                <div class="progress-spinner"></div>
                <button onclick="closeVideoModal()" class="btn btn-secondary">Close</button>
            </div>
        `;
        
        fetch(`/api/videos/${id}/transcode`, {
            method: 'POST'
        })
        .then(response => response.json())
        .then(result => {
            if (result.error) {
                playerDiv.innerHTML = `
                    <div class="transcoding-error">
                        <h3>‚ùå Conversion Failed</h3>
                        <p>Error: ${result.error}</p>
                        <button onclick="closeVideoModal()" class="btn btn-primary">Close</button>
                    </div>
                `;
            } else {
                // Start checking status
                checkTranscodingStatus(id);
            }
        })
        .catch(error => {
            console.error('Error transcoding video:', error);
            playerDiv.innerHTML = `
                <div class="transcoding-error">
                    <h3>‚ùå Conversion Failed</h3>
                    <p>Error starting video conversion: ${error.message}</p>
                    <button onclick="closeVideoModal()" class="btn btn-primary">Close</button>
                </div>
            `;
        });
    });
}

function checkTranscodingStatus(id) {
    const playerDiv = document.getElementById('videoPlayer');
    
    fetch(`/api/videos/${id}/transcode/status`)
        .then(response => response.json())
        .then(result => {
            if (result.status === 'completed') {
                playerDiv.innerHTML = `
                    <div class="transcoding-success">
                        <h3>‚úÖ Conversion Complete!</h3>
                        <p>Video has been converted to MP4 format.</p>
                        <button onclick="refreshAndPlay(${id})" class="btn btn-success">Play Video</button>
                        <button onclick="closeVideoModal()" class="btn btn-secondary">Close</button>
                    </div>
                `;
            } else if (result.status === 'processing' || result.status === 'not_started') {
                // Keep checking every 5 seconds
                setTimeout(() => checkTranscodingStatus(id), 5000);
            } else {
                playerDiv.innerHTML = `
                    <div class="transcoding-error">
                        <h3>‚ùå Conversion Status Unknown</h3>
                        <p>Status: ${result.status}</p>
                        <button onclick="closeVideoModal()" class="btn btn-primary">Close</button>
                    </div>
                `;
            }
        })
        .catch(error => {
            console.error('Error checking transcoding status:', error);
            // Stop checking on error
        });
}

function tryPlayAnyway(videoId, title, localPath, videoUrl) {
    // Proceed with normal playback attempt
    const playerDiv = document.getElementById('videoPlayer');
    
    // Determine MIME type based on file extension
    let mimeType = 'video/mp4'; // default
    if (localPath.toLowerCase().endsWith('.mkv')) {
        mimeType = 'video/x-matroska';
    } else if (localPath.toLowerCase().endsWith('.webm')) {
        mimeType = 'video/webm';
    } else if (localPath.toLowerCase().endsWith('.avi')) {
        mimeType = 'video/x-msvideo';
    } else if (localPath.toLowerCase().endsWith('.mov')) {
        mimeType = 'video/quicktime';
    }
    
    // Play local file via streaming endpoint with proper MIME type
    playerDiv.innerHTML = `
        <video width="800" height="450" controls preload="metadata">
            <source src="/api/videos/${videoId}/stream" type="${mimeType}">
            Your browser does not support the video tag or this video format.
        </video>
    `;
    
    // Add all the same error handling as the normal playback
    const video = playerDiv.querySelector('video');
    let loadTimeout;
    let hasLoaded = false;
    
    video.addEventListener('error', function(e) {
        console.error('Video playback error:', e);
        clearTimeout(loadTimeout);
        showVideoError(videoId, localPath, mimeType, 'Video failed to load');
    });
    
    video.addEventListener('loadstart', function() {
        console.log('Video load started for:', localPath, 'Type:', mimeType);
        hasLoaded = false;
        
        loadTimeout = setTimeout(() => {
            if (!hasLoaded) {
                console.warn('Video loading timeout for:', localPath);
                showVideoError(videoId, localPath, mimeType, 'Video loading timeout - format may not be supported');
            }
        }, 10000);
    });
    
    video.addEventListener('loadeddata', function() {
        console.log('Video loaded successfully:', localPath);
        hasLoaded = true;
        clearTimeout(loadTimeout);
    });
    
    video.addEventListener('canplay', function() {
        hasLoaded = true;
        clearTimeout(loadTimeout);
    });
}

function showVideoError(videoId, localPath, mimeType, errorMessage) {
    const playerDiv = document.getElementById('videoPlayer');
    let unsupportedVideoFormat = localPath.toLowerCase().endsWith('.mkv') || 
                                 localPath.toLowerCase().endsWith('.avi');
    
    playerDiv.innerHTML = `
        <div class="video-error">
            <p>‚ö†Ô∏è ${errorMessage}</p>
            <p><strong>File:</strong> ${localPath}</p>
            <p><strong>Type:</strong> ${mimeType}</p>
            ${unsupportedVideoFormat ? `
                <p><em>Note: .mkv and .avi files have limited browser support.</em></p>
                <button onclick="transcodeVideo(${videoId})" class="btn btn-warning">Convert to MP4</button>
            ` : ''}
            <button onclick="closeVideoModal()" class="btn btn-primary">Close</button>
        </div>
    `;
}

function refreshAndPlay(id) {
    // Refresh the video list to get updated paths
    loadVideos();
    
    // Close modal and show success message
    closeVideoModal();
    showSuccess('Video converted successfully! Try playing it again.');
}

function refreshVideoMetadata(id) {
    toastConfirm('Refresh metadata for this video from IMVDb? This will update year, directors, producers, and thumbnail information.', () => {
        // Find the video card to show loading state
        const videoCard = document.querySelector(`[data-video-id="${id}"]`).closest('.video-card');
        const originalContent = videoCard.innerHTML;
        
        // Show loading state
        videoCard.innerHTML = `
            <div style="padding: 20px; text-align: center;">
                <div class="loading-spinner"></div>
                <p>Refreshing metadata from IMVDb...</p>
            </div>
        `;
        
        fetch(`/api/videos/${id}/refresh-metadata`, {
            method: 'POST'
        })
        .then(response => response.json())
        .then(result => {
            if (result.error) {
                showError('Error: ' + result.error);
                // Restore original content on error
                videoCard.innerHTML = originalContent;
            } else if (result.success === false) {
                showWarning('Warning: ' + result.message);
                // Restore original content if no match found
                videoCard.innerHTML = originalContent;
            } else {
                showSuccess('Metadata refreshed successfully!');
                loadVideos(); // Refresh the entire list to show updated data
            }
        })
        .catch(error => {
            console.error('Error refreshing metadata:', error);
            showError('Error refreshing metadata');
            // Restore original content on error
            videoCard.innerHTML = originalContent;
        });
    });
}

function refreshAllMetadata() {
    toastConfirm('Refresh metadata from IMVDb for all videos that don\'t have IMVDb data? This may take several minutes.', () => {
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = 'Refreshing...';
        button.disabled = true;
        
        fetch('/api/videos/refresh-all-metadata', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                force_refresh: false,
                limit: 100  // Process first 100 videos to avoid timeouts
            })
        })
        .then(response => response.json())
        .then(result => {
            button.textContent = originalText;
            button.disabled = false;
            
            if (result.error) {
                showError('Error: ' + result.error);
            } else {
                const message = `Metadata refresh completed!\n\nProcessed: ${result.processed}\nUpdated: ${result.updated}\nErrors: ${result.errors}`;
                showSuccess(message);
                loadVideos(); // Refresh the video list
            }
        })
        .catch(error => {
            console.error('Error refreshing all metadata:', error);
            showError('Error refreshing metadata');
            button.textContent = originalText;
            button.disabled = false;
        });
    });
}

function refreshAllMetadataForce() {
    toastConfirm('Force refresh metadata from IMVDb for ALL videos? This will re-fetch data even for videos that already have IMVDb metadata. This may take a very long time.', () => {
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = 'Force Refreshing...';
        button.disabled = true;
        
        fetch('/api/videos/refresh-all-metadata', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                force_refresh: true,
                limit: 50  // Smaller limit for force refresh
            })
        })
        .then(response => response.json())
        .then(result => {
            button.textContent = originalText;
            button.disabled = false;
            
            if (result.error) {
                showError('Error: ' + result.error);
            } else {
                const message = `Force metadata refresh completed!\n\nProcessed: ${result.processed}\nUpdated: ${result.updated}\nErrors: ${result.errors}`;
                showSuccess(message);
                loadVideos(); // Refresh the video list
            }
        })
        .catch(error => {
            console.error('Error force refreshing all metadata:', error);
            showError('Error refreshing metadata');
            button.textContent = originalText;
            button.disabled = false;
        });
    });
}

function deleteVideo(id) {
    toastConfirm('Are you sure you want to delete this video? This action cannot be undone.', () => {
        fetch(`/api/videos/${id}`, {
            method: 'DELETE'
        })
        .then(response => response.json())
        .then(result => {
            if (result.error) {
                showError('Error: ' + result.error);
            } else {
                showSuccess('Video deleted successfully!');
                loadVideos();
            }
        })
        .catch(error => {
            console.error('Error deleting video:', error);
            showError('Error deleting video');
        });
    });
}

function identifyArtist() {
    const videoId = window.currentEditVideoId;
    if (!videoId) {
        showWarning('No video selected');
        return;
    }
    
    const button = document.getElementById('identifyArtistBtn');
    button.textContent = 'üîÑ Identifying...';
    button.disabled = true;
    
    // Store the request so it can be aborted if needed
    const abortController = new AbortController();
    window.currentIdentifyRequest = abortController;
    
    fetch(`/api/videos/${videoId}/identify-artist`, {
        method: 'POST',
        signal: abortController.signal
    })
    .then(response => response.json())
    .then(result => {
        // Only process if this request is still current
        if (window.currentIdentifyRequest === abortController) {
            resetIdentifyArtistButton();
            
            if (result.error) {
                showError('Error identifying artist: ' + result.error);
                return;
            }
            
            displayArtistSuggestions(result);
        }
    })
    .catch(error => {
        // Only show error if request wasn't aborted
        if (window.currentIdentifyRequest === abortController && error.name !== 'AbortError') {
            console.error('Error identifying artist:', error);
            showError('Error identifying artist');
        }
        
        // Reset button if this was the current request
        if (window.currentIdentifyRequest === abortController) {
            resetIdentifyArtistButton();
        }
    });
}

function displayArtistSuggestions(data) {
    const suggestionsDiv = document.getElementById('artistSuggestions');
    
    if (!data.suggestions || data.suggestions.length === 0) {
        suggestionsDiv.innerHTML = `
            <h4>No Artist Suggestions Found</h4>
            <p>No automatic suggestions could be generated for "${data.title}".</p>
            <div class="manual-entry">
                <label>Enter artist name manually:</label>
                <div class="autocomplete-container">
                    <input type="text" id="manualArtistInput" placeholder="Enter artist name" 
                           oninput="searchExistingArtists(this.value)" 
                           onkeydown="handleAutocompleteKeydown(event)"
                           autocomplete="off">
                    <div id="artistAutocomplete" class="autocomplete-suggestions" style="display: none;"></div>
                </div>
                <button type="button" onclick="applyManualArtist()" class="btn btn-primary btn-small" style="margin-top: 5px;">Apply</button>
            </div>
        `;
        suggestionsDiv.style.display = 'block';
        return;
    }
    
    let html = `<h4>Artist Suggestions for "${data.title}":</h4>`;
    
    data.suggestions.forEach((suggestion, index) => {
        const confidenceClass = getConfidenceClass(suggestion.confidence);
        const confidencePercent = Math.round(suggestion.confidence * 100);
        
        html += `
            <div class="artist-suggestion" onclick="selectArtistSuggestion('${suggestion.artist_name}')">
                <div class="artist-suggestion-name">${suggestion.artist_name}</div>
                <div class="artist-suggestion-details">
                    <span class="artist-suggestion-confidence ${confidenceClass}">
                        ${confidencePercent}%
                    </span>
                    Source: ${suggestion.source}
                    ${suggestion.reason ? `<br><em>${suggestion.reason}</em>` : ''}
                </div>
            </div>
        `;
    });
    
    // Add manual entry option
    html += `
        <div class="manual-entry">
            <label>Or enter artist name manually:</label>
            <input type="text" id="manualArtistInput" placeholder="Enter artist name">
            <button type="button" onclick="applyManualArtist()" class="btn btn-primary btn-small" style="margin-top: 5px;">Apply</button>
        </div>
    `;
    
    suggestionsDiv.innerHTML = html;
    suggestionsDiv.style.display = 'block';
}

function getConfidenceClass(confidence) {
    if (confidence >= 0.8) return 'high';
    if (confidence >= 0.6) return 'medium';
    return 'low';
}

function selectArtistSuggestion(artistName) {
    document.getElementById('videoArtist').value = artistName;
    document.getElementById('artistSuggestions').style.display = 'none';
}

function applyManualArtist() {
    const manualInput = document.getElementById('manualArtistInput');
    const artistName = manualInput.value.trim();
    
    if (artistName) {
        document.getElementById('videoArtist').value = artistName;
        document.getElementById('artistSuggestions').style.display = 'none';
    } else {
        showWarning('Please enter an artist name');
    }
}

function resetIdentifyArtistButton() {
    // Abort any pending identify request
    if (window.currentIdentifyRequest) {
        window.currentIdentifyRequest.abort();
        window.currentIdentifyRequest = null;
    }
    
    const button = document.getElementById('identifyArtistBtn');
    if (button) {
        button.textContent = 'üîç Identify Artist';
        button.disabled = false;
    }
}

// Autocomplete functionality for artist search
let autocompleteTimeout;
let selectedAutocompleteIndex = -1;

function searchExistingArtists(query) {
    // Clear previous timeout
    if (autocompleteTimeout) {
        clearTimeout(autocompleteTimeout);
    }
    
    // Reset selection
    selectedAutocompleteIndex = -1;
    
    // Debounce the search
    autocompleteTimeout = setTimeout(() => {
        if (query.length < 2) {
            hideAutocomplete();
            return;
        }
        
        fetch(`/api/videos/search-artists?q=${encodeURIComponent(query)}`)
            .then(response => response.json())
            .then(data => {
                displayAutocomplete(data.artists);
            })
            .catch(error => {
                console.error('Error searching artists:', error);
                hideAutocomplete();
            });
    }, 300); // Wait 300ms after user stops typing
}

function displayAutocomplete(artists) {
    const autocompleteDiv = document.getElementById('artistAutocomplete');
    
    if (!artists || artists.length === 0) {
        hideAutocomplete();
        return;
    }
    
    let html = '';
    artists.forEach((artist, index) => {
        html += `
            <div class="autocomplete-suggestion" data-artist-name="${artist.name.replace(/"/g, '&quot;')}" data-index="${index}">
                <span class="autocomplete-suggestion-name">${artist.name}</span>
                <span class="autocomplete-suggestion-count">(${artist.video_count} videos)</span>
            </div>
        `;
    });
    
    autocompleteDiv.innerHTML = html;
    autocompleteDiv.style.display = 'block';
    
    // Add click event listeners for autocomplete suggestions
    autocompleteDiv.querySelectorAll('.autocomplete-suggestion').forEach(suggestion => {
        suggestion.addEventListener('click', function() {
            const artistName = this.getAttribute('data-artist-name');
            selectAutocompleteArtist(artistName);
        });
    });
}

function hideAutocomplete() {
    const autocompleteDiv = document.getElementById('artistAutocomplete');
    if (autocompleteDiv) {
        autocompleteDiv.style.display = 'none';
    }
    selectedAutocompleteIndex = -1;
}

function selectAutocompleteArtist(artistName) {
    document.getElementById('manualArtistInput').value = artistName;
    hideAutocomplete();
}

function handleAutocompleteKeydown(event) {
    const autocompleteDiv = document.getElementById('artistAutocomplete');
    const suggestions = autocompleteDiv.querySelectorAll('.autocomplete-suggestion');
    
    if (suggestions.length === 0) {
        return;
    }
    
    switch (event.key) {
        case 'ArrowDown':
            event.preventDefault();
            selectedAutocompleteIndex = Math.min(selectedAutocompleteIndex + 1, suggestions.length - 1);
            updateAutocompleteSelection(suggestions);
            break;
            
        case 'ArrowUp':
            event.preventDefault();
            selectedAutocompleteIndex = Math.max(selectedAutocompleteIndex - 1, -1);
            updateAutocompleteSelection(suggestions);
            break;
            
        case 'Enter':
            event.preventDefault();
            if (selectedAutocompleteIndex >= 0) {
                const selectedSuggestion = suggestions[selectedAutocompleteIndex];
                const artistName = selectedSuggestion.getAttribute('data-artist-name');
                selectAutocompleteArtist(artistName);
            }
            break;
            
        case 'Escape':
            hideAutocomplete();
            break;
    }
}

function updateAutocompleteSelection(suggestions) {
    // Remove previous selection
    suggestions.forEach(suggestion => {
        suggestion.classList.remove('selected');
    });
    
    // Add selection to current item
    if (selectedAutocompleteIndex >= 0) {
        suggestions[selectedAutocompleteIndex].classList.add('selected');
    }
}

// Hide autocomplete when clicking outside
document.addEventListener('click', function(event) {
    const autocompleteContainer = document.querySelector('.autocomplete-container');
    if (autocompleteContainer && !autocompleteContainer.contains(event.target)) {
        hideAutocomplete();
    }
});

// Bulk Selection Functions
function toggleSelectAll() {
    const selectAllCheckbox = document.getElementById('selectAllVideos');
    const videoCheckboxes = document.querySelectorAll('.video-checkbox');
    
    videoCheckboxes.forEach(checkbox => {
        checkbox.checked = selectAllCheckbox.checked;
    });
    
    updateSelectedCount();
}

function updateSelectedCount() {
    const selectedCheckboxes = document.querySelectorAll('.video-checkbox:checked');
    const count = selectedCheckboxes.length;
    
    document.getElementById('selectedCount').textContent = count;
    document.getElementById('deleteSelectedBtn').disabled = count === 0;
    
    // Update select all checkbox state
    const selectAllCheckbox = document.getElementById('selectAllVideos');
    const videoCheckboxes = document.querySelectorAll('.video-checkbox');
    
    if (count === 0) {
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.checked = false;
    } else if (count === videoCheckboxes.length) {
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.checked = true;
    } else {
        selectAllCheckbox.indeterminate = true;
    }
}

function deleteSelectedVideos() {
    const selectedCheckboxes = document.querySelectorAll('.video-checkbox:checked');
    const videoIds = Array.from(selectedCheckboxes).map(checkbox => parseInt(checkbox.value));
    
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    const confirmed = confirm(`Are you sure you want to delete ${videoIds.length} selected video(s)?\n\nThis action cannot be undone.`);
    
    if (confirmed) {
        const deleteBtn = document.getElementById('deleteSelectedBtn');
        deleteBtn.disabled = true;
        deleteBtn.innerHTML = 'üîÑ Deleting...';
        
        fetch('/api/videos/bulk/delete', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                video_ids: videoIds
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.deleted_count > 0) {
                showSuccess(`Successfully deleted ${data.deleted_count} video(s)`);
                if (data.failed_count > 0) {
                    showWarning(`Failed to delete ${data.failed_count} video(s)`);
                }
                // Refresh the video list
                loadVideos();
            } else {
                showError('Failed to delete videos: ' + (data.error || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Error deleting videos:', error);
            showError('Failed to delete videos: ' + error.message);
        })
        .finally(() => {
            deleteBtn.disabled = false;
            deleteBtn.innerHTML = 'üóëÔ∏è Delete Selected (<span id="selectedCount">0</span>)';
            // Reset selection
            document.getElementById('selectAllVideos').checked = false;
            updateSelectedCount();
        });
    }
}

</script>

<!-- Video Thumbnail Management Modal -->
<div id="videoThumbnailModal" class="modal" style="z-index: 2000;">
    <div class="modal-content" style="width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
            <h3>üñºÔ∏è Video Thumbnail Management</h3>
            <span class="modal-close" onclick="closeVideoThumbnailModal()">&times;</span>
        </div>
        <div class="modal-body">
            <!-- Current Thumbnail Display -->
            <div class="current-thumbnail-section">
                <div class="thumbnail-display">
                    <div class="thumbnail-container" id="videoThumbnailContainer">
                        <img id="currentVideoThumbnailImg" src="" alt="Video thumbnail" style="display: none; max-width: 300px; max-height: 300px;">
                        <div id="noVideoThumbnailPlaceholder" class="no-thumbnail-placeholder">
                            <div class="placeholder-icon">üñºÔ∏è</div>
                            <div class="placeholder-text">No thumbnail available</div>
                        </div>
                        <div class="thumbnail-overlay" id="videoThumbnailOverlay" style="display: none;">
                            <div class="thumbnail-actions-overlay">
                                <button onclick="cropVideoThumbnail()" class="btn-overlay" title="Crop">‚úÇÔ∏è</button>
                                <button onclick="replaceVideoThumbnail()" class="btn-overlay" title="Replace">üîÑ</button>
                                <button onclick="deleteVideoThumbnail()" class="btn-overlay" title="Delete">üóëÔ∏è</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Thumbnail Metadata -->
                    <div class="thumbnail-metadata" id="videoThumbnailMetadata" style="display: none;">
                        <h5>Thumbnail Information:</h5>
                        <div class="metadata-grid">
                            <div class="metadata-item">
                                <span class="metadata-label">Source:</span>
                                <span class="metadata-value" id="videoThumbnailSource">-</span>
                            </div>
                            <div class="metadata-item">
                                <span class="metadata-label">Size:</span>
                                <span class="metadata-value" id="videoThumbnailSize">-</span>
                            </div>
                            <div class="metadata-item">
                                <span class="metadata-label">Format:</span>
                                <span class="metadata-value" id="videoThumbnailFormat">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Upload Methods -->
            <div class="upload-methods">
                <div class="upload-tabs">
                    <button class="upload-tab active" onclick="switchVideoUploadTab('manual')" id="videoManualUploadTab">
                        üìÅ Manual Upload
                    </button>
                    <button class="upload-tab" onclick="switchVideoUploadTab('url')" id="videoUrlUploadTab">
                        üîó From URL
                    </button>
                    <button class="upload-tab" onclick="switchVideoUploadTab('search')" id="videoSearchUploadTab">
                        üîç Search Online
                    </button>
                </div>
                
                <!-- Manual Upload Panel -->
                <div class="upload-panel active" id="videoManualUploadPanel">
                    <div class="drag-drop-area" id="videoDragDropArea">
                        <div class="drag-drop-content">
                            <div class="upload-icon">üì§</div>
                            <div class="upload-text">
                                <h4>Drag & Drop Image Here</h4>
                                <p>Or click to browse and select an image</p>
                                <small>Supported formats: JPEG, PNG, WebP, GIF (max 10MB)</small>
                            </div>
                            <input type="file" id="videoThumbnailFileInput" accept="image/*" style="display: none;">
                        </div>
                        <div class="upload-progress" id="videoUploadProgress" style="display: none;">
                            <div class="progress-bar">
                                <div class="progress-fill" id="videoUploadProgressFill"></div>
                            </div>
                            <div class="progress-text" id="videoUploadProgressText">Uploading...</div>
                        </div>
                    </div>
                </div>
                
                <!-- URL Upload Panel -->
                <div class="upload-panel" id="videoUrlUploadPanel" style="display: none;">
                    <div class="url-upload-form">
                        <div class="form-group">
                            <label for="videoThumbnailUrlInput">Image URL:</label>
                            <input type="url" id="videoThumbnailUrlInput" placeholder="https://example.com/image.jpg" class="form-control">
                        </div>
                        <div class="form-actions">
                            <button onclick="previewVideoUrlImage()" class="btn btn-info">üîç Preview</button>
                            <button onclick="uploadVideoFromUrl()" class="btn btn-primary">üì• Upload</button>
                        </div>
                        <div class="url-preview" id="videoUrlPreview" style="display: none;">
                            <img id="videoUrlPreviewImg" alt="URL preview" style="max-width: 300px; max-height: 200px;">
                        </div>
                    </div>
                </div>
                
                <!-- Search Upload Panel -->
                <div class="upload-panel" id="videoSearchUploadPanel" style="display: none;">
                    <div class="search-options">
                        <div class="form-group">
                            <label>Search Sources:</label>
                            <div class="checkbox-group">
                                <label><input type="checkbox" id="searchYoutube" checked> YouTube</label>
                                <label><input type="checkbox" id="searchImvdb" checked> IMVDb</label>
                            </div>
                        </div>
                        <div class="form-actions">
                            <button onclick="searchVideoThumbnails()" class="btn btn-primary">üîç Search Thumbnails</button>
                            <button onclick="refreshVideoThumbnailSearch()" class="btn btn-secondary" id="videoThumbnailRefreshBtn" style="display: none;">üîÑ Refresh</button>
                        </div>
                        
                        <div class="search-results" id="videoThumbnailSearchResults" style="display: none;">
                            <h5>Search Results:</h5>
                            <div class="thumbnail-results-grid" id="videoThumbnailResultsGrid">
                                <!-- Search results will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="form-actions" style="margin-top: 20px;">
                <button type="button" class="btn btn-secondary" onclick="closeVideoThumbnailModal()">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Advanced Thumbnail Cropping Modal -->
<div id="thumbnailCropModal" class="modal" style="z-index: 2500;">
    <div class="modal-content" style="width: 90%; max-width: 1000px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
            <h3>‚úÇÔ∏è Advanced Thumbnail Cropping</h3>
            <span class="modal-close" onclick="closeThumbnailCropModal()">&times;</span>
        </div>
        <div class="modal-body">
            <div class="crop-container">
                <div class="crop-workspace">
                    <div class="crop-canvas-container">
                        <canvas id="cropCanvas" style="max-width: 100%; max-height: 500px; border: 2px solid #4a90e2; background: #f0f0f0;"></canvas>
                        <div class="crop-overlay" id="cropOverlay">
                            <div class="crop-selection" id="cropSelection">
                                <div class="crop-handle crop-handle-nw" data-direction="nw"></div>
                                <div class="crop-handle crop-handle-ne" data-direction="ne"></div>
                                <div class="crop-handle crop-handle-sw" data-direction="sw"></div>
                                <div class="crop-handle crop-handle-se" data-direction="se"></div>
                                <div class="crop-handle crop-handle-n" data-direction="n"></div>
                                <div class="crop-handle crop-handle-s" data-direction="s"></div>
                                <div class="crop-handle crop-handle-e" data-direction="e"></div>
                                <div class="crop-handle crop-handle-w" data-direction="w"></div>
                                <div class="crop-center" id="cropCenter"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="crop-controls">
                    <div class="crop-presets">
                        <h4>Aspect Ratio Presets:</h4>
                        <div class="preset-buttons">
                            <button onclick="setCropAspectRatio(1)" class="btn btn-sm">1:1 Square</button>
                            <button onclick="setCropAspectRatio(16/9)" class="btn btn-sm">16:9 Widescreen</button>
                            <button onclick="setCropAspectRatio(4/3)" class="btn btn-sm">4:3 Standard</button>
                            <button onclick="setCropAspectRatio(3/2)" class="btn btn-sm">3:2 Photo</button>
                            <button onclick="setCropAspectRatio(0)" class="btn btn-sm">Free Form</button>
                        </div>
                    </div>
                    
                    <div class="crop-settings">
                        <h4>Crop Settings:</h4>
                        <div class="settings-grid">
                            <div class="setting-group">
                                <label>Width:</label>
                                <input type="number" id="cropWidth" min="1" max="2000" onchange="updateCropFromInput()">
                            </div>
                            <div class="setting-group">
                                <label>Height:</label>
                                <input type="number" id="cropHeight" min="1" max="2000" onchange="updateCropFromInput()">
                            </div>
                            <div class="setting-group">
                                <label>X Position:</label>
                                <input type="number" id="cropX" min="0" onchange="updateCropFromInput()">
                            </div>
                            <div class="setting-group">
                                <label>Y Position:</label>
                                <input type="number" id="cropY" min="0" onchange="updateCropFromInput()">
                            </div>
                        </div>
                    </div>
                    
                    <div class="crop-effects">
                        <h4>Image Effects:</h4>
                        <div class="effects-grid">
                            <div class="effect-group">
                                <label>Brightness:</label>
                                <input type="range" id="brightnessSlider" min="0" max="200" value="100" onchange="updateCropPreview()">
                                <span id="brightnessValue">100%</span>
                            </div>
                            <div class="effect-group">
                                <label>Contrast:</label>
                                <input type="range" id="contrastSlider" min="0" max="200" value="100" onchange="updateCropPreview()">
                                <span id="contrastValue">100%</span>
                            </div>
                            <div class="effect-group">
                                <label>Saturation:</label>
                                <input type="range" id="saturationSlider" min="0" max="200" value="100" onchange="updateCropPreview()">
                                <span id="saturationValue">100%</span>
                            </div>
                            <div class="effect-group">
                                <label>Blur:</label>
                                <input type="range" id="blurSlider" min="0" max="10" value="0" onchange="updateCropPreview()">
                                <span id="blurValue">0px</span>
                            </div>
                        </div>
                        <div class="effect-buttons">
                            <button onclick="resetImageEffects()" class="btn btn-sm">Reset Effects</button>
                            <button onclick="applyImageFilter('grayscale')" class="btn btn-sm">Grayscale</button>
                            <button onclick="applyImageFilter('sepia')" class="btn btn-sm">Sepia</button>
                            <button onclick="applyImageFilter('invert')" class="btn btn-sm">Invert</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="crop-preview">
                <h4>Cropped Preview:</h4>
                <div class="preview-container">
                    <canvas id="cropPreviewCanvas" style="max-width: 200px; max-height: 200px; border: 1px solid #ccc; background: #f9f9f9;"></canvas>
                    <div class="preview-info">
                        <div>Preview Size: <span id="previewSize">0x0</span></div>
                        <div>Aspect Ratio: <span id="previewAspectRatio">1:1</span></div>
                        <div>File Size: <span id="previewFileSize">~0KB</span></div>
                    </div>
                </div>
            </div>
            
            <div class="crop-actions">
                <button onclick="resetCrop()" class="btn btn-secondary">Reset</button>
                <button onclick="applyCrop()" class="btn btn-primary">Apply Crop</button>
                <button onclick="saveCroppedThumbnail()" class="btn btn-success">Save Thumbnail</button>
                <button onclick="closeThumbnailCropModal()" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>
</div>

<script>
// Video Thumbnail Management Functions
let currentVideoThumbnailId = null;

function openVideoThumbnailManager() {
    if (!window.currentEditVideoId) {
        showError('No video selected for thumbnail management');
        return;
    }
    
    currentVideoThumbnailId = window.currentEditVideoId;
    document.getElementById('videoThumbnailModal').style.display = 'block';
    
    // Load current thumbnail info
    loadVideoThumbnailInfo();
    
    // Initialize drag & drop
    initializeVideoThumbnailUpload();
}

function closeVideoThumbnailModal() {
    document.getElementById('videoThumbnailModal').style.display = 'none';
    currentVideoThumbnailId = null;
}

function switchVideoUploadTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.upload-tab').forEach(tab => tab.classList.remove('active'));
    document.getElementById(`video${tabName.charAt(0).toUpperCase() + tabName.slice(1)}UploadTab`).classList.add('active');
    
    // Update panels
    document.querySelectorAll('.upload-panel').forEach(panel => panel.style.display = 'none');
    document.getElementById(`video${tabName.charAt(0).toUpperCase() + tabName.slice(1)}UploadPanel`).style.display = 'block';
}

function loadVideoThumbnailInfo() {
    if (!currentVideoThumbnailId) return;
    
    fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail/info`)
        .then(response => response.json())
        .then(data => {
            const thumbnailImg = document.getElementById('currentVideoThumbnailImg');
            const placeholder = document.getElementById('noVideoThumbnailPlaceholder');
            const overlay = document.getElementById('videoThumbnailOverlay');
            const metadata = document.getElementById('videoThumbnailMetadata');
            
            if (data.has_thumbnail) {
                // Show thumbnail image with cache busting
                thumbnailImg.src = `/api/videos/${currentVideoThumbnailId}/thumbnail?t=${Date.now()}`;
                thumbnailImg.style.display = 'block';
                placeholder.style.display = 'none';
                overlay.style.display = 'block';
                
                // Update metadata
                document.getElementById('videoThumbnailSource').textContent = data.thumbnail_source || 'Unknown';
                document.getElementById('videoThumbnailSize').textContent = data.file_size || 'Unknown';
                document.getElementById('videoThumbnailFormat').textContent = data.format || 'Unknown';
                metadata.style.display = 'block';
            } else {
                // Show placeholder
                thumbnailImg.style.display = 'none';
                placeholder.style.display = 'block';
                overlay.style.display = 'none';
                metadata.style.display = 'none';
            }
        })
        .catch(error => {
            console.error('Error loading thumbnail info:', error);
            showError('Failed to load thumbnail information');
        });
}

function initializeVideoThumbnailUpload() {
    const dragDropArea = document.getElementById('videoDragDropArea');
    const fileInput = document.getElementById('videoThumbnailFileInput');
    
    if (!dragDropArea || !fileInput) return;
    
    // Drag & drop handlers
    dragDropArea.addEventListener('click', () => fileInput.click());
    
    dragDropArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        dragDropArea.classList.add('drag-over');
    });
    
    dragDropArea.addEventListener('dragleave', () => {
        dragDropArea.classList.remove('drag-over');
    });
    
    dragDropArea.addEventListener('drop', (e) => {
        e.preventDefault();
        dragDropArea.classList.remove('drag-over');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            handleVideoThumbnailFile(files[0]);
        }
    });
    
    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
            handleVideoThumbnailFile(e.target.files[0]);
        }
    });
}

function handleVideoThumbnailFile(file) {
    if (!file.type.startsWith('image/')) {
        showError('Please select an image file');
        return;
    }
    
    if (file.size > 10 * 1024 * 1024) { // 10MB
        showError('File size must be less than 10MB');
        return;
    }
    
    const formData = new FormData();
    formData.append('file', file);
    
    const progress = document.getElementById('videoUploadProgress');
    const progressFill = document.getElementById('videoUploadProgressFill');
    const progressText = document.getElementById('videoUploadProgressText');
    
    progress.style.display = 'block';
    progressFill.style.width = '0%';
    
    fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail/upload`, {
        method: 'POST',
        body: formData
    })
    .then(response => {
        progressFill.style.width = '100%';
        return response.json();
    })
    .then(data => {
        progress.style.display = 'none';
        
        if (data.error) {
            showError('Upload failed: ' + data.error);
        } else {
            showSuccess('Thumbnail uploaded successfully');
            loadVideoThumbnailInfo();
            refreshVideoDisplayThumbnail();
            
            // Update the thumbnail URL field in the edit form
            document.getElementById('videoThumbnailUrl').value = '';
        }
    })
    .catch(error => {
        progress.style.display = 'none';
        console.error('Upload error:', error);
        showError('Upload failed: ' + error.message);
    });
}

function previewVideoUrlImage() {
    const url = document.getElementById('videoThumbnailUrlInput').value;
    if (!url) {
        showError('Please enter an image URL');
        return;
    }
    
    const preview = document.getElementById('videoUrlPreview');
    const img = document.getElementById('videoUrlPreviewImg');
    
    img.src = url;
    preview.style.display = 'block';
}

function uploadVideoFromUrl() {
    const url = document.getElementById('videoThumbnailUrlInput').value;
    if (!url) {
        showError('Please enter an image URL');
        return;
    }
    
    fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            action: 'update',
            thumbnail_url: url
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            showError('Failed to update thumbnail: ' + data.error);
        } else {
            showSuccess('Thumbnail URL updated successfully');
            loadVideoThumbnailInfo();
            refreshVideoDisplayThumbnail();
            
            // Update the thumbnail URL field in the edit form
            document.getElementById('videoThumbnailUrl').value = url;
        }
    })
    .catch(error => {
        console.error('Error updating thumbnail:', error);
        showError('Failed to update thumbnail');
    });
}

function searchVideoThumbnails() {
    console.log('searchVideoThumbnails called, currentVideoThumbnailId:', currentVideoThumbnailId);
    
    const youtubeCheckbox = document.getElementById('searchYoutube');
    const imvdbCheckbox = document.getElementById('searchImvdb');
    
    console.log('YouTube checkbox element:', youtubeCheckbox);
    console.log('IMVDb checkbox element:', imvdbCheckbox);
    
    if (!youtubeCheckbox || !imvdbCheckbox) {
        showError('Search checkboxes not found');
        return;
    }
    
    const includeYoutube = youtubeCheckbox.checked;
    const includeImvdb = imvdbCheckbox.checked;
    
    console.log('YouTube checked:', includeYoutube, 'IMVDb checked:', includeImvdb);
    
    const sources = [];
    if (includeYoutube) sources.push('youtube');
    if (includeImvdb) sources.push('imvdb');
    
    if (sources.length === 0) {
        showError('Please select at least one search source');
        return;
    }
    
    if (!currentVideoThumbnailId) {
        showError('No video selected for thumbnail search');
        return;
    }
    
    console.log('Making API call with sources:', sources);
    
    fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail/search`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            sources: sources
        })
    })
    .then(response => {
        console.log('API response received:', response.status, response.statusText);
        return response.json();
    })
    .then(data => {
        console.log('API response data:', data);
        if (data.error) {
            showError('Search failed: ' + data.error);
        } else {
            displayVideoThumbnailResults(data.results);
        }
    })
    .catch(error => {
        console.error('Search error:', error);
        showError('Search failed: ' + error.message);
    });
}

function displayVideoThumbnailResults(results) {
    console.log('displayVideoThumbnailResults called with:', results);
    const resultsContainer = document.getElementById('videoThumbnailSearchResults');
    const grid = document.getElementById('videoThumbnailResultsGrid');
    
    console.log('Results container:', resultsContainer);
    console.log('Results container class:', resultsContainer.className);
    console.log('Results container style:', resultsContainer.style.display);
    console.log('Grid container:', grid);
    console.log('Grid container class:', grid.className);
    
    if (!resultsContainer || !grid) {
        console.error('Results container or grid not found');
        showError('Search results container not found');
        return;
    }
    
    if (results.length === 0) {
        grid.innerHTML = '<p>No thumbnails found</p>';
        console.log('No results found, showing "No thumbnails found" message');
    } else {
        const htmlContent = results.map(result => `
            <div class="thumbnail-result" onclick="selectVideoThumbnailResult('${result.url}')">
                <img src="${result.url}" alt="${result.title || 'Thumbnail'}" 
                     style="max-width: 150px; max-height: 150px; cursor: pointer;"
                     onerror="this.style.display='none'">
                <div class="result-info">
                    <small>${result.source} - ${result.quality || 'Standard'}</small>
                </div>
            </div>
        `).join('');
        
        console.log('Generated HTML content:', htmlContent);
        grid.innerHTML = htmlContent;
        console.log('Grid innerHTML set to:', grid.innerHTML);
    }
    
    resultsContainer.style.display = 'block';
    resultsContainer.style.visibility = 'visible';
    resultsContainer.style.opacity = '1';
    
    // Ensure the grid is also visible
    grid.style.display = 'block';
    grid.style.visibility = 'visible';
    
    console.log('Results container display set to block');
    console.log('Results container final style:', resultsContainer.style.cssText);
    console.log('Results container computed style:', window.getComputedStyle(resultsContainer).display);
    console.log('Grid final style:', grid.style.cssText);
    
    // Show the refresh button once results are displayed
    document.getElementById('videoThumbnailRefreshBtn').style.display = 'inline-block';
}

function selectVideoThumbnailResult(url) {
    // Update the URL input and preview
    document.getElementById('videoThumbnailUrlInput').value = url;
    previewVideoUrlImage();
    
    // Automatically upload the selected thumbnail
    uploadVideoFromUrl();
    
    // Switch back to the URL tab to show the selection
    switchVideoUploadTab('url');
}

function refreshVideoThumbnailSearch() {
    if (!currentVideoThumbnailId) {
        showError('No video selected for thumbnail refresh');
        return;
    }
    
    // Clear current results
    const resultsContainer = document.getElementById('videoThumbnailSearchResults');
    const grid = document.getElementById('videoThumbnailResultsGrid');
    
    if (resultsContainer) {
        resultsContainer.style.display = 'none';
    }
    
    if (grid) {
        grid.innerHTML = '<div class="loading-placeholder">Refreshing search results...</div>';
    }
    
    // Hide refresh button during refresh
    document.getElementById('videoThumbnailRefreshBtn').style.display = 'none';
    
    // Trigger a new search with current settings
    searchVideoThumbnails();
}

function deleteVideoThumbnail() {
    if (!confirm('Are you sure you want to delete this thumbnail?')) {
        return;
    }
    
    fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            action: 'remove'
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            showError('Failed to delete thumbnail: ' + data.error);
        } else {
            showSuccess('Thumbnail deleted successfully');
            loadVideoThumbnailInfo();
            refreshVideoDisplayThumbnail();
            
            // Clear the thumbnail URL field in the edit form
            document.getElementById('videoThumbnailUrl').value = '';
        }
    })
    .catch(error => {
        console.error('Error deleting thumbnail:', error);
        showError('Failed to delete thumbnail');
    });
}

function replaceVideoThumbnail() {
    // Switch to manual upload tab for replacement
    switchVideoUploadTab('manual');
}

function cropVideoThumbnail() {
    if (!currentVideoThumbnailId) {
        showError('No video selected for cropping');
        return;
    }
    
    // Load the current thumbnail image
    const thumbnailImg = document.getElementById('currentVideoThumbnailImg');
    if (!thumbnailImg.src || thumbnailImg.style.display === 'none') {
        showError('No thumbnail available to crop');
        return;
    }
    
    // Open crop modal
    document.getElementById('thumbnailCropModal').style.display = 'block';
    
    // Initialize cropping interface
    initializeCropInterface(thumbnailImg.src);
}

function closeThumbnailCropModal() {
    document.getElementById('thumbnailCropModal').style.display = 'none';
    // Clean up crop interface
    if (window.cropImage) {
        window.cropImage = null;
    }
}

// Advanced Cropping Functions
let cropImage = null;
let cropSelection = { x: 0, y: 0, width: 100, height: 100 };
let cropAspectRatio = 0; // 0 = free form
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let dragMode = 'move'; // 'move' or resize direction

function initializeCropInterface(imageSrc) {
    const canvas = document.getElementById('cropCanvas');
    const ctx = canvas.getContext('2d');
    
    // Load image
    cropImage = new Image();
    cropImage.crossOrigin = 'anonymous';
    cropImage.onload = function() {
        // Set canvas size
        const maxWidth = 600;
        const maxHeight = 400;
        const ratio = Math.min(maxWidth / cropImage.width, maxHeight / cropImage.height);
        
        canvas.width = cropImage.width * ratio;
        canvas.height = cropImage.height * ratio;
        
        // Draw image
        ctx.drawImage(cropImage, 0, 0, canvas.width, canvas.height);
        
        // Initialize crop selection (center 50% of image)
        const margin = 0.25;
        cropSelection = {
            x: canvas.width * margin,
            y: canvas.height * margin,
            width: canvas.width * (1 - 2 * margin),
            height: canvas.height * (1 - 2 * margin)
        };
        
        // Setup crop overlay
        setupCropOverlay();
        updateCropPreview();
        updateCropInputs();
    };
    
    cropImage.src = imageSrc;
}

function setupCropOverlay() {
    const canvas = document.getElementById('cropCanvas');
    const overlay = document.getElementById('cropOverlay');
    const selection = document.getElementById('cropSelection');
    
    // Position overlay to match canvas
    const rect = canvas.getBoundingClientRect();
    overlay.style.width = rect.width + 'px';
    overlay.style.height = rect.height + 'px';
    
    // Position selection
    updateCropSelectionDisplay();
    
    // Add event listeners
    selection.addEventListener('mousedown', handleCropMouseDown);
    document.addEventListener('mousemove', handleCropMouseMove);
    document.addEventListener('mouseup', handleCropMouseUp);
    
    // Add handle event listeners
    document.querySelectorAll('.crop-handle').forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            dragMode = handle.dataset.direction;
            isDragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
        });
    });
}

function updateCropSelectionDisplay() {
    const selection = document.getElementById('cropSelection');
    const canvas = document.getElementById('cropCanvas');
    const canvasRect = canvas.getBoundingClientRect();
    
    const scaleX = canvasRect.width / canvas.width;
    const scaleY = canvasRect.height / canvas.height;
    
    selection.style.left = (cropSelection.x * scaleX) + 'px';
    selection.style.top = (cropSelection.y * scaleY) + 'px';
    selection.style.width = (cropSelection.width * scaleX) + 'px';
    selection.style.height = (cropSelection.height * scaleY) + 'px';
}

function handleCropMouseDown(e) {
    if (!e.target.classList.contains('crop-handle')) {
        dragMode = 'move';
        isDragging = true;
        dragStart = { x: e.clientX, y: e.clientY };
    }
}

function handleCropMouseMove(e) {
    if (!isDragging) return;
    
    const deltaX = e.clientX - dragStart.x;
    const deltaY = e.clientY - dragStart.y;
    const canvas = document.getElementById('cropCanvas');
    const canvasRect = canvas.getBoundingClientRect();
    
    // Convert screen coordinates to canvas coordinates
    const scaleX = canvas.width / canvasRect.width;
    const scaleY = canvas.height / canvasRect.height;
    const scaledDeltaX = deltaX * scaleX;
    const scaledDeltaY = deltaY * scaleY;
    
    let newSelection = { ...cropSelection };
    
    switch (dragMode) {
        case 'move':
            newSelection.x += scaledDeltaX;
            newSelection.y += scaledDeltaY;
            break;
        case 'nw':
            newSelection.x += scaledDeltaX;
            newSelection.y += scaledDeltaY;
            newSelection.width -= scaledDeltaX;
            newSelection.height -= scaledDeltaY;
            break;
        case 'ne':
            newSelection.y += scaledDeltaY;
            newSelection.width += scaledDeltaX;
            newSelection.height -= scaledDeltaY;
            break;
        case 'sw':
            newSelection.x += scaledDeltaX;
            newSelection.width -= scaledDeltaX;
            newSelection.height += scaledDeltaY;
            break;
        case 'se':
            newSelection.width += scaledDeltaX;
            newSelection.height += scaledDeltaY;
            break;
        case 'n':
            newSelection.y += scaledDeltaY;
            newSelection.height -= scaledDeltaY;
            break;
        case 's':
            newSelection.height += scaledDeltaY;
            break;
        case 'e':
            newSelection.width += scaledDeltaX;
            break;
        case 'w':
            newSelection.x += scaledDeltaX;
            newSelection.width -= scaledDeltaX;
            break;
    }
    
    // Apply aspect ratio constraint
    if (cropAspectRatio > 0) {
        if (dragMode.includes('e') || dragMode.includes('w')) {
            newSelection.height = newSelection.width / cropAspectRatio;
        } else if (dragMode.includes('n') || dragMode.includes('s')) {
            newSelection.width = newSelection.height * cropAspectRatio;
        }
    }
    
    // Constrain to canvas bounds
    newSelection.x = Math.max(0, Math.min(newSelection.x, canvas.width - newSelection.width));
    newSelection.y = Math.max(0, Math.min(newSelection.y, canvas.height - newSelection.height));
    newSelection.width = Math.max(10, Math.min(newSelection.width, canvas.width - newSelection.x));
    newSelection.height = Math.max(10, Math.min(newSelection.height, canvas.height - newSelection.y));
    
    cropSelection = newSelection;
    updateCropSelectionDisplay();
    updateCropPreview();
    updateCropInputs();
    
    dragStart = { x: e.clientX, y: e.clientY };
}

function handleCropMouseUp() {
    isDragging = false;
    dragMode = 'move';
}

function setCropAspectRatio(ratio) {
    cropAspectRatio = ratio;
    
    if (ratio > 0) {
        // Adjust current selection to match aspect ratio
        const centerX = cropSelection.x + cropSelection.width / 2;
        const centerY = cropSelection.y + cropSelection.height / 2;
        
        if (cropSelection.width / cropSelection.height > ratio) {
            // Too wide, adjust width
            cropSelection.width = cropSelection.height * ratio;
        } else {
            // Too tall, adjust height
            cropSelection.height = cropSelection.width / ratio;
        }
        
        // Re-center
        cropSelection.x = centerX - cropSelection.width / 2;
        cropSelection.y = centerY - cropSelection.height / 2;
        
        // Constrain to canvas
        const canvas = document.getElementById('cropCanvas');
        cropSelection.x = Math.max(0, Math.min(cropSelection.x, canvas.width - cropSelection.width));
        cropSelection.y = Math.max(0, Math.min(cropSelection.y, canvas.height - cropSelection.height));
        
        updateCropSelectionDisplay();
        updateCropPreview();
        updateCropInputs();
    }
}

function updateCropFromInput() {
    const canvas = document.getElementById('cropCanvas');
    const width = parseInt(document.getElementById('cropWidth').value) || cropSelection.width;
    const height = parseInt(document.getElementById('cropHeight').value) || cropSelection.height;
    const x = parseInt(document.getElementById('cropX').value) || cropSelection.x;
    const y = parseInt(document.getElementById('cropY').value) || cropSelection.y;
    
    cropSelection = {
        x: Math.max(0, Math.min(x, canvas.width - width)),
        y: Math.max(0, Math.min(y, canvas.height - height)),
        width: Math.max(10, Math.min(width, canvas.width)),
        height: Math.max(10, Math.min(height, canvas.height))
    };
    
    updateCropSelectionDisplay();
    updateCropPreview();
}

function updateCropInputs() {
    document.getElementById('cropWidth').value = Math.round(cropSelection.width);
    document.getElementById('cropHeight').value = Math.round(cropSelection.height);
    document.getElementById('cropX').value = Math.round(cropSelection.x);
    document.getElementById('cropY').value = Math.round(cropSelection.y);
}

function updateCropPreview() {
    if (!cropImage) return;
    
    const previewCanvas = document.getElementById('cropPreviewCanvas');
    const previewCtx = previewCanvas.getContext('2d');
    const canvas = document.getElementById('cropCanvas');
    
    // Calculate scale factors
    const scaleX = cropImage.width / canvas.width;
    const scaleY = cropImage.height / canvas.height;
    
    // Set preview canvas size
    previewCanvas.width = cropSelection.width;
    previewCanvas.height = cropSelection.height;
    
    // Apply image effects
    const brightness = document.getElementById('brightnessSlider').value;
    const contrast = document.getElementById('contrastSlider').value;
    const saturation = document.getElementById('saturationSlider').value;
    const blur = document.getElementById('blurSlider').value;
    
    previewCtx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%) blur(${blur}px)`;
    
    // Draw cropped image
    previewCtx.drawImage(
        cropImage,
        cropSelection.x * scaleX, cropSelection.y * scaleY,
        cropSelection.width * scaleX, cropSelection.height * scaleY,
        0, 0,
        cropSelection.width, cropSelection.height
    );
    
    // Update preview info
    document.getElementById('previewSize').textContent = `${Math.round(cropSelection.width)}x${Math.round(cropSelection.height)}`;
    document.getElementById('previewAspectRatio').textContent = `${Math.round(cropSelection.width / cropSelection.height * 100) / 100}:1`;
    
    // Estimate file size (rough approximation)
    const pixels = cropSelection.width * cropSelection.height;
    const estimatedSize = Math.round(pixels * 3 / 1024); // Rough JPEG estimate
    document.getElementById('previewFileSize').textContent = `~${estimatedSize}KB`;
    
    // Update slider value displays
    document.getElementById('brightnessValue').textContent = brightness + '%';
    document.getElementById('contrastValue').textContent = contrast + '%';
    document.getElementById('saturationValue').textContent = saturation + '%';
    document.getElementById('blurValue').textContent = blur + 'px';
}

function resetImageEffects() {
    document.getElementById('brightnessSlider').value = 100;
    document.getElementById('contrastSlider').value = 100;
    document.getElementById('saturationSlider').value = 100;
    document.getElementById('blurSlider').value = 0;
    updateCropPreview();
}

function applyImageFilter(filterType) {
    const brightness = document.getElementById('brightnessSlider');
    const contrast = document.getElementById('contrastSlider');
    const saturation = document.getElementById('saturationSlider');
    
    switch (filterType) {
        case 'grayscale':
            saturation.value = 0;
            break;
        case 'sepia':
            brightness.value = 110;
            contrast.value = 90;
            saturation.value = 180;
            break;
        case 'invert':
            brightness.value = 0;
            contrast.value = 200;
            break;
    }
    
    updateCropPreview();
}

function resetCrop() {
    const canvas = document.getElementById('cropCanvas');
    const margin = 0.25;
    cropSelection = {
        x: canvas.width * margin,
        y: canvas.height * margin,
        width: canvas.width * (1 - 2 * margin),
        height: canvas.height * (1 - 2 * margin)
    };
    
    cropAspectRatio = 0;
    resetImageEffects();
    updateCropSelectionDisplay();
    updateCropPreview();
    updateCropInputs();
}

function applyCrop() {
    updateCropPreview();
    showSuccess('Crop applied to preview');
}

function saveCroppedThumbnail() {
    if (!cropImage || !currentVideoThumbnailId) {
        showError('No image or video selected');
        return;
    }
    
    // Convert preview canvas to blob
    const previewCanvas = document.getElementById('cropPreviewCanvas');
    previewCanvas.toBlob((blob) => {
        if (!blob) {
            showError('Failed to generate cropped image');
            return;
        }
        
        // Create form data
        const formData = new FormData();
        formData.append('file', blob, 'cropped_thumbnail.jpg');
        
        // Upload cropped thumbnail
        fetch(`/api/videos/${currentVideoThumbnailId}/thumbnail/upload`, {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                showError('Failed to save cropped thumbnail: ' + data.error);
            } else {
                showSuccess('Cropped thumbnail saved successfully');
                closeThumbnailCropModal();
                loadVideoThumbnailInfo();
                refreshVideoDisplayThumbnail();
            }
        })
        .catch(error => {
            console.error('Error saving cropped thumbnail:', error);
            showError('Error saving cropped thumbnail');
        });
    }, 'image/jpeg', 0.9);
}

function refreshVideoDisplayThumbnail() {
    // Refresh the thumbnail in the main video grid
    const videoCard = document.querySelector(`[data-video-id="${currentVideoThumbnailId}"]`);
    if (videoCard) {
        const thumbnailImg = videoCard.querySelector('img');
        if (thumbnailImg) {
            // Update with cache busting
            thumbnailImg.src = `/api/videos/${currentVideoThumbnailId}/thumbnail?t=${Date.now()}`;
        }
    }
    
    // Also refresh the video list if we're currently searching
    if (window.searchActive) {
        performSearch();
    } else {
        loadVideos();
    }
}

// Close thumbnail modal when clicking outside
window.addEventListener('click', function(event) {
    const thumbnailModal = document.getElementById('videoThumbnailModal');
    if (event.target === thumbnailModal) {
        closeVideoThumbnailModal();
    }
});

// Enhanced Bulk Actions Functions
function toggleBulkActionsPanel() {
    const panel = document.getElementById('bulkActionsPanel');
    if (panel.style.display === 'none' || panel.style.display === '') {
        panel.style.display = 'block';
        updateBulkButtonStates();
    } else {
        panel.style.display = 'none';
    }
}

function closeBulkActionsPanel() {
    document.getElementById('bulkActionsPanel').style.display = 'none';
}

function switchBulkTab(tabName) {
    // Hide all tab contents
    const tabContents = document.querySelectorAll('.tab-content');
    tabContents.forEach(content => content.classList.remove('active'));
    
    // Deactivate all tab buttons
    const tabButtons = document.querySelectorAll('.tab-button');
    tabButtons.forEach(button => button.classList.remove('active'));
    
    // Show selected tab content
    document.getElementById(`bulk${tabName.charAt(0).toUpperCase() + tabName.slice(1)}Tab`).classList.add('active');
    
    // Activate selected tab button
    event.target.classList.add('active');
    
    updateBulkButtonStates();
}

function updateBulkButtonStates() {
    const selectedCount = document.querySelectorAll('.video-checkbox:checked').length;
    const bulkButtons = document.querySelectorAll('.bulk-btn');
    
    bulkButtons.forEach(button => {
        button.disabled = selectedCount === 0;
    });
}

function getSelectedVideoIds() {
    const selectedCheckboxes = document.querySelectorAll('.video-checkbox:checked');
    return Array.from(selectedCheckboxes).map(checkbox => parseInt(checkbox.value));
}

function showBulkProgress(text) {
    const progressDiv = document.getElementById('bulkProgress');
    const progressText = document.getElementById('bulkProgressText');
    const progressFill = document.getElementById('bulkProgressFill');
    
    progressText.textContent = text;
    progressFill.style.width = '0%';
    progressDiv.style.display = 'block';
}

function updateBulkProgress(percentage, text) {
    const progressText = document.getElementById('bulkProgressText');
    const progressFill = document.getElementById('bulkProgressFill');
    
    if (text) progressText.textContent = text;
    progressFill.style.width = percentage + '%';
}

function hideBulkProgress() {
    document.getElementById('bulkProgress').style.display = 'none';
}

// Bulk Actions Functions
function bulkDownloadSelected() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    showBulkProgress('Initiating downloads...');
    
    fetch('/api/videos/bulk/download', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds
        })
    })
    .then(response => response.json())
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error initiating downloads: ' + data.error);
        } else {
            showSuccess(`Successfully initiated ${data.queued_count} downloads`);
            if (data.failed_count > 0) {
                showWarning(`Failed to queue ${data.failed_count} videos`);
            }
            loadVideos();
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error:', error);
        showError('Error initiating bulk downloads');
    });
}

function bulkDeleteSelected() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    const confirmed = confirm(`Are you sure you want to delete ${videoIds.length} selected video(s)?\n\nThis action cannot be undone.`);
    
    if (confirmed) {
        showBulkProgress('Deleting videos...');
        
        fetch('/api/videos/bulk/delete', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                video_ids: videoIds
            })
        })
        .then(response => response.json())
        .then(data => {
            hideBulkProgress();
            if (data.deleted_count > 0) {
                showSuccess(`Successfully deleted ${data.deleted_count} video(s)`);
            }
            if (data.failed_count > 0) {
                showWarning(`Failed to delete ${data.failed_count} video(s)`);
            }
            loadVideos();
            updateSelectedCount();
        })
        .catch(error => {
            hideBulkProgress();
            console.error('Error:', error);
            showError('Error deleting videos');
        });
    }
}

function bulkSetStatus(status) {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    showBulkProgress(`Setting status to ${status}...`);
    
    fetch('/api/videos/bulk/status', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds,
            status: status
        })
    })
    .then(response => response.json())
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error updating status: ' + data.error);
        } else {
            showSuccess(`Successfully updated status for ${data.updated_count} videos`);
            loadVideos();
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error:', error);
        showError('Error updating video status');
    });
}

function applyBulkEdit() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    const updates = {};
    
    // Collect changes
    const artistChange = document.getElementById('bulkArtistChange').value.trim();
    const yearChange = document.getElementById('bulkYearChange').value.trim();
    const statusChange = document.getElementById('bulkStatusChange').value;
    const priorityChange = document.getElementById('bulkPriorityChange').value;
    
    if (artistChange) updates.artist_name = artistChange;
    if (yearChange) updates.year = parseInt(yearChange);
    if (statusChange) updates.status = statusChange;
    if (priorityChange) updates.priority = priorityChange;
    
    if (Object.keys(updates).length === 0) {
        showError('No changes specified');
        return;
    }
    
    showBulkProgress('Applying bulk edits...');
    
    fetch('/api/videos/bulk/edit', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds,
            updates: updates
        })
    })
    .then(response => response.json())
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error applying bulk edits: ' + data.error);
        } else {
            showSuccess(`Successfully updated ${data.updated_count} videos`);
            loadVideos();
            
            // Clear form
            document.getElementById('bulkArtistChange').value = '';
            document.getElementById('bulkYearChange').value = '';
            document.getElementById('bulkStatusChange').value = '';
            document.getElementById('bulkPriorityChange').value = '';
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error:', error);
        showError('Error applying bulk edits');
    });
}

function bulkOrganizeFiles() {
    const videoIds = getSelectedVideoIds();
    if (videoIds.length === 0) {
        showError('No videos selected');
        return;
    }
    
    const options = {
        create_folders: document.getElementById('bulkCreateFolders').checked,
        rename_files: document.getElementById('bulkRenameFiles').checked,
        remove_duplicates: document.getElementById('bulkRemoveDuplicates').checked
    };
    
    showBulkProgress('Organizing files...');
    
    fetch('/api/videos/bulk/organize', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            video_ids: videoIds,
            options: options
        })
    })
    .then(response => response.json())
    .then(data => {
        hideBulkProgress();
        if (data.error) {
            showError('Error organizing files: ' + data.error);
        } else {
            showSuccess(`Successfully organized ${data.organized_count} files`);
            if (data.failed_count > 0) {
                showWarning(`Failed to organize ${data.failed_count} files`);
            }
            loadVideos();
        }
    })
    .catch(error => {
        hideBulkProgress();
        console.error('Error:', error);
        showError('Error organizing files');
    });
}

// Selection helper functions
function selectByStatus() {
    const status = prompt('Select videos by status (WANTED, DOWNLOADING, DOWNLOADED, IGNORED, FAILED):');
    if (!status) return;
    
    const videoCards = document.querySelectorAll('.video-card');
    videoCards.forEach(card => {
        const statusText = card.querySelector('.video-info p:nth-child(3)').textContent;
        const checkbox = card.querySelector('.video-checkbox');
        
        if (statusText.includes(status.toUpperCase())) {
            checkbox.checked = true;
        }
    });
    
    updateSelectedCount();
}

function selectByArtist() {
    const artist = prompt('Select videos by artist:');
    if (!artist) return;
    
    const videoCards = document.querySelectorAll('.video-card');
    videoCards.forEach(card => {
        const artistText = card.querySelector('.video-info p:nth-child(2)').textContent;
        const checkbox = card.querySelector('.video-checkbox');
        
        if (artistText.toLowerCase().includes(artist.toLowerCase())) {
            checkbox.checked = true;
        }
    });
    
    updateSelectedCount();
}

function selectByYear() {
    const year = prompt('Select videos by year:');
    if (!year) return;
    
    const videoCards = document.querySelectorAll('.video-card');
    videoCards.forEach(card => {
        const yearElement = card.querySelector('.video-info p:nth-child(4)');
        const checkbox = card.querySelector('.video-checkbox');
        
        if (yearElement && yearElement.textContent.includes(year)) {
            checkbox.checked = true;
        }
    });
    
    updateSelectedCount();
}

function deselectAll() {
    const checkboxes = document.querySelectorAll('.video-checkbox');
    checkboxes.forEach(checkbox => checkbox.checked = false);
    document.getElementById('selectAllVideos').checked = false;
    updateSelectedCount();
}

// Update the existing updateSelectedCount function to work with new bulk actions
function updateSelectedCount() {
    const selectedCheckboxes = document.querySelectorAll('.video-checkbox:checked');
    const count = selectedCheckboxes.length;
    
    document.getElementById('selectedCount').textContent = count;
    
    // Update legacy delete button
    const deleteBtn = document.getElementById('deleteSelectedBtn');
    if (deleteBtn) {
        deleteBtn.disabled = count === 0;
    }
    
    // Update bulk action buttons
    updateBulkButtonStates();
    
    // Update select all checkbox state
    const selectAllCheckbox = document.getElementById('selectAllVideos');
    const videoCheckboxes = document.querySelectorAll('.video-checkbox');
    
    if (count === 0) {
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.checked = false;
    } else if (count === videoCheckboxes.length) {
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.checked = true;
    } else {
        selectAllCheckbox.indeterminate = true;
    }
}

// Close bulk actions panel when clicking outside
window.addEventListener('click', function(event) {
    const bulkPanel = document.getElementById('bulkActionsPanel');
    const bulkButton = document.getElementById('bulkActionsToggle');
    
    if (event.target === bulkPanel) {
        closeBulkActionsPanel();
    }
});

// Pagination Functions
function updatePaginationControls() {
    // Show pagination controls if we have videos
    const showPagination = totalVideos > 0;
    document.getElementById('topPagination').style.display = showPagination ? 'flex' : 'none';
    document.getElementById('bottomPagination').style.display = showPagination ? 'flex' : 'none';
    
    if (!showPagination) return;
    
    // Update pagination info
    const startIndex = ((currentPage - 1) * pageSize) + 1;
    const endIndex = Math.min(currentPage * pageSize, totalVideos);
    const infoText = `Showing ${startIndex}-${endIndex} of ${totalVideos} videos`;
    
    document.getElementById('videoCountInfo').textContent = infoText;
    document.getElementById('videoCountInfoBottom').textContent = infoText;
    
    // Update page inputs
    document.getElementById('pageInputTop').value = currentPage;
    document.getElementById('pageInputBottom').value = currentPage;
    document.getElementById('totalPagesTop').textContent = totalPages;
    document.getElementById('totalPagesBottom').textContent = totalPages;
    document.getElementById('currentPageSize').textContent = pageSize;
    
    // Update button states
    const hasPrevious = currentPage > 1;
    const hasNext = currentPage < totalPages;
    
    document.getElementById('prevPageTop').disabled = !hasPrevious;
    document.getElementById('prevPageBottom').disabled = !hasPrevious;
    document.getElementById('nextPageTop').disabled = !hasNext;
    document.getElementById('nextPageBottom').disabled = !hasNext;
    
    // Update page size selector
    document.getElementById('pageSizeSelect').value = pageSize;
}

function nextPage() {
    if (currentPage < totalPages) {
        loadVideos(currentPage + 1, pageSize);
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function previousPage() {
    if (currentPage > 1) {
        loadVideos(currentPage - 1, pageSize);
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function goToPage(page) {
    const pageNum = parseInt(page);
    if (pageNum >= 1 && pageNum <= totalPages && pageNum !== currentPage) {
        loadVideos(pageNum, pageSize);
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    } else {
        // Reset invalid input
        document.getElementById('pageInputTop').value = currentPage;
        document.getElementById('pageInputBottom').value = currentPage;
    }
}

function changePageSize(newSize) {
    const size = parseInt(newSize);
    if (size !== pageSize) {
        pageSize = size;
        // Reset to page 1 when changing page size
        loadVideos(1, pageSize, true);
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

// Override existing loadVideos calls to use pagination
const originalLoadVideos = loadVideos;
window.refreshVideosWithPagination = function() {
    loadVideos(currentPage, pageSize);
};

// Update other functions to use the new pagination-aware reload
function refreshVideoList() {
    loadVideos(currentPage, pageSize);
}
</script>

{% endblock %}